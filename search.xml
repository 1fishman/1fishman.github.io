<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>中断与中断处理</title>
      <link href="/2019/04/01/%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/"/>
      <url>/2019/04/01/%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断就是使硬件发出通知给处理器,比如在敲击键盘的时候,键盘控制器会发送一个中断,通知操作系统有键按下,让操作系统尽快处理<br>不同的设备对应的中断不同,每个中断都通过一个唯一的数字标志,使得操作系统能够对中断进行区分,继而提供不同的处理程序.这些中断值通常被成为中断请求(IRQ)线.每个IRQ先都会呗关联一个数值量;例如在经典的PC机上,IRQ 0 是时钟中断.1是键盘中断.但是对于连接在PCi总线上的设备而言,中断是动态分配的.</p><h2 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h2><p>在操作系统中,在响应一个特定中断的时候,内核会执行一个函数,该函数叫做中断处理程序,产生中断的每个设备都有一个特定的中断处理程序.<br>对于操作系统而言,中断出息程序在尽可能端的时间内完成很重要;但是对于硬件而言,操作系统能迅速对其中断进行服务也非常重要.<br>所以中断程序首先哟啊通知硬件设备中断已接受.还要运行中断函数处理.例如要把硬件网络接收到的数据拷贝到内存,但是现在网速特别块,所以之后的工作量会很大.因此将响应中断分为两部分.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">在操作系统中一般中断分为两部分.中断处理程序是上半部 ---接收到一个中断,它就立即开始执行,但是只做有严格实现的工作.例如对接收的中断进行应答或复位硬件.能够允许稍后完后才能的工作会推迟到下半部.<br></code></pre></td></tr></table></figure></p><p>linux的中断处理程序是无须重入的,淡一个给定的中断处理程序正在执行,相应的中断线上的所有处理器上的都会被屏蔽掉.</p><h2 id="注册中断处理程序"><a href="#注册中断处理程序" class="headerlink" title="注册中断处理程序"></a>注册中断处理程序</h2><p>每个设备都有相关的驱动程序,如果硬件使用中断,应该注册一个中断处理程序.通过reques_irq()函数注册,并且激活给定的中断线,以处理中断.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">int request_irq(unsigned int irq,  表示要分配的中断号<br>                irq_handler_t handler, //handler是一个指针,指向处理这个中断的实际中断处理程序<br>                unsigned long flags, //标志位: IRQF_FISABLED 表示不响应其他中断;IRQF_TIMER为系统定时器的中断处理而准备的;IRQF_SHARED:表明在多个中断处理程序之间共享中断线.<br>                const char *name, // 是与中断相关的设备的ASCII文本表示<br>                void *dev) // 拥有共享中断线,dev讲提供唯一的标识信息.当删除中断处理程序需要释放时,能够知道删除哪一个.<br></code></pre></td></tr></table></figure></p><p>request_irq()成功会返回0,否则返回非0值.<br>这里request_irq函数可能会睡眠,因此不能在中断上下文或者其他不允许阻塞的代码中调用该函数.<br>中断线共享仅仅指的是中断号共享,并不是处理程序共享.</p><h2 id="共享的中断处理程序"><a href="#共享的中断处理程序" class="headerlink" title="共享的中断处理程序"></a>共享的中断处理程序</h2><p>对于共享中断线的设备,首先request_irq()的flag参数为IRQF_SHARED标志<br>对于dev参数必须唯一.指向任意设备结构的指针就可以满足这一要求;通常选择设备结构,因为它是唯一的.这里设备结构是你要想响应的设备结构.<br>中断处理程序必须能够区分它的设备是否真的产生了中断.这需要硬件的支持,也需要程序中有相关的处理逻辑.</p><h2 id="释放中断处理程序"><a href="#释放中断处理程序" class="headerlink" title="释放中断处理程序"></a>释放中断处理程序</h2><p>使用free_irq(unsigned int irq, void *dev);<br>如果中断线是共享的,则传入dev参数,删除此dev对应的处理程序,知道最后一个处理程序时才会被禁用此中断线;如果不是共享的,则在删除处理程序的同时禁用此中断线.  </p><h2 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h2><p>上面提到了中断上下文.其实在执行一个中断处理程序时,内核处于中断上下文中.<br>中断上下文和进程没有瓜葛,因为没有后备进程,所以中断上下文不可以睡眠.因此在中断上下文中不能调用睡眠的函数.<br>在中断上下文具有较为严格的时间限制,所有的中断处理程序必须尽可能的迅速,简洁.尽量把工作从中断处理程序中分离出来.放在下半部执行．　　<br>在每个处理中有一个中断处理栈，大小为１页. 在栈中处理中断程序.</p><h2 id="中断控制"><a href="#中断控制" class="headerlink" title="中断控制"></a>中断控制</h2><p>禁止指定中断线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">void disable_irq(unsigned int irq);//会等待当前处理程序完成后才返回<br>void diable_irq_nosync(unsigned int irq);//强制返回<br>void enable_irq(unsigned int irq);<br>void synchronized_irq(unsigned int irq);<br></code></pre></td></tr></table></figure></p><p>前两个函数禁止中断控制器上制定的中断线.synchronized_irq等待一个特定的中断处理程序的退出.  对于调用禁用函数可以嵌套,但是有一点就是调用多少次禁用中断线函数,就要调用多少次启动函数才能够重新激活.</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程调度</title>
      <link href="/2019/04/01/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
      <url>/2019/04/01/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><p>linux采用两种不同的优先级范围.<br>第一种用nice值,范围为-20到19,越低优先级越高.<br>第二种是实时优先级,从0-99,越大优先级越高.  </p><p>在系统调度中总会解决I/O密集型的和CPU密集型的进程的协调,I/O密集型要求有更好的响应性,而执行时间应该更少.CPU要求有更好的执行时间,而不是花费更多时间用来调度.</p><h2 id="调度器类"><a href="#调度器类" class="headerlink" title="调度器类"></a>调度器类</h2><p>linux调度器是以模块方式提供的,每个模块化结构成为调度器类,允许多种不同的可动态添加的调度算法并存.每个调度器都有一个优先级,会按照优先级顺序便利调度类,拥有一个可执行进程的最高优先级的调度器类胜出,选出下面要执行的一个程序.</p><h2 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h2><p>在linux中采用公平调度算法CFS,允许每个进程运行一段时间,循环轮转,选择运行最少的进程作为下一个运行进程,而不在采用分配给每个进程时间片.CFS在所有可运行进程总数基础上计算出一个进程应该运行多久.通过用nice值作为进程获得处理器运行比的权重,越低的优先级进程获得更低的处理器使用权重.在这里nice值并不是通过绝对值值来进行划分的,而是通过相对差值来分配权重的.避免了优先级差值不大的两个进程得到的处理器使用权重相差过大的情况.<br>在这里是由操作系统来确定进程应该使用多久,假设nice=0的进程分配时间片为100ms,则另一个nice=20的进程时间片为5ms.<br>如果按照绝对差值来分配时间片可能出现下列情况:<br>两个进程优先级分别为0和1,一个为100ms,则另一个为95ms,这时候基本没有问题.但是当两个优先级分别为18和19,那么一个为10ms,一个为5ms,这样前者比后者多出了一倍的处理器时间,是相对不合理的.</p><h2 id="linux调度的实现"><a href="#linux调度的实现" class="headerlink" title="linux调度的实现"></a>linux调度的实现</h2><h3 id="时间记账"><a href="#时间记账" class="headerlink" title="时间记账"></a><strong>时间记账</strong></h3><p>CFS不再有时间片概念,维护每个进程运行的时间的记账,保存在进程描述符中.<br>每个进程都有一个虚拟运行时间,该运行时间的计算是所有可运行进程总数的标准化(是被加权的).虚拟时间以ns为单位.CFS使用vruntime变量来记录一个程序到底运行了多长时间以及还应该在运行多久.<br>vruntime运行时间计算如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">首先的到当前进程的执行时间,然后在根据当前可运行进程总数对运行时间进行加权计算,在将权重值与当前进程的vruntime相加.<br>vruntime准确的测量给定进程的运行时间,而且可知道谁应该是下一个被运行的进程,因为他是根据运行时间最小的进程优先调度的.<br></code></pre></td></tr></table></figure></p><h3 id="进程选择"><a href="#进程选择" class="headerlink" title="进程选择"></a><strong>进程选择</strong></h3><p>主要选择具有最小vruntime的任务;通过使用红黑树来保存这些进程</p><h3 id="调度器入口"><a href="#调度器入口" class="headerlink" title="调度器入口"></a><strong>调度器入口</strong></h3><p>进程调度的时候首先是以调度器的优先级为顺序从高到低一次检查每个调度类,并且从最高优先级的调度类中选择最高优先级的进程.这样就找到最高优先级的进程,也就是vruntime最小的进程.</p><h3 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a><strong>睡眠和唤醒</strong></h3><p>内核操作: 首先标记自己为休眠状态,从可执行红黑树中移除,放入等待队列.在选择一个可执行进程.唤醒相反.<br>等待队列: 维护一个等待队列,当要休眠的时候放入到等待队列.编码是一个while(true)循环中等待,在被唤醒后在此检查条件是否为真,为真就会退出循环,将自己移除出等待队列,加入可执行红黑树中.<br>唤醒:唤醒操作通过函数wake_up()进行,唤醒指定的等待队列上的所有进程.</p><h2 id="抢占和上下文切换"><a href="#抢占和上下文切换" class="headerlink" title="抢占和上下文切换"></a>抢占和上下文切换</h2><p>内核中有一个参数为need_resched参数,表明是否需要重新执行一次调度,此过程称为抢占.</p><ul><li>用户抢占:　在系统调用返回用户控件或从中断处理程序返回用户空间是会发生用户抢占，当然need_resched参数要设置</li><li>内核抢占: 除了need_resched参数还有一个preempt_count参数,表明是否持有锁,在preempt_count为0的时候说明在执行任务持有锁,此次抢占是不安全的.知道当前新进程持有的所有锁都释放了,才会重新执行调度.</li></ul><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用在用户空间进程和硬件设备之间添加了一个中间层,作用有三个:</p><ol><li>首先为用户空间提供了一种硬件的抽象接口.这样应用程序不管磁盘类型和介质,不管文件系统是那种类型</li><li>第二 系统调用保证了系统的稳定和安全.作为硬件设备和应用程序之间的中间人可以基于权限,用户类型和其他规则对需要进行的访问进行裁决,避免引用程序不正当的使用硬件设备.</li><li>每个进程都运行在虚拟系统中,而在用户控件和系统的其余部分提供这样一层公共接口.在linux中系统调用是用户空间进入内核的唯一手段,除了异常和陷入外,他们是内核唯一的合法入口.</li></ol><h3 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a><strong>系统调用</strong></h3><p>在linux中,每个系统调用被富裕一个系统调用好. 这样就可以根据一个独一无二的号关联系统调用.进程不会提及系统调用的名称.如果一个系统调用删除,他所占用的系统调用号不允许被回收,否则以前编译过的代码调用此系统调用,但是事实上却调用另一个系统调用容易引发错误.如果一个系统调用被删除会用sys_ni_syscall()替换,此函数返回-ENOSYS.内核记录了系统调用表中的所有已注册过的系统调用的列表.存储在sys_call_table中. </p><h3 id="指定系统调用"><a href="#指定系统调用" class="headerlink" title="指定系统调用"></a><strong>指定系统调用</strong></h3><p>所有的系统调用陷入内核方式都一样,所以必须吧系统调用号一并创给内核.在x86上,系统调用号通过eax寄存器传递给内核.在陷入内核前,用户空间就把响应系统调用锁对应的号放入eax中.</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a><strong>参数传递</strong></h3><p>调用系统调用有时需要一些参数,最简单的办法是把参数也存放在寄存器里.在ebx ecx edx esi edi按照顺序存放前5个参数.应用用一个单独的寄存器存放指向所有这些参数在用户空间地址的指针.给用户空间的返回值也通过寄存器传递.</p><h3 id="调用参数限制"><a href="#调用参数限制" class="headerlink" title="调用参数限制"></a><strong>调用参数限制</strong></h3><p>在进行系统调用之前会先检查他们所有的参数是否合法有效.在接受用户空间的指针前,内核必须保证:</p><ul><li>指针指向的内存区域属于用户空间.进程决不能哄骗内核去读内核空间的数据.</li><li>指针指向的内核区域在进程的地址空间里.进程绝不能哄骗内核去读取其他进程的数据.</li><li>如果是读,该内存可以被读;如果是写操作,该内存应该可写;如果是可执行,必须被标记为可执行.进程局不能绕过内存访问限制.<br>如果调用成功返回0,否则返回标准-EFAULT<br>###　<strong>绑定系统调用</strong><br>在编写完一个系统调用后，要把它注册程一个正式的系统调用</li></ul><ol><li>首先在系统调用表的最后加入一个表项,从0开始算起</li><li>系统调用必须被编译进内核映像(不能被编译成模块)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux进程管理</title>
      <link href="/2019/03/31/linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2019/03/31/linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="linux进程管理"><a href="#linux进程管理" class="headerlink" title="linux进程管理"></a>linux进程管理</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><blockquote><p>进程就是处于执行期的程序.但不仅仅局限于一段可执行程序代码.通常还要包括其他资源,打开的文件,挂起的信号,内核内部数据,处理器状态,一个或多个具有内存映射的内存地址空间或多个执行线程.<br>在linux中线程是一种特殊的进程.是内核调度的对象.每个线程都拥有一个独立的程序计数器,进程栈,一组进程寄存器.<br>在操作系统中进程提供两种虚拟机机制:虚拟处理器和虚拟内存   </p></blockquote><h2 id="进程描述符及任务结构"><a href="#进程描述符及任务结构" class="headerlink" title="进程描述符及任务结构"></a>进程描述符及任务结构</h2><blockquote><p>内核把进程的列表存在叫任务队列的双向循环链表中.链表的每一项类型为task_struct称为进程描述符的机构.主要保存有:打开的文件,进程的地址空间,挂起的信号,进程的状态等.<br>每个进程都有自己的父进程,父进程可以管理其子进程.通过fork创建子进程.<br>在系统中有一个进程内核栈,动态生成task_struct只需要在栈上创建一个新结构thread_info,thread_info中包含了指向task_struct的指针.</p></blockquote><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在linux中线程创建和普通进程的创建类似,但是在调用clone()的时候要传入参数指明要共享的资源.因为在linux中线程和普通的进程差不多,只是有共享资源.  </p><h2 id="进程终结"><a href="#进程终结" class="headerlink" title="进程终结"></a>进程终结</h2><p>原因: </p><ul><li>可能是自身引起,调用exit()系统调用.可能被其他进程终结.<br>过程:</li></ul><ol><li>讲tast_struct中标志成员设置为PF_EXITING.</li><li>调用deltimersync()删除任意内核定时器.根据返回结果,确保没有定时器在排队,也没有定时器处理程序在运行.</li><li>如果BSD进程记账功能开启,do_exit()调用函数输出记账信息.</li><li>调用exit_files和exit_fs(),分别递减文件描述符,文件系统数据的引用技术.如果每个引用技术为0,则可以释放</li><li>把退出代码保存下来,供父进程随时检索.</li><li>调用exit_notify()向父进程发送信号,给子进程重新找养父,养父为线程组的其他线程或者init进程,并吧线程状态设置为EXIT_ZOMBIE</li><li>切换新的进程</li></ol><blockquote><p>在每个进程结束之后都会保留一个退出信息,等待父进程调用结束后在被释放.<br>如果父进程在子进程之前退出,就会在当前线程组内找一个线程作为父亲,如果不行就让init做他们的父进程.保证了每个进程死亡之后不会僵死,会有父进程回收此进程的退出代码信息</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一个测试</title>
      <link href="/2019/03/30/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/03/30/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="nihao"><a href="#nihao" class="headerlink" title="nihao"></a>nihao</h3><h4 id="sdalfjsdlkfjad-f"><a href="#sdalfjsdlkfjad-f" class="headerlink" title="sdalfjsdlkfjad f"></a>sdalfjsdlkfjad f</h4><blockquote><p>dsf asdf<br>fasdfasdf </p></blockquote><h3 id="zheshiyigeceshi"><a href="#zheshiyigeceshi" class="headerlink" title="zheshiyigeceshi"></a>zheshiyigeceshi</h3>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>test.md</title>
      <link href="/2019/03/30/test-md/"/>
      <url>/2019/03/30/test-md/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/30/hello-world/"/>
      <url>/2019/03/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
