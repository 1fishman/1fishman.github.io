<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>timSort源码剖析</title>
      <link href="/2019/04/05/timSort%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2019/04/05/timSort%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="TimSort"><a href="#TimSort" class="headerlink" title="TimSort"></a>TimSort</h1><p>timsort是jdk自带的一种特别高效的排序算法,大致思想使用的是归并排序,但是内部细节做了许多的优化.<br>在timsort中,主要是为待排序数组分为很多个run块,通过讲这些run块进行归并排序.最后实现总体排序.每个run块的大小为16-32大小.<br>优化地方: </p><ul><li>当待排序数组长度小于32就使用二分排序算法</li><li>分为多个run块,在通过把run块的起始位置和长度压入栈中,在进行合并.</li><li>在找到一个run块的时候会首先判断数组中有序元素的个数.通过二分排序从第一个无序的元素开始排序,加快排序速度</li><li>在进行合并的时候会进行”去头”,”去尾”操作,是的归并操作加快速度.</li></ul><h2 id="sort-T-a-int-lo-int-hi-Comparator-lt-super-T-gt-c-T-work-int-workBase-int-workLen"><a href="#sort-T-a-int-lo-int-hi-Comparator-lt-super-T-gt-c-T-work-int-workBase-int-workLen" class="headerlink" title="sort(T[] a, int lo, int hi, Comparator&lt;? super T&gt; c, T[] work, int workBase, int workLen)"></a>sort(T[] a, int lo, int hi, Comparator&lt;? super T&gt; c, T[] work, int workBase, int workLen)</h2><p>timsort对外的唯一接口.并且只能本包内访问<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T[] a, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi, Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; c,<br>                         T[] work, <span class="hljs-keyword">int</span> workBase, <span class="hljs-keyword">int</span> workLen)</span> </span>&#123;<br>        <span class="hljs-keyword">assert</span> c != <span class="hljs-keyword">null</span> &amp;&amp; a != <span class="hljs-keyword">null</span> &amp;&amp; lo &gt;= <span class="hljs-number">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;<br><br>        <span class="hljs-keyword">int</span> nRemaining  = hi - lo;<br>        <span class="hljs-comment">//小于2不用排序,直接返回</span><br>        <span class="hljs-keyword">if</span> (nRemaining &lt; <span class="hljs-number">2</span>) <br>            <span class="hljs-keyword">return</span>; <br>        <span class="hljs-comment">// 看是否小于min_merge,如果小于就直接二分排序,没必要进行复杂的timsort.</span><br>        <span class="hljs-keyword">if</span> (nRemaining &lt; MIN_MERGE) &#123;<br>            <span class="hljs-comment">//下面有详细说明.返回的是从lo开始已经有序的个数,对二分排序用</span><br>            <span class="hljs-keyword">int</span> initRunLen = countRunAndMakeAscending(a, lo, hi, c);<br>            <span class="hljs-comment">// 从第一没有排好序位置开始进行二分排序</span><br>            binarySort(a, lo, hi, lo + initRunLen, c);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//这个时候开始真正的timsort</span><br>        TimSort&lt;T&gt; ts = <span class="hljs-keyword">new</span> TimSort&lt;&gt;(a, c, work, workBase, workLen);<br>        <span class="hljs-comment">//主要将数组分为一个个的minRun,最后在进行合并,如果长度为2的n次幂,minRun为32,否则为16-32之间的数.</span><br>        <span class="hljs-keyword">int</span> minRun = minRunLength(nRemaining);<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">//再次找到a中已经有序的元素个数</span><br>            <span class="hljs-keyword">int</span> runLen = countRunAndMakeAscending(a, lo, hi, c);<br><br>            <span class="hljs-comment">//如果有序个数小于上面的最小minRun的话,就找到</span><br>            <span class="hljs-keyword">if</span> (runLen &lt; minRun) &#123;<br>                <span class="hljs-keyword">int</span> force = nRemaining &lt;= minRun ? nRemaining : minRun;<br>                binarySort(a, lo, lo + force, lo + runLen, c);<br>                runLen = force;<br>            &#125;<br><br>            <span class="hljs-comment">// 将此run块放入run数组中.</span><br>            ts.pushRun(lo, runLen);<br>            <span class="hljs-comment">//这里之心合并操作.</span><br>            ts.mergeCollapse();<br><br>            <span class="hljs-comment">// Advance to find next run</span><br>            lo += runLen;<br>            nRemaining -= runLen;<br>        &#125; <span class="hljs-keyword">while</span> (nRemaining != <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// Merge all remaining runs to complete sort</span><br>        <span class="hljs-keyword">assert</span> lo == hi;<br>        ts.mergeForceCollapse();<br>        <span class="hljs-keyword">assert</span> ts.stackSize == <span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h2 id="minRunLength"><a href="#minRunLength" class="headerlink" title="minRunLength"></a>minRunLength</h2><p>就是获得一个最小的Run块的大小,大小在16-32之间.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minRunLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">assert</span> n &gt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;      <span class="hljs-comment">// Becomes 1 if any 1 bits are shifted off</span><br>    <span class="hljs-keyword">while</span> (n &gt;= MIN_MERGE) &#123;<br>        r |= (n &amp; <span class="hljs-number">1</span>);<br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n + r;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="countRunAndMakeAscending-a-lo-hi-c"><a href="#countRunAndMakeAscending-a-lo-hi-c" class="headerlink" title="countRunAndMakeAscending(a, lo, hi, c)"></a>countRunAndMakeAscending(a, lo, hi, c)</h2><p>找到a数组中从lo开始并且已经有序的元素个数,返回已经有序的元素个数.在这里如果逆序在翻转一下,变为有序.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countRunAndMakeAscending</span><span class="hljs-params">(T[] a, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi,<br>                                                    Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; c)</span> </span>&#123;<br>        <span class="hljs-keyword">assert</span> lo &lt; hi;<br>        <span class="hljs-keyword">int</span> runHi = lo + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (runHi == hi)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 找见a从lo开始已经有序的元素个数</span><br>        <span class="hljs-keyword">if</span> (c.compare(a[runHi++], a[lo]) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Descending</span><br>            <span class="hljs-keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="hljs-number">1</span>]) &lt; <span class="hljs-number">0</span>)<br>                runHi++;<br>            reverseRange(a, lo, runHi);<span class="hljs-comment">//如果是逆序则翻转</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;                              <span class="hljs-comment">// Ascending</span><br>            <span class="hljs-keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="hljs-number">1</span>]) &gt;= <span class="hljs-number">0</span>)<br>                runHi++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> runHi - lo;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h2 id="binarySort-T-a-int-lo-int-hi-int-start-Comparator-lt-super-T-gt-c"><a href="#binarySort-T-a-int-lo-int-hi-int-start-Comparator-lt-super-T-gt-c" class="headerlink" title="binarySort(T[] a, int lo, int hi, int start,Comparator&lt;? super T&gt; c)"></a>binarySort(T[] a, int lo, int hi, int start,Comparator&lt;? super T&gt; c)</h2><p>此方法就是二分排序,二分排序就是插入排序,但是在寻找向前面插入的位置是通过二分法来查找,然后在插入的.<br>此方法是在a数组中排序从lo到hi的元素,从start开始.</p><h2 id="private-void-mergeCollapse"><a href="#private-void-mergeCollapse" class="headerlink" title="private void mergeCollapse()"></a>private void mergeCollapse()</h2><p>这个方法主要是用来合并已经分好的几个Run块的.但是是有条件的;</p><ol><li>runLen[i - 3] &gt; runLen[i - 2] + runLen[i - 1]</li><li>runLen[i - 2] &gt; runLen[i - 1]<br>满足这两个条件才合并,否则什么都不做.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeCollapse</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//最少都得有两个块,如果没有,则退出.</span><br>        <span class="hljs-keyword">while</span> (stackSize &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">int</span> n = stackSize - <span class="hljs-number">2</span>;<span class="hljs-comment">// stackSize为块的数量,-2相当与倒数第二个块</span><br>            <span class="hljs-comment">//如果块的数量大于三个并且倒数第三个Run块大小小于后面两个块的大小和进入</span><br>            <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span> &amp;&amp; runLen[n-<span class="hljs-number">1</span>] &lt;= runLen[n] + runLen[n+<span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">//如果倒数第三个块比倒一块的大小小,就从倒数第三个块进行合并</span><br>                <span class="hljs-keyword">if</span> (runLen[n - <span class="hljs-number">1</span>] &lt; runLen[n + <span class="hljs-number">1</span>])<br>                    n--;<br>                mergeAt(n);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (runLen[n] &lt;= runLen[n + <span class="hljs-number">1</span>]) &#123;<span class="hljs-comment">//第一个块大小小于第二个块大小,就合并这两个</span><br>                mergeAt(n);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//否则什么都不做    </span><br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// Invariant is established</span><br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="private-void-mergeAt-int-i"><a href="#private-void-mergeAt-int-i" class="headerlink" title="private void mergeAt(int i)"></a>private void mergeAt(int i)</h2><p>再来看mergeAt(i)方法,这个方法主要就是合并在run块数组中从i开始的两个块.run[i]和run[i+1]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> base1 = runBase[i];<br><span class="hljs-keyword">int</span> len1 = runLen[i];<br><span class="hljs-keyword">int</span> base2 = runBase[i + <span class="hljs-number">1</span>];<br><span class="hljs-keyword">int</span> len2 = runLen[i + <span class="hljs-number">1</span>];<br>runLen[i] = len1 + len2;<br><span class="hljs-comment">//观察如果是倒数第三个块,就倒数第一个块赋值给倒数第二个块</span><br><span class="hljs-keyword">if</span> (i == stackSize - <span class="hljs-number">3</span>) &#123;<br>    runBase[i + <span class="hljs-number">1</span>] = runBase[i + <span class="hljs-number">2</span>];<br>    runLen[i + <span class="hljs-number">1</span>] = runLen[i + <span class="hljs-number">2</span>];<br>&#125;<br>stackSize--;<br><br><span class="hljs-comment">//计算run2的第一个元素能插入到run1的位置</span><br><span class="hljs-comment">//如果属于run1的最后一个位置,就不需要排序,因为run1中的所有元素都比run2中的小,直接返回,</span><br><span class="hljs-comment">//这样可以忽略掉run1中之前的位置</span><br><span class="hljs-keyword">int</span> k = gallopRight(a[base2], a, base1, len1, <span class="hljs-number">0</span>, c);<br><span class="hljs-keyword">assert</span> k &gt;= <span class="hljs-number">0</span>;<br>base1 += k;<br>len1 -= k;<br><span class="hljs-keyword">if</span> (len1 == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">//计算run1的最后一个元素在run2中插入的位置,进行去尾.</span><br>len2 = gallopLeft(a[base1 + len1 - <span class="hljs-number">1</span>], a, base2, len2, len2 - <span class="hljs-number">1</span>, c);<br><span class="hljs-keyword">assert</span> len2 &gt;= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (len2 == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">// 经过上面的“去头”和“去尾”之后，保证run1的开始元素一定大</span><br><span class="hljs-comment">// 于run2的开始元素，并且run1的最后一个数据一定大于run2的最后一个数据  </span><br><span class="hljs-comment">// 然后进行合并,通过两个len的大小找到最好的合并方式</span><br><span class="hljs-keyword">if</span> (len1 &lt;= len2)<br>    mergeLo(base1, len1, base2, len2);<br><span class="hljs-keyword">else</span><br>    mergeHi(base1, len1, base2, len2);<br></code></pre></td></tr></table></figure></p><h2 id="private-void-mergeLo-int-base1-int-len1-int-base2-int-len2"><a href="#private-void-mergeLo-int-base1-int-len1-int-base2-int-len2" class="headerlink" title="private void mergeLo(int base1, int len1, int base2, int len2)"></a>private void mergeLo(int base1, int len1, int base2, int len2)</h2><p>mergeLo方法 合并两个run块<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs java">    T[] a = <span class="hljs-keyword">this</span>.a; <span class="hljs-comment">//首先赋值到一个临时数组中</span><br>    T[] tmp = ensureCapacity(len1);<br>    <span class="hljs-keyword">int</span> cursor1 = tmpBase;<br>    <span class="hljs-keyword">int</span> cursor2 = base2;   <span class="hljs-comment">// Indexes int a</span><br>    <span class="hljs-keyword">int</span> dest = base1;      <span class="hljs-comment">// Indexes int a</span><br>    <span class="hljs-comment">//先吧a从base1开始的元素赋值到tmp从tmpbase开始的元素,赋值len1个元素,因为len1肯定是最小的元素</span><br>    System.arraycopy(a, base1, tmp, cursor1, len1);<br><br>    <span class="hljs-comment">// 首先肯定run2的第一个元素小于run1的第一个元素,因为上面都已经去头了</span><br>    a[dest++] = a[cursor2++];<br>    <span class="hljs-keyword">if</span> (--len2 == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果run2长度为0,则赋值tmp过去,</span><br>        System.arraycopy(tmp, cursor1, a, dest, len1);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (len1 == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//如果run1只剩下一个元素,所以只需要先把run2复制过去,再讲Run1的唯一元素赋值过去</span><br>        System.arraycopy(a, cursor2, a, dest, len2);<br>        a[dest + len2] = tmp[cursor1]; <span class="hljs-comment">// Last elt of run 1 to end of merge</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; c = <span class="hljs-keyword">this</span>.c;  <span class="hljs-comment">// Use local variable for performance</span><br>    <span class="hljs-keyword">int</span> minGallop = <span class="hljs-keyword">this</span>.minGallop;    <span class="hljs-comment">// 定义一个最小Gallop</span><br>outer: <span class="hljs-comment">//定义跳出什么循环</span><br><br>    <span class="hljs-comment">//在这里有一个思路就是合并两个run,但是会记录两个块中连续个数的数量,如果连续个数的数量大于minGallop也就是7,那就会进入Gallop模式.此模式就是通过"去头","去尾"来减少比较次数</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">int</span> count1 = <span class="hljs-number">0</span>; <span class="hljs-comment">// Number of times in a row that first run won</span><br>        <span class="hljs-keyword">int</span> count2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// Number of times in a row that second run won</span><br><br>        <span class="hljs-comment">/*<br>         * Do the straightforward thing until (if ever) one run starts<br>         * winning consistently.<br>         */</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">assert</span> len1 &gt; <span class="hljs-number">1</span> &amp;&amp; len2 &gt; <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//开始比较</span><br>            <span class="hljs-keyword">if</span> (c.compare(a[cursor2], tmp[cursor1]) &lt; <span class="hljs-number">0</span>) &#123;<br>                a[dest++] = a[cursor2++];<br>                count2++;<br>                count1 = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (--len2 == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span> outer;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                a[dest++] = tmp[cursor1++];<br>                count1++;<br>                count2 = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (--len1 == <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">break</span> outer;<br>            &#125;<br>            <span class="hljs-comment">//当有一个块有连续大于另一个块的次数超过minGallop的时候,进入gallop模式</span><br>        &#125; <span class="hljs-keyword">while</span> ((count1 | count2) &lt; minGallop);<br><br>        <span class="hljs-comment">/*<br>         * One run is winning so consistently that galloping may be a<br>         * huge win. So try that, and continue galloping until (if ever)<br>         * neither run appears to be winning consistently anymore.<br>         */</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">assert</span> len1 &gt; <span class="hljs-number">1</span> &amp;&amp; len2 &gt; <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//如上,去掉run1的头部</span><br>            count1 = gallopRight(a[cursor2], tmp, cursor1, len1, <span class="hljs-number">0</span>, c);<br>            <span class="hljs-keyword">if</span> (count1 != <span class="hljs-number">0</span>) &#123;<br>                System.arraycopy(tmp, cursor1, a, dest, count1);<br>                dest += count1;<br>                cursor1 += count1;<br>                len1 -= count1;<br>                <span class="hljs-keyword">if</span> (len1 &lt;= <span class="hljs-number">1</span>) <span class="hljs-comment">// len1 == 1 || len1 == 0</span><br>                    <span class="hljs-keyword">break</span> outer;<br>            &#125;<br>            a[dest++] = a[cursor2++];<br>            <span class="hljs-keyword">if</span> (--len2 == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span> outer;<br>            <span class="hljs-comment">// 去掉run2的尾部</span><br>            count2 = gallopLeft(tmp[cursor1], a, cursor2, len2, <span class="hljs-number">0</span>, c);<br>            <span class="hljs-keyword">if</span> (count2 != <span class="hljs-number">0</span>) &#123;<br>                System.arraycopy(a, cursor2, a, dest, count2);<br>                dest += count2;<br>                cursor2 += count2;<br>                len2 -= count2;<br>                <span class="hljs-keyword">if</span> (len2 == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span> outer;<br>            &#125;<br>            a[dest++] = tmp[cursor1++];<br>            <span class="hljs-keyword">if</span> (--len1 == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">break</span> outer;<br>            minGallop--;<br>            <span class="hljs-comment">//在此模式每多循环一次minGallop减少1</span><br>        &#125; <span class="hljs-keyword">while</span> (count1 &gt;= MIN_GALLOP | count2 &gt;= MIN_GALLOP);<br>        <span class="hljs-keyword">if</span> (minGallop &lt; <span class="hljs-number">0</span>)<br>            minGallop = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//在离开这个gallop模式后值增加2</span><br>        minGallop += <span class="hljs-number">2</span>;  <span class="hljs-comment">// Penalize for leaving gallop mode</span><br>    &#125;  <span class="hljs-comment">// End of "outer" loop</span><br>    <br>    <span class="hljs-keyword">this</span>.minGallop = minGallop &lt; <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : minGallop;  <span class="hljs-comment">// Write back to field</span><br>    <span class="hljs-keyword">if</span> (len1 == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">assert</span> len2 &gt; <span class="hljs-number">0</span>;<br>        System.arraycopy(a, cursor2, a, dest, len2);<br>        a[dest + len2] = tmp[cursor1]; <span class="hljs-comment">//  Last elt of run 1 to end of merge</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len1 == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<br>            <span class="hljs-string">"Comparison method violates its general contract!"</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">assert</span> len2 == <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">assert</span> len1 &gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//最后将tmp的值赋值到a中</span><br>        System.arraycopy(tmp, cursor1, a, dest, len1);<br>    &#125;<br></code></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中断与中断处理</title>
      <link href="/2019/04/01/%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/"/>
      <url>/2019/04/01/%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断就是使硬件发出通知给处理器,比如在敲击键盘的时候,键盘控制器会发送一个中断,通知操作系统有键按下,让操作系统尽快处理<br>不同的设备对应的中断不同,每个中断都通过一个唯一的数字标志,使得操作系统能够对中断进行区分,继而提供不同的处理程序.这些中断值通常被成为中断请求(IRQ)线.每个IRQ先都会呗关联一个数值量;例如在经典的PC机上,IRQ 0 是时钟中断.1是键盘中断.但是对于连接在PCi总线上的设备而言,中断是动态分配的.</p><h2 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h2><p>在操作系统中,在响应一个特定中断的时候,内核会执行一个函数,该函数叫做中断处理程序,产生中断的每个设备都有一个特定的中断处理程序.<br>对于操作系统而言,中断出息程序在尽可能端的时间内完成很重要;但是对于硬件而言,操作系统能迅速对其中断进行服务也非常重要.<br>所以中断程序首先哟啊通知硬件设备中断已接受.还要运行中断函数处理.例如要把硬件网络接收到的数据拷贝到内存,但是现在网速特别块,所以之后的工作量会很大.因此将响应中断分为两部分.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">在操作系统中一般中断分为两部分.中断处理程序是上半部 ---接收到一个中断,它就立即开始执行,但是只做有严格实现的工作.例如对接收的中断进行应答或复位硬件.能够允许稍后完后才能的工作会推迟到下半部.<br></code></pre></td></tr></table></figure></p><p>linux的中断处理程序是无须重入的,淡一个给定的中断处理程序正在执行,相应的中断线上的所有处理器上的都会被屏蔽掉.</p><h2 id="注册中断处理程序"><a href="#注册中断处理程序" class="headerlink" title="注册中断处理程序"></a>注册中断处理程序</h2><p>每个设备都有相关的驱动程序,如果硬件使用中断,应该注册一个中断处理程序.通过reques_irq()函数注册,并且激活给定的中断线,以处理中断.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">int request_irq(unsigned int irq,  表示要分配的中断号<br>                irq_handler_t handler, //handler是一个指针,指向处理这个中断的实际中断处理程序<br>                unsigned long flags, //标志位: IRQF_FISABLED 表示不响应其他中断;IRQF_TIMER为系统定时器的中断处理而准备的;IRQF_SHARED:表明在多个中断处理程序之间共享中断线.<br>                const char *name, // 是与中断相关的设备的ASCII文本表示<br>                void *dev) // 拥有共享中断线,dev讲提供唯一的标识信息.当删除中断处理程序需要释放时,能够知道删除哪一个.<br></code></pre></td></tr></table></figure></p><p>request_irq()成功会返回0,否则返回非0值.<br>这里request_irq函数可能会睡眠,因此不能在中断上下文或者其他不允许阻塞的代码中调用该函数.<br>中断线共享仅仅指的是中断号共享,并不是处理程序共享.</p><h2 id="共享的中断处理程序"><a href="#共享的中断处理程序" class="headerlink" title="共享的中断处理程序"></a>共享的中断处理程序</h2><p>对于共享中断线的设备,首先request_irq()的flag参数为IRQF_SHARED标志<br>对于dev参数必须唯一.指向任意设备结构的指针就可以满足这一要求;通常选择设备结构,因为它是唯一的.这里设备结构是你要想响应的设备结构.<br>中断处理程序必须能够区分它的设备是否真的产生了中断.这需要硬件的支持,也需要程序中有相关的处理逻辑.</p><h2 id="释放中断处理程序"><a href="#释放中断处理程序" class="headerlink" title="释放中断处理程序"></a>释放中断处理程序</h2><p>使用free_irq(unsigned int irq, void *dev);<br>如果中断线是共享的,则传入dev参数,删除此dev对应的处理程序,知道最后一个处理程序时才会被禁用此中断线;如果不是共享的,则在删除处理程序的同时禁用此中断线.  </p><h2 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h2><p>上面提到了中断上下文.其实在执行一个中断处理程序时,内核处于中断上下文中.<br>中断上下文和进程没有瓜葛,因为没有后备进程,所以中断上下文不可以睡眠.因此在中断上下文中不能调用睡眠的函数.<br>在中断上下文具有较为严格的时间限制,所有的中断处理程序必须尽可能的迅速,简洁.尽量把工作从中断处理程序中分离出来.放在下半部执行．　　<br>在每个处理中有一个中断处理栈，大小为１页. 在栈中处理中断程序.</p><h2 id="中断控制"><a href="#中断控制" class="headerlink" title="中断控制"></a>中断控制</h2><p>禁止指定中断线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">void disable_irq(unsigned int irq);//会等待当前处理程序完成后才返回<br>void diable_irq_nosync(unsigned int irq);//强制返回<br>void enable_irq(unsigned int irq);<br>void synchronized_irq(unsigned int irq);<br></code></pre></td></tr></table></figure></p><p>前两个函数禁止中断控制器上制定的中断线.synchronized_irq等待一个特定的中断处理程序的退出.  对于调用禁用函数可以嵌套,但是有一点就是调用多少次禁用中断线函数,就要调用多少次启动函数才能够重新激活.</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程调度</title>
      <link href="/2019/04/01/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
      <url>/2019/04/01/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><p>linux采用两种不同的优先级范围.<br>第一种用nice值,范围为-20到19,越低优先级越高.<br>第二种是实时优先级,从0-99,越大优先级越高.  </p><p>在系统调度中总会解决I/O密集型的和CPU密集型的进程的协调,I/O密集型要求有更好的响应性,而执行时间应该更少.CPU要求有更好的执行时间,而不是花费更多时间用来调度.</p><h2 id="调度器类"><a href="#调度器类" class="headerlink" title="调度器类"></a>调度器类</h2><p>linux调度器是以模块方式提供的,每个模块化结构成为调度器类,允许多种不同的可动态添加的调度算法并存.每个调度器都有一个优先级,会按照优先级顺序便利调度类,拥有一个可执行进程的最高优先级的调度器类胜出,选出下面要执行的一个程序.</p><h2 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h2><p>在linux中采用公平调度算法CFS,允许每个进程运行一段时间,循环轮转,选择运行最少的进程作为下一个运行进程,而不在采用分配给每个进程时间片.CFS在所有可运行进程总数基础上计算出一个进程应该运行多久.通过用nice值作为进程获得处理器运行比的权重,越低的优先级进程获得更低的处理器使用权重.在这里nice值并不是通过绝对值值来进行划分的,而是通过相对差值来分配权重的.避免了优先级差值不大的两个进程得到的处理器使用权重相差过大的情况.<br>在这里是由操作系统来确定进程应该使用多久,假设nice=0的进程分配时间片为100ms,则另一个nice=20的进程时间片为5ms.<br>如果按照绝对差值来分配时间片可能出现下列情况:<br>两个进程优先级分别为0和1,一个为100ms,则另一个为95ms,这时候基本没有问题.但是当两个优先级分别为18和19,那么一个为10ms,一个为5ms,这样前者比后者多出了一倍的处理器时间,是相对不合理的.</p><h2 id="linux调度的实现"><a href="#linux调度的实现" class="headerlink" title="linux调度的实现"></a>linux调度的实现</h2><h3 id="时间记账"><a href="#时间记账" class="headerlink" title="时间记账"></a><strong>时间记账</strong></h3><p>CFS不再有时间片概念,维护每个进程运行的时间的记账,保存在进程描述符中.<br>每个进程都有一个虚拟运行时间,该运行时间的计算是所有可运行进程总数的标准化(是被加权的).虚拟时间以ns为单位.CFS使用vruntime变量来记录一个程序到底运行了多长时间以及还应该在运行多久.<br>vruntime运行时间计算如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">首先的到当前进程的执行时间,然后在根据当前可运行进程总数对运行时间进行加权计算,在将权重值与当前进程的vruntime相加.<br>vruntime准确的测量给定进程的运行时间,而且可知道谁应该是下一个被运行的进程,因为他是根据运行时间最小的进程优先调度的.<br></code></pre></td></tr></table></figure></p><h3 id="进程选择"><a href="#进程选择" class="headerlink" title="进程选择"></a><strong>进程选择</strong></h3><p>主要选择具有最小vruntime的任务;通过使用红黑树来保存这些进程</p><h3 id="调度器入口"><a href="#调度器入口" class="headerlink" title="调度器入口"></a><strong>调度器入口</strong></h3><p>进程调度的时候首先是以调度器的优先级为顺序从高到低一次检查每个调度类,并且从最高优先级的调度类中选择最高优先级的进程.这样就找到最高优先级的进程,也就是vruntime最小的进程.</p><h3 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a><strong>睡眠和唤醒</strong></h3><p>内核操作: 首先标记自己为休眠状态,从可执行红黑树中移除,放入等待队列.在选择一个可执行进程.唤醒相反.<br>等待队列: 维护一个等待队列,当要休眠的时候放入到等待队列.编码是一个while(true)循环中等待,在被唤醒后在此检查条件是否为真,为真就会退出循环,将自己移除出等待队列,加入可执行红黑树中.<br>唤醒:唤醒操作通过函数wake_up()进行,唤醒指定的等待队列上的所有进程.</p><h2 id="抢占和上下文切换"><a href="#抢占和上下文切换" class="headerlink" title="抢占和上下文切换"></a>抢占和上下文切换</h2><p>内核中有一个参数为need_resched参数,表明是否需要重新执行一次调度,此过程称为抢占.</p><ul><li>用户抢占:　在系统调用返回用户控件或从中断处理程序返回用户空间是会发生用户抢占，当然need_resched参数要设置</li><li>内核抢占: 除了need_resched参数还有一个preempt_count参数,表明是否持有锁,在preempt_count为0的时候说明在执行任务持有锁,此次抢占是不安全的.知道当前新进程持有的所有锁都释放了,才会重新执行调度.</li></ul><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用在用户空间进程和硬件设备之间添加了一个中间层,作用有三个:</p><ol><li>首先为用户空间提供了一种硬件的抽象接口.这样应用程序不管磁盘类型和介质,不管文件系统是那种类型</li><li>第二 系统调用保证了系统的稳定和安全.作为硬件设备和应用程序之间的中间人可以基于权限,用户类型和其他规则对需要进行的访问进行裁决,避免引用程序不正当的使用硬件设备.</li><li>每个进程都运行在虚拟系统中,而在用户控件和系统的其余部分提供这样一层公共接口.在linux中系统调用是用户空间进入内核的唯一手段,除了异常和陷入外,他们是内核唯一的合法入口.</li></ol><h3 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a><strong>系统调用</strong></h3><p>在linux中,每个系统调用被富裕一个系统调用好. 这样就可以根据一个独一无二的号关联系统调用.进程不会提及系统调用的名称.如果一个系统调用删除,他所占用的系统调用号不允许被回收,否则以前编译过的代码调用此系统调用,但是事实上却调用另一个系统调用容易引发错误.如果一个系统调用被删除会用sys_ni_syscall()替换,此函数返回-ENOSYS.内核记录了系统调用表中的所有已注册过的系统调用的列表.存储在sys_call_table中. </p><h3 id="指定系统调用"><a href="#指定系统调用" class="headerlink" title="指定系统调用"></a><strong>指定系统调用</strong></h3><p>所有的系统调用陷入内核方式都一样,所以必须吧系统调用号一并创给内核.在x86上,系统调用号通过eax寄存器传递给内核.在陷入内核前,用户空间就把响应系统调用锁对应的号放入eax中.</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a><strong>参数传递</strong></h3><p>调用系统调用有时需要一些参数,最简单的办法是把参数也存放在寄存器里.在ebx ecx edx esi edi按照顺序存放前5个参数.应用用一个单独的寄存器存放指向所有这些参数在用户空间地址的指针.给用户空间的返回值也通过寄存器传递.</p><h3 id="调用参数限制"><a href="#调用参数限制" class="headerlink" title="调用参数限制"></a><strong>调用参数限制</strong></h3><p>在进行系统调用之前会先检查他们所有的参数是否合法有效.在接受用户空间的指针前,内核必须保证:</p><ul><li>指针指向的内存区域属于用户空间.进程决不能哄骗内核去读内核空间的数据.</li><li>指针指向的内核区域在进程的地址空间里.进程绝不能哄骗内核去读取其他进程的数据.</li><li>如果是读,该内存可以被读;如果是写操作,该内存应该可写;如果是可执行,必须被标记为可执行.进程局不能绕过内存访问限制.<br>如果调用成功返回0,否则返回标准-EFAULT<br>###　<strong>绑定系统调用</strong><br>在编写完一个系统调用后，要把它注册程一个正式的系统调用</li></ul><ol><li>首先在系统调用表的最后加入一个表项,从0开始算起</li><li>系统调用必须被编译进内核映像(不能被编译成模块)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux进程管理</title>
      <link href="/2019/03/31/linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2019/03/31/linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="linux进程管理"><a href="#linux进程管理" class="headerlink" title="linux进程管理"></a>linux进程管理</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><blockquote><p>进程就是处于执行期的程序.但不仅仅局限于一段可执行程序代码.通常还要包括其他资源,打开的文件,挂起的信号,内核内部数据,处理器状态,一个或多个具有内存映射的内存地址空间或多个执行线程.<br>在linux中线程是一种特殊的进程.是内核调度的对象.每个线程都拥有一个独立的程序计数器,进程栈,一组进程寄存器.<br>在操作系统中进程提供两种虚拟机机制:虚拟处理器和虚拟内存   </p></blockquote><h2 id="进程描述符及任务结构"><a href="#进程描述符及任务结构" class="headerlink" title="进程描述符及任务结构"></a>进程描述符及任务结构</h2><blockquote><p>内核把进程的列表存在叫任务队列的双向循环链表中.链表的每一项类型为task_struct称为进程描述符的机构.主要保存有:打开的文件,进程的地址空间,挂起的信号,进程的状态等.<br>每个进程都有自己的父进程,父进程可以管理其子进程.通过fork创建子进程.<br>在系统中有一个进程内核栈,动态生成task_struct只需要在栈上创建一个新结构thread_info,thread_info中包含了指向task_struct的指针.</p></blockquote><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在linux中线程创建和普通进程的创建类似,但是在调用clone()的时候要传入参数指明要共享的资源.因为在linux中线程和普通的进程差不多,只是有共享资源.  </p><h2 id="进程终结"><a href="#进程终结" class="headerlink" title="进程终结"></a>进程终结</h2><p>原因: </p><ul><li>可能是自身引起,调用exit()系统调用.可能被其他进程终结.<br>过程:</li></ul><ol><li>讲tast_struct中标志成员设置为PF_EXITING.</li><li>调用deltimersync()删除任意内核定时器.根据返回结果,确保没有定时器在排队,也没有定时器处理程序在运行.</li><li>如果BSD进程记账功能开启,do_exit()调用函数输出记账信息.</li><li>调用exit_files和exit_fs(),分别递减文件描述符,文件系统数据的引用技术.如果每个引用技术为0,则可以释放</li><li>把退出代码保存下来,供父进程随时检索.</li><li>调用exit_notify()向父进程发送信号,给子进程重新找养父,养父为线程组的其他线程或者init进程,并吧线程状态设置为EXIT_ZOMBIE</li><li>切换新的进程</li></ol><blockquote><p>在每个进程结束之后都会保留一个退出信息,等待父进程调用结束后在被释放.<br>如果父进程在子进程之前退出,就会在当前线程组内找一个线程作为父亲,如果不行就让init做他们的父进程.保证了每个进程死亡之后不会僵死,会有父进程回收此进程的退出代码信息</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一个测试</title>
      <link href="/2019/03/30/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/03/30/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="nihao"><a href="#nihao" class="headerlink" title="nihao"></a>nihao</h3><h4 id="sdalfjsdlkfjad-f"><a href="#sdalfjsdlkfjad-f" class="headerlink" title="sdalfjsdlkfjad f"></a>sdalfjsdlkfjad f</h4><blockquote><p>dsf asdf<br>fasdfasdf </p></blockquote><h3 id="zheshiyigeceshi"><a href="#zheshiyigeceshi" class="headerlink" title="zheshiyigeceshi"></a>zheshiyigeceshi</h3>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>test.md</title>
      <link href="/2019/03/30/test-md/"/>
      <url>/2019/03/30/test-md/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/30/hello-world/"/>
      <url>/2019/03/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
