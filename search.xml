<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>装饰器模式</title>
      <link href="/2019/04/15/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/15/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式就是动态地给一个对象添加一些额外的职责,扩展对象的功能.对于增加功能来说,装饰器模式比生成子类更为灵活.  </p><h2 id="装饰器模式的结构"><a href="#装饰器模式的结构" class="headerlink" title="装饰器模式的结构"></a>装饰器模式的结构</h2><p>通常来说,给一个对象添加一些额外的功能,可以通过继承来实现,但是这并不能动态地给对象添加职责,如果要添加一些职责,只能改变原有对象. 这时候就需要有装饰器模式出现了. 装饰器模式并不是利用继承和多态来扩展和复用功能,是基于对象组合的方式 .  </p><p>装饰器模式的角色有:</p><ol><li>抽象的对象角色    给出一个抽象接口,以规范准备接受附加功能的对象</li><li>具体的被装饰者    一个将要接受附加功能的具体实现,就是被装饰者,需要实现抽象的对象接口</li><li>装饰抽象类　　持有一个被装饰者的实例,并实现抽象对象接口,为具体的装饰功能提供一个统一的接口</li><li>具体装饰角色 就是具体的装饰对象,继承子装饰抽象类,是用来给被装饰者添加附加功能的.</li></ol><p>看类图:</p><p><img src="/2019/04/15/装饰器模式/Decorator.png" alt></p><p>装饰对象和被装饰对象实现的都是同一个接口,装饰对象也可以是一个接口,下面还可以有更多的具体的装饰对象.通过调用一个方法来装饰被装饰对象,以此来添加新的功能附件.</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>比如我们现在要实现一个给人动态添加服装的功能.<br><strong>首先定义一个接口,就是被装饰者实现的接口</strong> 里面有一个方法就是为人动态添加衣服<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name ;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">getSex</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSex</span><span class="hljs-params">(String sex)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>接着实现具体要穿衣服的人</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Man</span><span class="hljs-params">(String name, String sex)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.setName(name);<br>        <span class="hljs-keyword">super</span>.setSex(sex);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"装扮"</span>+getName()+getSex());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>在实现装饰抽象类</strong> 定义一个统一的装饰接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> Person person;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decorator</span><span class="hljs-params">(Person person)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.person = person;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(person != <span class="hljs-keyword">null</span>)&#123;<br>            person.show();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>具体装饰实现类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TShirts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decorator</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"穿T恤"</span>);<br>        <span class="hljs-keyword">super</span>.show();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shorts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decorator</span>  </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"穿短裤"</span>);<br>        <span class="hljs-keyword">super</span>.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Person man = <span class="hljs-keyword">new</span> Man(<span class="hljs-string">"spj"</span>,<span class="hljs-string">"男"</span>);<br>        TShirts shirts = <span class="hljs-keyword">new</span> TShirts();<br>        Shorts shorts = <span class="hljs-keyword">new</span> Shorts();<br>        shirts.decorator(man);<br>        shorts.decorator(shirts);<br>        shirts.show();<br><br>    &#125;<br>&#125;<br>输出:<br>穿短裤<br>穿T恤<br>装扮spj男<br></code></pre></td></tr></table></figure><p>这个例子中每一个装饰对象都会调用自己装饰的那个对象,这个样子其实有点像责任链模式,不过责任链是将消息传递出去,而装饰模式是修饰已经已有的对象,一层一层的装饰.为对象动态的添加责任,最后形成一个完整的有用的对象.  </p><p>在java中 字节输入流就是使用到了装饰器模式,在java中我们经常能见到这种写法.比如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">InputStream in = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"文件1"</span>);<br>BufferedInputStream bfi = <span class="hljs-keyword">new</span> BufferedInputStream(in);<br>DataInputStream dis = <span class="hljs-keyword">new</span> DataInputStream(bfi);<br></code></pre></td></tr></table></figure></p><p>在这中写法中应该能够看出来这就是应用了装饰器模式,所有的这些输入流都继承InputStream类,通过一层一层的包装,来为输入流添加不同的功能.而他们每个类都有着上一层的一个实例对象,通过对此实例对象进行包装,就能够添加想要的功能.</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码阅读</title>
      <link href="/2019/04/14/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2019/04/14/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>java.util包下面的工具类,键值对存储数据.通过对键值计算hash值,来存储到对应的位置.<br>jdk1.8中底层使用数组加链表实现.键值对通过一个内部类的Node节点来表示.采用链地址法解决hash冲突,如果一条链上的节点超过给定阈值会变为红黑树.默认为8.<br>在hashmap中是可以存储空key和value的.如果为空,则位置为0.</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>hashmap继承了AbstractMap类,实现Map接口和克隆接口.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;<br>    implements Map&lt;K,V&gt;, Cloneable, Serializable<br></code></pre></td></tr></table></figure></p><h2 id="主要内部类"><a href="#主要内部类" class="headerlink" title="主要内部类"></a>主要内部类</h2><h3 id="Node-继承Map-Entry"><a href="#Node-继承Map-Entry" class="headerlink" title="Node  继承Map.Entry"></a>Node  继承Map.Entry</h3><ul><li>final int hash; 此节点保存的键值的hash值</li><li>final K key; 此节点的键</li><li>V value; 值</li><li>Node&lt;K,V&gt; next; 下一个节点,主要在有hash冲突的地方指向下一个几点<blockquote><p>Node(int hash, K key, V value, Node&lt;K,V&gt; next)  初始化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul><p>这里计算hashCode是用key和value的hash值异或得到.<br>剩下的是获取键,获取值,设置值,equals等方法,比较简单</p><h3 id="KeySet"><a href="#KeySet" class="headerlink" title="KeySet"></a>KeySet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeySet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSet</span>&lt;<span class="hljs-title">K</span>&gt; </span>&#123;<br>        <span class="hljs-comment">//容量</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span>                 </span>&#123; <span class="hljs-keyword">return</span> size; &#125;<br>        <span class="hljs-comment">//调用父类的clear函数</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span>               </span>&#123; HashMap.<span class="hljs-keyword">this</span>.clear(); &#125;<br>        <span class="hljs-comment">//返回key的iterator</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Iterator&lt;K&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span>     </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> KeyIterator(); &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123; <span class="hljs-keyword">return</span> containsKey(o); &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>) != <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Spliterator&lt;K&gt; <span class="hljs-title">spliterator</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> KeySpliterator&lt;&gt;(HashMap.<span class="hljs-keyword">this</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> K&gt; action)</span> </span>&#123;<br>            Node&lt;K,V&gt;[] tab;<br>            <span class="hljs-keyword">if</span> (action == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>            <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span> &amp;&amp; (tab = table) != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">int</span> mc = modCount;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tab.length; ++i) &#123;<br>                    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="hljs-keyword">null</span>; e = e.next)<br>                        action.accept(e.key);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (modCount != mc)<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="HashIterator"><a href="#HashIterator" class="headerlink" title="HashIterator"></a>HashIterator</h3><p>遍历map的迭代器,定义了遍历的基本操作.KeyIterator,ValueIterator和EntryIterator都继承自此类,在实现了一个返回Node的不同值.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashIterator</span> </span>&#123;<br>    Node&lt;K,V&gt; next;        <span class="hljs-comment">// next entry to return</span><br>    Node&lt;K,V&gt; current;     <span class="hljs-comment">// current entry</span><br>    <span class="hljs-comment">//期望的modcount,在遍历期间不希望有别的线程更改过此map,如果改过,则抛出异常</span><br>    <span class="hljs-keyword">int</span> expectedModCount;  <span class="hljs-comment">// for fast-fail</span><br>    <span class="hljs-keyword">int</span> index;             <span class="hljs-comment">// current slot</span><br><br>    <span class="hljs-comment">//初始化,找到第一个不为空的节点</span><br>    HashIterator() &#123;<br>        expectedModCount = modCount;<br>        Node&lt;K,V&gt;[] t = table;<br>        current = next = <span class="hljs-keyword">null</span>;<br>        index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span> &amp;&amp; size &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// advance to first entry</span><br>            <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> next != <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//返回下一个节点,</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">nextNode</span><span class="hljs-params">()</span> </span>&#123;<br>        Node&lt;K,V&gt;[] t;<br>        <span class="hljs-comment">//首先返回值应该是下一个要返回的节点</span><br>        Node&lt;K,V&gt; e = next;<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>        <span class="hljs-comment">//这里在继续寻找下一个节点</span><br>        <span class="hljs-keyword">if</span> ((next = (current = e).next) == <span class="hljs-keyword">null</span> &amp;&amp; (t = table) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-keyword">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br>    <span class="hljs-comment">//移除节点使用外部类的方法移除</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>        Node&lt;K,V&gt; p = current;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>        current = <span class="hljs-keyword">null</span>;<br>        K key = p.key;<br>        removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);<br>        expectedModCount = modCount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul><li>DEFAULT_INITIAL_CAPACITY,    默认为16,初始化默认容量大小</li><li>MAXIMUM_CAPACITY,   最大容量大小 ,为 1&lt;&lt;30</li><li>DEFAULT_LOAD_FACTOR,   加载因子. 默认0.75</li><li>TREEIFY_THRESHOLD,      链表树化的阈值,超过这个值,链表转为红黑树.默认为8</li><li>UNTREEIFY_THRESHOLD,      红黑树转为链表的阈值,当红黑树的节点个数小于此值会变为链表.默认为6</li><li>MIN_TREEIFY_CAPACITY,      这个值就是最小的树化table数组的长度,如果数组长度小于这个值,则先不进行树化,先扩容来减少冲突.<h3 id="具体属性"><a href="#具体属性" class="headerlink" title="具体属性"></a>具体属性</h3></li><li>Node&lt;K,V&gt;[] table. 用来存放键值对的数组.</li><li>int size; 返回table存放了多少键值对,并不是table的长度</li><li>int modCount. 这个是在迭代的时候才会用到,因为hashMap的迭代器是fast-fail的.用这个值表示在此过程中是否有过改变,有过改变就抛出异常.</li><li>int threshold;  下一个数组长度</li><li>final float loadFactor; 加载因子</li></ul><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><p>这里一些简单的get(),set()就不说了,因为很简单.</p><h3 id="HashMap-int-initialCapacity-float-loadFactor"><a href="#HashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="HashMap(int initialCapacity, float loadFactor)"></a>HashMap(int initialCapacity, float loadFactor)</h3><p>初始化方法,这里只看这一个.其他的都是通过调用这个方法的.所以能看出来在初始化的时候真正的存数据的表并没有初始化.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>    <span class="hljs-comment">//初始化容量小于0,直接抛出异常</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal initial capacity: "</span> +<br>                                           initialCapacity);<br>    <span class="hljs-comment">//如果大于默认的最大容量,则为最大容量</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal load factor: "</span> +<br>                                           loadFactor);<br>    <span class="hljs-keyword">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-comment">//这里就是计算出下一次的table的长度.</span><br>    <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="tableSizeFor-int-cap-方法"><a href="#tableSizeFor-int-cap-方法" class="headerlink" title="tableSizeFor(int cap) 方法"></a>tableSizeFor(int cap) 方法</h3><p>这个方法设计的很巧妙,通过5次移位运算可以返回一个大于等于cap的最小的2的n次方的数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;<br>    <span class="hljs-comment">//  减一是为了防止cap本身就为2的n次方</span><br>    <span class="hljs-comment">// 这里一个数字首先无符号右移1位,然后在或运算,会将他最高位为1的右边一位也变为1.</span><br>    <span class="hljs-comment">// 比如随便来一个数字  为010010111000000...</span><br>        <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;<br>        n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//经过第一次运算后,很明显为1的最高位和下一位都为1.数字为 01101....</span><br>        n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//第二次运算之后,这两位1在向右移动两位,现在最高位最少有4个1.为011110....</span><br>        n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>        n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>        n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>        <span class="hljs-comment">//以此类推,在最后右移16位的时候,最后会导致cap的最高位为1的位置之后的全部为1.很容易就找见了大于等于cap的最小的2的n次方的数</span><br>        <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h3 id="hash-Object-key"><a href="#hash-Object-key" class="headerlink" title="hash(Object key)"></a>hash(Object key)</h3><p>计算key的hash值,通过高16位与上低16为保证每一位都能够参与运算.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h;<br>        <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>    &#125;<br></code></pre></td></tr></table></figure></p><h3 id="putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict-方法"><a href="#putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict-方法" class="headerlink" title="putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)方法"></a>putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,<br>                   <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>        <br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;<br>        <span class="hljs-comment">//首先判断table是否为空,如果为空,则先resize扩容.</span><br>        <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            n = (tab = resize()).length;<br>            <span class="hljs-comment">//判断key要存储的位置是否有Node.如果没有则直接插入.有的话向下走</span><br>        <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>            tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>            <br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//这里表示每个table对应的位置有节点,发生冲突,向链表或者红黑树插入节点.</span><br>            Node&lt;K,V&gt; e; K k;<br>            <span class="hljs-comment">//如果链首节点的hash值和key值都与要插入的值相等,则把将e指向该节点..</span><br>            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>                ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                e = p;<br>                <span class="hljs-comment">//如果这条链已经转化成了红黑树,则通过红黑树的插入方式插入</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//这里找到链表的最后一个节点,如果在找的过程中,遇到了和自己key一样的节点将e指向此节点.在插入后如果长度大于等于8则把链表转化为树</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>                        p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                            treeifyBin(tab, hash);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                        <span class="hljs-keyword">break</span>;<br>                    p = e;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//这里e指的是key与要插入的key相等的节点.所以这个时候会判断上面是否要求存在并替换,如果为false,则不替换</span><br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>                V oldValue = e.value;<br>                <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                    e.value = value;<br>                <span class="hljs-comment">//这个方法是给linkedHashMap用的,这里用不到</span><br>                afterNodeAccess(e);<br>                <span class="hljs-keyword">return</span> oldValue;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//modCount加1,表示这个时候被改过了.</span><br>        ++modCount;<br>        <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>            resize();<br>        <span class="hljs-comment">//这个方法也是个linkedHashMap用的,这里用不到,没有实现.</span><br>        afterNodeInsertion(evict);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h3><p>接着看resize()方法,在这里,resize总是将容量大小扩容到2的n次方大小,因为这个样子有利于rehash.还有利于找key在数组中的位置.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>        <span class="hljs-comment">//保存下来旧的table.</span><br>        Node&lt;K,V&gt;[] oldTab = table;<br>        <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>        <span class="hljs-keyword">int</span> oldThr = threshold;<br>        <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//如果旧的容量大于0,并且大于默认最大值也就是1&lt;&lt;30,threshold也就是下一次的要扩容到threshold大小.直接返回</span><br>            <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>                threshold = Integer.MAX_VALUE;<br>                <span class="hljs-keyword">return</span> oldTab;<br>            &#125;<br>            <span class="hljs-comment">//新的容量变为原来的2被,新的threshold也变为原来的2倍,因为有一个tablesizefor()方法,导致hashMap的容量只能是2的n次方</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>                newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>        &#125;<br>        <span class="hljs-comment">//这里是table还没有初始化的时候,等于之前的要扩容大小</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>            newCap = oldThr;<br>        <span class="hljs-keyword">else</span> &#123;           <br>            <span class="hljs-comment">//如果oldThr也没有制定,则就是默认大小.</span><br>            newCap = DEFAULT_INITIAL_CAPACITY;<br>            newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;<br>            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?<br>                      (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);<br>        &#125;<br>        threshold = newThr;<br>        <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">"rawtypes"</span>,<span class="hljs-string">"unchecked"</span>&#125;)<br>            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];<br>        table = newTab;<br>        <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//对于表中的没一个位置,复制到新表中</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>                Node&lt;K,V&gt; e;<br>                <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;<br>                    oldTab[j] = <span class="hljs-keyword">null</span>;<br>                    <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)<br>                        newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                        <span class="hljs-comment">//如果这个表中的节点是树的话,就用树的方式来写.</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                        ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);<br>                    <span class="hljs-keyword">else</span> &#123; <br>                        <span class="hljs-comment">//如果是链表的话,这里有一个小知识点,因为table的大小只能是2的n次方,所以在rehash的时候在一条链上的节点在rehash后,只能有两个位置,一个是本身i,另一个是i+oldTab.length;</span><br>                        <span class="hljs-comment">//这里使用两个链表直接遍历所有的在链表上的节点,然后分为两个链表,最后给i和i+oldTab.length位置赋值</span><br>                        Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>                        Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>                        Node&lt;K,V&gt; next;<br>                        <span class="hljs-keyword">do</span> &#123;<br>                            next = e.next;<br>                            <span class="hljs-comment">//如果hash与上旧的长度为0的话,说明这个节点的位置还在原处</span><br>                            <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                                <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)<br>                                    loHead = e;<br>                                <span class="hljs-keyword">else</span><br>                                    loTail.next = e;<br>                                loTail = e;<br>                            &#125;<br>                            <span class="hljs-keyword">else</span> &#123;<br>                                <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)<br>                                    hiHead = e;<br>                                <span class="hljs-keyword">else</span><br>                                    hiTail.next = e;<br>                                hiTail = e;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);<br>                        <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<br>                            loTail.next = <span class="hljs-keyword">null</span>;<br>                            newTab[j] = loHead;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;<br>                            hiTail.next = <span class="hljs-keyword">null</span>;<br>                            newTab[j + oldCap] = hiHead;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newTab;<br>    &#125;<br></code></pre></td></tr></table></figure></p><p>扩容这里,旧的链表上的节点的位置只可能是i或者i+oldTab.length.为什么呢.举个例子.假如之前的链表长度为16,二进制为10000,现在变为32,就是100000;这个时候如果一个hash值为10的节点分别与16-1(1111)和32-1(11111)进行与运算,那么他们两个就只有可能有一位不一样,就是第5位.所以如果第5为是0,说明和以前的坐标一样,还在原位置,如果为1,则说明坐标位置应该在i+oldTabl.length的位置.</p><h3 id="removeNode-int-hash-Object-key-Object-value-boolean-matchValue-boolean-movable"><a href="#removeNode-int-hash-Object-key-Object-value-boolean-matchValue-boolean-movable" class="headerlink" title="removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable)"></a>removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable)</h3><p>移除一个节点.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">removeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key, Object value,<br>                               <span class="hljs-keyword">boolean</span> matchValue, <span class="hljs-keyword">boolean</span> movable)</span> </span>&#123;<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, index;<br>        <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>            (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">//先找到key所在数组中的位置为(n-1)&amp;hash</span><br>                <span class="hljs-comment">//保存一个node节点,节点表示的是要删除的节点,p表示要删除的前一个节点.</span><br>            Node&lt;K,V&gt; node = <span class="hljs-keyword">null</span>, e; K k; V v;<br>            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>                ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                node = p;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = p.next) != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                            ((k = e.key) == key ||<br>                             (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<br>                            node = e;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        p = e;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||<br>                                 (value != <span class="hljs-keyword">null</span> &amp;&amp; value.equals(v)))) &#123;<br>                <span class="hljs-comment">//具体删除操作,都能看懂</span><br>                <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="hljs-keyword">this</span>, tab, movable);<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == p)<br>                    tab[index] = node.next;<br>                <span class="hljs-keyword">else</span><br>                    p.next = node.next;<br>                ++modCount;<br>                --size;<br>                afterNodeRemoval(node);<br>                <span class="hljs-keyword">return</span> node;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h3 id="public-boolean-containsValue-Object-value"><a href="#public-boolean-containsValue-Object-value" class="headerlink" title="public boolean containsValue(Object value)"></a>public boolean containsValue(Object value)</h3><p>containsValue主要就是遍历表中的节点,如果找到就返回true.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>    Node&lt;K,V&gt;[] tab; V v;<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; size &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tab.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="hljs-keyword">null</span>; e = e.next) &#123;<br>                <span class="hljs-keyword">if</span> ((v = e.value) == value ||<br>                    (value != <span class="hljs-keyword">null</span> &amp;&amp; value.equals(v)))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear()方法"></a>clear()方法</h3><p>简单,就是将table中的元素附空值.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>        Node&lt;K,V&gt;[] tab;<br>        modCount++;<br>        <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; size &gt; <span class="hljs-number">0</span>) &#123;<br>            size = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tab.length; ++i)<br>                tab[i] = <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java注解</title>
      <link href="/2019/04/13/java%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/04/13/java%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这两天在自己学习着写一个小型的web框架,有点像spring,但是有是轻量级的.里面用到的注解功能.但是对于自定义注解这块又不熟悉,所以专门学习了一波,做点笔记记下来.  </p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>注解是自带的.jdk中本身就有很多内置注解,比如override等等.注解的功能其实就是为一些加了注解的类,方法等赋予一些特别的含义.java中有4中元注解<br>@Target中的参数表示注解应该用在什么地方,参数类型有</p><ul><li>TYPE 类,接口(包括注解类型)或enum类型</li><li>FIELD 声明在字段上(包括enum实例)</li><li>METHOD,声明在方法上</li><li>PARAMETER,声明参数</li><li>CONSTRUCTOR,构造器的声明</li><li>LOCAL_VARIABLE,局部变量声明</li><li>ANNOTATION_TYPE,注解累心声明</li><li>PACKAGE,声明在包上<br>@Rentention注解 表示需要在什么级别保存该注解信息,就是注解的生命周期.参数RetentionPolicy</li><li>SOURCE 只保留在源文件中,被编译器丢弃</li><li>CLASS 注解在class文件中可用,但会被VM丢弃</li><li>RUNTIME 运行时保存,可以通过反射获得信息<br>@Document 将注解包含在Javadoc中<br>@Inherited 允许子类继承父类中的注解  </li></ul><p>举个例子,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(ElementType.METHOD)<br>    <span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<br>    <span class="hljs-meta">@interface</span> UseCases&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">id</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">description</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> "no description"</span>;<br>    &#125;<br></code></pre></td></tr></table></figure></p><p><strong>注意:</strong>注解定义上的内容值允许有String ,基本类型和枚举类型<br>这是个声明在方法级别上的注解,使用了这个注解的方法,可以通过反射来获得注解中的内容.如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">beanUtil</span></span>&#123;<br>    <span class="hljs-comment">//在这里使用了注解</span><br>    <span class="hljs-meta">@UseCases</span>(id = <span class="hljs-string">"123"</span>,description = <span class="hljs-string">"123的description"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">valipassword</span><span class="hljs-params">(String password)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (password.matches(<span class="hljs-string">"\\w*\\d\\w*"</span>));<br>    &#125;<br><br>    <span class="hljs-meta">@UseCases</span>(id =<span class="hljs-string">"48"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">encryptPassword</span><span class="hljs-params">(String password)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StringBuilder(password).reverse().toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>下面看测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; useCases = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        Collections.addAll(useCases, <span class="hljs-number">47</span>, <span class="hljs-number">48</span>, <span class="hljs-number">49</span>, <span class="hljs-number">50</span>);<br>        trackUseCases(useCases, beanUtil.class);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">trackUseCases</span><span class="hljs-params">(List&lt;Integer&gt; useCases, Class&lt;?&gt; cl)</span> </span>&#123;<br>        <span class="hljs-comment">//这里通过反射获取到此对象的所有方法,并且在其中找到所有的使用此注解的方法.</span><br>        <span class="hljs-keyword">for</span> (Method m : cl.getDeclaredMethods()) &#123;<br>            <span class="hljs-comment">//获得注解的对象</span><br>            UseCases uc = m.getAnnotation(UseCases.class);<br>            <span class="hljs-keyword">if</span> (uc != <span class="hljs-keyword">null</span>) &#123;<br>                System.out.println(<span class="hljs-string">"Found Use Case:"</span> + uc.id() + <span class="hljs-string">" "</span><br>                        + uc.description());<br>                useCases.remove(<span class="hljs-keyword">new</span> Integer(uc.id()));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>输出<br>Found Use Case:<span class="hljs-number">123</span> <span class="hljs-number">123</span>的description<br>Found Use Case:<span class="hljs-number">48</span> no description<br></code></pre></td></tr></table></figure></p><p>这里就完成了一个自定义注解的实现了.<br>在这里主要用到的就是两个  一个是@Target注解,里面指明了此注解要修饰的内容,例如构造器,方法,类等.还有一个是Retention注解,表明了此注解保存在哪里,有只在源码中存在,在class文件中存在,在运行时可以出现.如果要使用反射需要使用RUNTIME类型,在运行中通过反射来获得注解.   </p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>说了这么多,对java注解有了初步的了解,注解其实就是附加在类上的一段附加信息.</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>责任链模式</title>
      <link href="/2019/04/10/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/10/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>有多个对象, 每个对象都持有下一个对象的引用,这样就会形成一条责任链,请求在这条链上进行传递,知道某一对象决定处理该请求.但是发出者并不知道那个对象处理的请求.责任链模式的好处就是在隐瞒客户端的情况下,对系统进行动态的调整.<br>类结构图<br>三个继承了Handle的类组成了一个责任链,每个对象获取请求后都会看自己是否能处理,不能处理则放在最顶端.<br><img src="/2019/04/10/责任链模式/Client.png" alt></p><p><strong>handle抽象类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handle</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> Handle successor;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetSuccessor</span><span class="hljs-params">(Handle successor)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.successor=successor;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandleRequest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> request)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>三个责任链上的对象</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteHandle1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handle</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HandleRequest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> request)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(request&lt;<span class="hljs-number">10</span> &amp;&amp; request&gt;<span class="hljs-number">0</span>)&#123;<br>            System.out.println(<span class="hljs-string">"concreteHandler1 处理请求"</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            successor.HandleRequest(request);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteHandle2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handle</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HandleRequest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> request)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(request&lt;<span class="hljs-number">20</span> &amp;&amp; request&gt;<span class="hljs-number">10</span>)&#123;<br>            System.out.println(<span class="hljs-string">"concreteHandler2 处理请求"</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            successor.HandleRequest(request);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteHandle3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handle</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HandleRequest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> request)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(request&lt;<span class="hljs-number">30</span> &amp;&amp; request&gt;<span class="hljs-number">20</span>)&#123;<br>            System.out.println(<span class="hljs-string">"concreteHandler3 处理请求"</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            successor.HandleRequest(request);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>这里链上的对象分别处理不同的请求.</p><p><strong>客户端代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Handle h1 = <span class="hljs-keyword">new</span> ConcreteHandle1();<br>        Handle h2 = <span class="hljs-keyword">new</span> ConcreteHandle2();<br>        Handle h3 = <span class="hljs-keyword">new</span> ConcreteHandle3();<br>        h1.SetSuccessor(h2);<br>        h2.SetSuccessor(h3);<br><br>        h1.HandleRequest(<span class="hljs-number">15</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>这里如果要改变处理流程,客户端代码完全可以不用改变,改变责任链上的某些对象就可以更改执行逻辑,这就是责任链模式.</p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式是用来降低类类之间的耦合的.就是将一个系统分割成许多对象,对象间的通信不彼此直接通讯,而是通过一个中介者来进行通信,进行协调对象之间的关系.如果使用直接依赖对象来进行通讯的话,如果要更改一个对象,那么和他有关联的对象都会更改.但是使用中介者模式的话,更改对象只需要改变他和中介的关系就可以了.具体的调度类或者通信通过中介来实现.     </p><p><img src="/2019/04/10/责任链模式/Colleague.png" alt><br>从类图中能够看出来两个colleague两个类之间没有关系,都是通过一个mediator类在中间协调,当这样子的类多了之后,更改起来就只需要更改mediator类就可以了,方便维护.  </p><p><strong>同事接口</strong><br>确保每一个类关联这mediator<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Colleague</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> Mediator mediator;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Colleague</span><span class="hljs-params">(Mediator mediator)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.mediator = mediator;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>具体同事类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealColleague1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Colleague</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RealColleague1</span><span class="hljs-params">(Mediator mediator)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(mediator);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(String message)</span></span>&#123;<br>        mediator.send(message,<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Notify</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"同事1获得消息"</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealColleague2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Colleague</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RealColleague2</span><span class="hljs-params">(Mediator mediator)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(mediator);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(String message)</span></span>&#123;<br>        mediator.send(message,<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Notify</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"同事2获得消息"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>mediator类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mediator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(String message,Colleague colleague)</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteMediator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mediator</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> RealColleague1 colleague1;<br>    <span class="hljs-keyword">private</span> RealColleague2 colleague2;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setColleague1</span><span class="hljs-params">(RealColleague1 colleague1)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.colleague1 = colleague1;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setColleague2</span><span class="hljs-params">(RealColleague2 colleague2)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.colleague2 = colleague2;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(String message, Colleague colleague)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(colleague == colleague1)&#123;<br>            colleague2.Notify(message);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            colleague1.Notify(message);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>其实中介模式就是实现了迪米特法则,也就是最小知道原则,对于自己依赖的类知道的越少越好,在中介这模式中,每个同事只需要知道一个中介就可以,干什么都和中介说,然后中介帮他去做事.降低耦合性.</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8元空间</title>
      <link href="/2019/04/09/java8%E7%9A%84%E5%86%85%E5%AD%98%E6%94%B9%E5%8F%98/"/>
      <url>/2019/04/09/java8%E7%9A%84%E5%86%85%E5%AD%98%E6%94%B9%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-8元空间"><a href="#Java-8元空间" class="headerlink" title="Java 8元空间"></a>Java 8元空间</h2><p>今天想要测试方法区空间溢出会怎么样,然后调试了半天.使用String,静态变量,发现最后都是heap space OOM,对比着博客,发现一些Java 8 中的一些改变.记录一下.<br>在java 8中方法区也就是永久代已经是不在了,出现了一个替代者:元空间.</p><h2 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h2><p>Java　8Hotpot JVM开始使用本地化的内存存放类的元数据,这个空间也叫作元空间(Metaspace).它存储在native heap中,不受jvm内存限制,仅仅只受本地内存的限制.<br>Java Hotpot明确了元数据空间从操作系统请求空间,然后将其分成块.每个类加载器有一个块.类加载器从其块中为元数据分配空间.当类加载器卸载掉类的时候,它的块会被循环使用,或者会被操作系统回收.元数据一般使用一种内存映射文件的方法分配的空间,而不是malloc申请的空间.</p><p>这个样子的话就是表示着一个让人烦恼的问题也就是java.lang.OutOfMemoryError: PermGen的问题将不会存在.并且不需要在调整和监控这个内存空间.但是这个改变并不会消除类和类加载器的内存泄露,而是需要以一些不同的方式和学习新名词来追查这些问题.  </p><ul><li>-XX:MetaspaceSize 初始元空间大小,达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整,如果释放了大量空间,就适当减少,如果释放了很少的空间,在不超过MaxMetaspaceSize时可以增加.</li><li>-XX:MaxMetaspaceSize 最大的元空间大小,元空间大小不得超过这个值,如果超过会抛出OOM异常</li><li>-XX:MinMetaspaceFreeRatio 在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</li><li>-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</li></ul><p><strong>永久区的情况</strong></p><ul><li>永久代被完全移除</li><li>JVM参数PermSize和MaxPermSize也会被忽略.</li></ul><p><strong>元空间内存分配模型</strong></p><ul><li>绝大多数的类元数据的空间都从本地内存分配.</li><li>每个类加载器分配一个内存块的列表.</li><li>这个内存块是连续分配的.</li><li>元空间主要存储类信息,常量池,方法数据以及方法代码</li></ul><p>从JDK7开始就进行移除永久代的准备 比如进行如下改变</p><ul><li>符号引用转换到了native heap中</li><li>字面量常量(String)分配到java heap中</li><li>类的静态变量转移到了java heap中</li></ul><p>在JDK8中则是完全移除了永久代 连带着设置永久代大小的参数也被移除,取而代之的是一个Metaspace,这些空间直接在堆上进行分配.<br>为什么这么更改呢: 总结一下: </p><ul><li>首先是为了融合Hotpot JVM和JRockit VM而做出的努力,因为JRockit没有永久代</li><li>字符串存放在永久代,很容易出现性能问题和内存溢出.</li><li>类即方法信息难以确定大小,尤其是现在大多数的动态代理.而永久代的大小指定比较困难,大小容易出现永久代溢出,太大会导致老年代溢出</li><li>永久代对于GC不方便,而且效率比较低</li></ul><p><strong>元空间的优势</strong></p><ul><li>以前的jar包以及自己项目的class放在永久代中,但是永久代大小固定,所以经常可能出现永久代溢出.</li><li>永久代溢出将会不存在,元空间直接与放在本地堆中,大小可以动态增长</li><li>使用元空间后,每个项目都会共享可用的class内存空间,元空间中的class可以被多个项目使用,以前的永久代则是每个项目都有自己的永久代,并且用独立的class对象</li></ul><p><strong>元空间的容量</strong></p><ul><li>默认情况下，类元数据分配受到可用的本机内存容量的限制（容量依然取决于你使用32位JVM还是64位操作系统的虚拟内存的可用性</li><li>新参数 MaxMetaspaceSize被使用,允许限制类元数据的最大本地内存,如果没有指定,会根据程序运行情况动态设置<br><strong>元空间垃圾回收</strong></li><li>如果元空间的中的元数据达到参数”MaxMetaspaceSize”设置的值,才会触发对死亡对象和类加载器的垃圾回收</li><li>元空间中的对象的位置是固定的</li><li>元空间不会单独回收某个类</li><li>元空间提高了GC的性能,省掉了GC扫描的时间.</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/2019/04/09/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/09/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式主要是用来将某个类的接口转换成客户端期望的另一个接口的形式.目的用于消除接口的不兼容问题,主要分为三类,接口的适配器模式,类的适配器模式,对象的适配器模式.  </p><p>###　类的适配器模式<br><img src="/2019/04/09/适配器模式/Adapter.png" alt><br>源类 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Source</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"source的方法1"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>目标类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Targetable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//与source一样</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>适配器: 继承自源类,并实现目标接口,就完成了适配功能.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Source</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Targetable</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.printf(<span class="hljs-string">"targetable的method2"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>这样实现了target的类就有了source的类的功能.</p><h3 id="对象的适配器模式"><a href="#对象的适配器模式" class="headerlink" title="对象的适配器模式;"></a>对象的适配器模式;</h3><p>与类的适配器模式差不多,只是在将继承原有类变成了持有原有类.也可以实现相同的功能. 前两个类就不在写了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Targetable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Source source ;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Adapter</span><span class="hljs-params">(Source source)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.source = source;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.printf(<span class="hljs-string">"targetable的method2"</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;  <br>        source.method1();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="接口的适配器模式"><a href="#接口的适配器模式" class="headerlink" title="接口的适配器模式"></a>接口的适配器模式</h3><p>对于接口的适配器模式主要有一种情况就是在接口的方法有很多,但是我们可能只需要几个方法,这个时候就需要一个接口的适配器出现了.写一个接口的适配器抽象类,实现接口的所有方法,当然方法也是空方法,这时候具体类就可以继承此抽象类.实现自己想要实现的方法.</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/2019/04/09/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/09/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>就是讲一个复杂对象的构建与它的表示分离,是的同样的构建过程可以创建不同的表示.<br>如果我们使用了建造者模式,用户只需要指定需要构造的类型就可以得到它们,而具体建造的过程和细节就不需要知道.<br>在这里建造者类是为了表示要建造的对象的不同种类.通过多个建造类可以实现建造一个种类的不同对象.<br>指挥者主要是为了防止在建造的时候出错,因为建造的时候可能会有很多步骤或者顺序,防止步骤缺失或者顺序相反.起到一个管理的作用  </p><p>举例:</p><h3 id="要建造的对象"><a href="#要建造的对象" class="headerlink" title="要建造的对象:"></a>要建造的对象:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String head;<br>    <span class="hljs-keyword">private</span> String body;<br>    <span class="hljs-keyword">private</span> String arm;<br>    <span class="hljs-keyword">private</span> String leg;<br><br>    <span class="hljs-comment">//省略get和set方法</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="建造对象抽象类"><a href="#建造对象抽象类" class="headerlink" title="建造对象抽象类"></a>建造对象抽象类</h3><p>定义了建造对象的主要方法,方便子类继承.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> Person person;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PersonBuilder</span><span class="hljs-params">(Person person)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.person = person;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHead</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildBody</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildArm</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildLeg</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="具体建造实现类"><a href="#具体建造实现类" class="headerlink" title="具体建造实现类"></a>具体建造实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//瘦子类,定义瘦子人的属性</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThinPersonBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThinPersonBuilder</span><span class="hljs-params">(Person person)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(person);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHead</span><span class="hljs-params">()</span> </span>&#123;<br>        person.setHead(<span class="hljs-string">"头"</span>);<br>        System.out.println(<span class="hljs-string">"建造瘦子的头"</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildBody</span><span class="hljs-params">()</span> </span>&#123;<br>        person.setBody(<span class="hljs-string">"身体"</span>);<br>        System.out.println(<span class="hljs-string">"建造瘦子的身体"</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildArm</span><span class="hljs-params">()</span> </span>&#123;<br>        person.setArm(<span class="hljs-string">"胳膊"</span>);<br>        System.out.println(<span class="hljs-string">"建造瘦子的胳膊"</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildLeg</span><span class="hljs-params">()</span> </span>&#123;<br>        person.setLeg(<span class="hljs-string">"腿"</span>);<br>        System.out.println(<span class="hljs-string">"建造瘦子的腿"</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//高个类,定义高个子的属性</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HighPersonBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HighPersonBuilder</span><span class="hljs-params">(Person person)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(person);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHead</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"建造高个的头"</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildBody</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"建造高个的身体"</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildArm</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"建造高个的胳膊"</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildLeg</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"建造高个的腿"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候我们已经把建造类写完了,但是当我们想要建造一个类的时候会在逻辑代码中写大量的如此类的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createPerson</span><span class="hljs-params">()</span></span>&#123;<br>        personBuilder.buildArm();<br>        personBuilder.buildHead();<br>        personBuilder.buildBody();<br>        personBuilder.buildLeg();<br>    &#125;<br></code></pre></td></tr></table></figure></p><p>这个样子更改起来特别繁琐,这个时候就有了我们的指挥者出场了.只会这封装了建造的过程与逻辑.接下里看指挥者:</p><p>###　指挥者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonDirector</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> PersonBuilder personBuilder ;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PersonDirector</span><span class="hljs-params">(PersonBuilder  pb)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.personBuilder = pb;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createPerson</span><span class="hljs-params">()</span></span>&#123;<br>        personBuilder.buildArm();<br>        personBuilder.buildHead();<br>        personBuilder.buildBody();<br>        personBuilder.buildLeg();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>通过指挥者封装的建造代码,我们完全不必要知道建造的具体细节,只需要把产品的属性就是建造类给它就可以创建出一个完好的对象.    </p><p><strong>如果没有指挥者类,直接在建造者类中添加逻辑可以吗</strong><br>当然是不可以的,如果在建造者类中添加建造逻辑,如果建造模式一旦改变就需要改变所有的建造者类,不仅代码更改量极大,还违反了开闭原则.如果有了指挥类,比如要先造身体在造头,就只需要更改指挥者类中的逻辑就可以实现建造的顺序.</p><h3 id="好处与使用场景"><a href="#好处与使用场景" class="headerlink" title="好处与使用场景"></a>好处与使用场景</h3><p>建造这模式主要用在创建一些复杂的对象,并且这些对象内部构建间的建造顺序通常是稳定的,但对象内部的构建通常面临这复杂的变化.它是的建造代码与表示代码分离,由于建造者吟唱了该产品是如何组装的,所以若需要改变一个产品的内部表示,只需要再定义一个具体的建造者就可以了.</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/2019/04/08/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/08/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>策略模式就是定义一系列的算法,并且将算法封装起来,使他们可以相互替换,并且算法的替换不会使用客户端,需要设计一个接口,为一系列实现提供一个统一的方法,多个实现类实现该j接口,设计一个抽象类,提供辅助函数.<br>从概念来看,所有的算法完成的都是相同的工作,只是实现不同.在一个上下文中完成对算法的改变,每次要新增一个算法只需要在新增一个实现类就可以<br><img src="/2019/04/08/策略模式/类图.png" alt><br>具体例子:</p><h2 id="抽象接口"><a href="#抽象接口" class="headerlink" title="抽象接口:"></a>抽象接口:</h2><p>封装了算法对外的同意接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Sort</span>  </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="具体实现类"><a href="#具体实现类" class="headerlink" title="具体实现类:"></a>具体实现类:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Sort</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        quicksort(arr);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[])</span></span>&#123;<br>        <span class="hljs-comment">//具体实现</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MergeSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Sort</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-comment">//具体实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h2><p>使用算法全都这里使用,如果想要调用不同的算法,只需要传入相应的对象即可改变算法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;<br>    Sort sort;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Context</span><span class="hljs-params">(Sort sort)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.sort = sort;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ContextInterface</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>        sort.sort(arr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>总结 :<br>策略模式主要是封装了变化,当不同的行为对其在一个类中时,就可能会有很多的条件语句,可读性不高.所以可以将这些行为封装在独立的类中,在使用行为的类来增强代码可读性.</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2019/04/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式在很多应用程序中有很多应用.比如说一个全局的工厂,一个threadlocal等等.要实现一个好的单利对象有很多种方法,可以挑选自己最喜欢的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-comment">//饿汉式 在不要求一些性能方面可以这个样子</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Simple</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Simple instance = <span class="hljs-keyword">new</span> Simple();<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Simple</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Simple <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//进阶 懒汉式 此方法可能导致并发的时候出现故障,比如很多线程在同事使用Two</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Two</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Two instance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Two</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Two <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(instance==<span class="hljs-keyword">null</span>)&#123;<br>            instance = <span class="hljs-keyword">new</span> Two();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 进阶 懒汉式 线程同步 这个线程同步没问题,但是会导致争用过大</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Three</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Three instance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Three</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Three <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(instance==<span class="hljs-keyword">null</span>)&#123;<br>            instance = <span class="hljs-keyword">new</span> Three();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 进阶 良好的线程同步 双重检查</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Four</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Four instance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Four</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Four <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(instance==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (instance)&#123;<br>                <span class="hljs-keyword">if</span>(instance==<span class="hljs-keyword">null</span>)&#123;<br>                    instance=<span class="hljs-keyword">new</span> Four();<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 静态内部类,懒汉式</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Five</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Five</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleFactory</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Five instance = <span class="hljs-keyword">new</span> Five();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Five <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> SingleFactory.instance;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 枚举的单例模式 jdk1.5以后推荐</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> singleton &#123;<br>    INSTANCE;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂方法模式</title>
      <link href="/2019/04/08/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/08/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>在简单工厂模式中有个坏处就是,类的创建需要依赖工厂,也就是说如果要扩展类的功能需要对工厂类进行修改,这违背了开闭原则,所以从设计考虑,有一定问题.所以有了工厂方法模式,创建一个工厂接口和多个工厂实现类,这样一旦需要增加新的功能,直接增加工厂类就可以了,不需要修改以前的代码,只需要在添加一个工厂类.符合开闭原则.<br><img src="/2019/04/08/工厂方法模式/类图.jpg" alt><br>举例:</p><h2 id="类接口"><a href="#类接口" class="headerlink" title="类接口:"></a>类接口:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Sender</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类:"></a>实现类:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Sender</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"mailsender"</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Sender</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"SmsSender"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="工厂接口"><a href="#工厂接口" class="headerlink" title="工厂接口:"></a>工厂接口:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Provider</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Sender <span class="hljs-title">getSender</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="工厂实现类"><a href="#工厂实现类" class="headerlink" title="工厂实现类:"></a>工厂实现类:</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">public class MailSendFactory implements Provider &#123;<br>    @Override<br>    public Sender getSender() &#123;<br>        return new MailSender();<br>    &#125;<br>&#125;<br>public class SmsSendFactory implements Provider &#123;<br>    @Override<br>    public Sender getSender() &#123;<br>        return new SmsSender();<br>    &#125;<br>&#125;<br>~~~ <br><br>## 测试<br>~~~java<br>public static void main(String[] args) &#123;<br>        Provider provider = new MailSendFactory();<br>        Sender sender = provider.getSender();<br>    &#125;<br>    //这样做的好处就是完全解耦合,当需要不同的产品是只需要改变一下工厂类即可,其余的都可以不需要改.<br></code></pre></td></tr></table></figure><p>这个样子就可以在扩展的时候不需要修改之前的程序就可以添加扩展功能了.这样做的好处就是扩展性好,在添加新功能的时候只需要实现一个类,实现Sender接口,然后在做一个实现工厂,实现Provider接口,就可以了.<br>借鉴与<a href="https://www.cnblogs.com/geek6/p/3951677.html" target="_blank" rel="noopener">https://www.cnblogs.com/geek6/p/3951677.html</a></p><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式与工厂模式的区别不好区分.<br>抽象工厂模式是提供一个创建一系列相关或相互依赖对象的接口,而无需制定他们具体的类.<br>抽象工厂模式的好处就是易于交换产品系列,由于具体工厂类在一个应用中一般只需要出现一次(就像Provider = new MailSendFactory()). 这就使得改变一个应用的具体工厂编的非常容易,只需要改变具体工厂即可使用不用的产品配置.<br>抽象工厂模式与工厂方法模式的不同:　　　<br>工厂方法模式:  </p><ul><li>一个抽象产品类可以派生出多个具体产品类</li><li>一个抽象工厂类可以派生出多个具体工厂类</li><li>每个具体工厂类也只能派生出一个具体产品类<br>抽象工厂模式:　　　</li><li>多个抽象产品类，每个抽象产品类可以派生出多个具体产品类</li><li>一个抽象工厂类．可以派生出多个具体工厂类</li><li>每个具体工厂类可以创建多个具体的产品类的实例.  </li></ul><p><img src="/2019/04/08/工厂方法模式/抽象工厂模式.png" alt><br>举个例子: </p><h2 id="多个抽象产品类"><a href="#多个抽象产品类" class="headerlink" title="多个抽象产品类"></a>多个抽象产品类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Recived</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recived</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Sender</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多个实现类"><a href="#多个实现类" class="headerlink" title="多个实现类"></a>多个实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Sender</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"mailsender"</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailRecived</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Recived</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recived</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"mailRecived"</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsRecived</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Recived</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recived</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"smsRecived"</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Sender</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"SmsSender"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>##　测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Provider provider = <span class="hljs-keyword">new</span> MailSendFactory();<br>        Recived recived = provider.getRecived();<br>        Sender sender = provider.getSender();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>在这里如果想要使用mailSend邮件协议只需要改变上面那个工厂就可以在下面整体替换邮件系统.这样子给程序的扩展性与改变性提供了更好的方法.</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单工厂模式</title>
      <link href="/2019/04/07/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/07/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>在说简单工厂模式之前首先说一下设计模式的分类以及基本原则.</p><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p>总体来说设计模式总共分为三大类:<br>创建型模式:共5种,工厂方法模式,抽象工厂模式,单例模式,建造者模式,原型模式<br>结构性模式:共7种,适配器模式,装饰器模式,代理模式,外观模式,桥接模式,组合模式,享元模式<br>行为型模式:共11中,策略模式,模板方法模式,观察者模式,迭代子模式,责任链模式,命令模式,备忘录模式,状态模式,访问这模式,中介模式,解释器模式.</p><h2 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h2><h3 id="总原则-开闭原则"><a href="#总原则-开闭原则" class="headerlink" title="总原则:开闭原则"></a><strong>总原则:开闭原则</strong></h3><p>开闭原则就是说对扩展开放,对更改关闭.在程序需要扩展的时候不去更改原有的代码,而是增加新的代码,实现一个热插拔的效果.所以一句话就是为了是程序的扩展性好,易于维护和升级.  </p><ol><li>单一职责原则<br>不要存在多余一个导致类变更的原因,也就是说一个类应该只实现一个功能,如果不然,应该把类拆开.</li><li>里氏替换原则(LSP) 是面向对象的基本原则之一,此原则是说任何基类可以出现的地方其子类一定也可以出现.LSP是继承复用的基石,只有当衍生类能够替换掉基类,并且软件功能不受影响时,基类才能真正的被复用,而衍生类也能在基类的基础上增加一些新的功能.里氏替换原则是对开闭原则的补充.实现开闭原则的的关键步骤就是抽象画,而基类与子类的继承关系就是抽象的具体实现.<br>在里氏替换原则中,子类对父类的的方法尽量不要重写与重载.因为父类定义了一个良好的对外的接口,通过这个接口可以与外界更好的交互.子类不应该随便破坏它.</li><li>依赖倒转原则: 这是开闭原则的基础.主要是面向接口编程,依赖抽象而不依赖具体,写代码用到具体类时,不与具体类交互,而与上层接口交互.</li><li>接口隔离原则: 每个接口中不存在子类用不到的方法,如果有,则应该将接口分开为两个.</li><li>最少知道原则: 一个类对自己依赖的对象知道的越少越好,也就是说无论依赖的对象有多复杂,都应该将实现封装在方法的内部,通过public提供给外界,这样当被依赖的对象变化时候,才能最少的影响该类.</li><li>合成复用原则: 首先使用组合/聚合的方式,而不是使用继承.</li></ol><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式:"></a>简单工厂模式:</h2><p>简单工厂模式按理来说不属于23中设计模式,但是使用的却挺多的.<br>简单工厂模式主要有三种实现.</p><h3 id="第一种-最普通"><a href="#第一种-最普通" class="headerlink" title="第一种 最普通:"></a>第一种 最普通:</h3><p>创建共同的接口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Send</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>然后有两个类实现这个接口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Send1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Send</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"我是send1"</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">send2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Send</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"我是send2"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>在创建工厂类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SendFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Send <span class="hljs-title">getProduce</span><span class="hljs-params">(String type)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">"send1"</span>.equals(type))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Send1();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">"send2"</span>.equals(type))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> send2();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">"输入正确类型"</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//这个是测试</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryTest</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SendFactory sendFactory = <span class="hljs-keyword">new</span> SendFactory();<br>        Send send = sendFactory.getProduce(<span class="hljs-string">"send1"</span>);<br>        send.send();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>这里只需要传入相对应的参数就可以返回相应的类. 但是这样子有点不好就是如果类的种类变多将会使得代码变得难以维护与扩展.</p><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>将创建每个类变成多个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SendFactoryTwo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Send <span class="hljs-title">getSend1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Send1();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Send <span class="hljs-title">getSend2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> send2();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>此种方法比第一种方法要更好一些,因为这里通过方法名来返回实例,比普通的要更好一点.</p><p>###　第三种<br>将方法变为静态的．这样不需要建立工厂类就可以调用返回响应的方法．<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SendFactoryTwo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Send <span class="hljs-title">getSend1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Send1();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Send <span class="hljs-title">getSend2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> send2();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建.</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized详解</title>
      <link href="/2019/04/06/synchronized%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/04/06/synchronized%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h3><ul><li>修饰普通方法,锁的是当前的实例对象</li><li>静态同步方法,锁的是当前类的class对象</li><li>修饰代码块,锁的是括号中的实例对象</li></ul><h4 id="java对象头-monitor"><a href="#java对象头-monitor" class="headerlink" title="java对象头 monitor"></a>java对象头 monitor</h4><h5 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h5><p>synchronized 用的锁都是java对象头中的.hotpot虚拟机中对象头主要包括两部分数据:mark word(标记字段)和klass Point(类型指针).类型指针是指向它类元数据的指针,虚拟机通过这个指针来确定对象属于那个类的实例.标记字段用来存储对象自身的运行时数据,是实现偏向锁和轻量级锁的关键.<br>标记字段:<br>用于存储对象自身的运行时数据,如哈希码(HashCode) GC分代年龄 锁状态标志 线程持有的锁 偏向线程ID 偏向时间戳等.<br>考虑到虚拟机的空间效率问题,标记字段被设计成一个非固定的数据结构以便在极小的空间存储更多的数据.会根据对象的状态复用自己的存储空间.<br><img src="/2019/04/06/synchronized详解/对象头.jpeg" alt></p><h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><p>monitor可以理解为一个同步工具,或者说是一种同步机制,被描述为一个对象.<br>所有的java对象是天生的Monitor,每个对象都有成为Monitor的潜力,在java设计中,每个java对象天生有一把看不见的锁,叫内部锁或Monitor锁.<br>Monitor锁是线程私有的数据结构,每个线程有一个monitor record列表,还有一个可用的全局列表每个被锁住的对象都会和一个monitor关联.同时monitor中有一个Owner字段 存放拥有该锁的线程的唯一标识,标识该锁被这个线程占用. </p><ul><li>每个对象都有一个monitor(监视器锁).当monitor被占用时就会处于被锁定状态,在线程进入被同步的代码块时,会首先请求获取monitor的所有权,获取不到则会阻塞.<br><img src="/2019/04/06/synchronized详解/monitor数据结构.png" alt><br>owner 初始为NULL,标识没有任何线程拥有该monitor,线程成功拥有该锁保后存该线程唯一标识,释放之后会有设置为NULL<br>EntryQ: 关联一个系统互斥锁,阻塞所有试图获得monitor失败的线程<br>RcThis 表示阻塞或waiting在该monitor上的线程个数<br>Nest 用来实现可重入锁的计数<br>HashCode 保存从对象头上copy过来的哈希码(可能还有GC age)<br>Candidate 用来避免不必要的阻塞或等待线程唤醒,每次只能有一个线程能成功用有锁,如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程,会引起不必要的上下文切换,浪费系统开销,.Candidate只有两种值,0表示没有需要唤醒的线程,1 表示要唤醒一个继任线程来竞争锁.</li></ul><h3 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h3><ol><li>轻量级加锁<br>(1). 在代码进入同步快时候,如果对象锁状态为无所状态,,虚拟机在栈中建立一个名为锁记录(Lock record)的空间,用于存储对象当前mark word字段,<br>(2). 拷贝成功后,会通过CAS操作尝试将对象的mark word 更新为指向(lock record)的指针,并且讲lock record的owner指针指向Object mark word,<br>(3).如果更新成功,说明这个线程拥有了该对象的锁,并且讲mark word的标志位设置为00,表示此对象处于轻量级锁定状态<br>(4). 如果更新不成功,首先会检查mark word是否指向的是当前线程的栈帧,如果是说明线程拥有锁,如果不是,说明多个线程竞争锁,会膨胀为重量级锁,设置锁标志位为10,mark word存储指向重量级锁的指针,后面获取锁的都会进入阻塞状态</li><li>轻量级解锁:<br> (1). 通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word。<br> (2). 如果替换成功,同步完成<br> (3). 如果不成功变为重量级锁,在释放锁的时候唤醒被挂起的线程</li><li>偏向锁加锁<ol><li>访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态</li><li>如果为可偏向状态，则测试线程ID是否指向当前线程.如果是,进入(5),不是进入(3)</li><li>如果线程ID并未指向当前线程，则通过CAS操作竞争锁。(这里CAS替换是替换mark word中的线程ID,如果没有竞争,则会成功,如果有竞争,肯定有一个线程失败,这个失败的线程则会将锁升级为轻量级锁).如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）,如果竞争失败，执行（4）。  </li><li>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码  </li><li>执行同步代码</li></ol></li><li>偏向锁解锁<br>解锁主要就是到达一个全局安全点,首先暂停拥有偏向锁的线程,然后检查拥有偏向锁的线程是否或者,如果不活着,则设置为无锁状态,如果活着,拥有偏向锁的栈会被执行,遍历偏向对象的锁记录,占中的锁记录和对象头的mark word要么重新偏向于其他线程,要么恢复到无锁活着标记对象不合适作为偏向锁,最后唤醒暂停的线程.<br><img src="/2019/04/06/synchronized详解/java加锁解锁.png" alt></li></ol>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile详解</title>
      <link href="/2019/04/06/volatile%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/04/06/volatile%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="volatile的定义与实现原理"><a href="#volatile的定义与实现原理" class="headerlink" title="volatile的定义与实现原理"></a>volatile的定义与实现原理</h3><p>在java语言规范第三版中对volatile的定义如下:Java编程语言允许线程访问共享变量,为了保存共享变量能够被准确和一致的更新,线程应该确保通过排它锁单独获得这个变量.<br>java线程内存模型确保所有线程看到这个变量的值是一致的.<br>在了解volatile实现原理之前,要先看cpu术语与说明  : </p><ul><li>内存屏障(memory barriers) 一组处理器指令,用于实现对内存操作的顺序限制</li><li>缓冲行( cache line) cpu告诉缓存中可以分配的最小存储单位.处理器填写缓存行时会加载整个缓存行  </li><li>原子操作: 不可中断的一个或一系列操作</li><li>缓存行填充: 当处理器识别到从内存中读取操作数是可以缓存的,处理器就读取整个高速缓存行到适当的缓存  </li></ul><p>在java中,在对volatile变量进行写操作时候,会有lock指令,此lock指令会使得处理器发生两件事情</p><ul><li>将当前处理器缓存行的数据写会到系统内存</li><li>这个写会内存的操作会使其他cpu里缓存了该内存地址的数据无效<br>在这里为了提高处理速度,处理器不直接与内存直接通信,会首先将系统内存的数据读取到内部缓存后在进行操作.如果是普通变量,操作完不知道什么时候会写会内存,但是如果声明了volatile变量,则会立刻把缓存行的数据写会到系统内存.并且在多处理器下,为了保证各个处理器的缓存是一致的,会实现缓存一致性协议,每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是否过期,当处理器发现自己缓存行对应的内存地址被修改,就会将当前处理器的缓存行置为无效.  </li></ul><p><strong>volatile还有一个功能是禁止指令的重排序.</strong><br>在程序执行过程中存在三种重排序</p><ol><li>编译器优化的重排序,编译器在不改变单线程程序语义下,可以重新安排语句的执行顺序</li><li>指令级并行的重排序,现代处理器采用指令级并行技术将多条执行重叠执行,如果没有数据依赖性,可以改变语句对应执行的执行顺序</li><li>内存系统的重排序,由于处理器使用缓存和读/写缓冲区,是的加载和存储操作可能是在乱序执行<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>; <span class="hljs-number">1</span><br><span class="hljs-keyword">int</span> a = c; <span class="hljs-number">2</span><br> <span class="hljs-comment">//这里在其他线程看来可能2发生在1的前面,以为这里有缓存一说,所以就有了给b赋值,但是还没有被刷新回主存,但是a=c已经从内存中读取了,在这种情况下,可能会出现内存系统的冲排序</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="volatile对于重排序的规定"><a href="#volatile对于重排序的规定" class="headerlink" title="volatile对于重排序的规定"></a>volatile对于重排序的规定</h3><p>当写一个volatile变量的时候,JMM会把该线程对应的本地内存中的共享变量值刷新会主存.当读一个volatile变量时,JMM会把该线程对应的本地内存置为无效,线程接下来将从主内存中读取共享变量</p><ul><li>对于volatile写之前的操作不允许放在volatile之后</li><li>对于valatile读之后的所有操作不允许放在volatile之前</li><li>一个普通变量的写可以被重排序到volatile变量的写之前</li></ul><p>在对一个普通变量的单个读/写操作,与一个普通变量的读/写操作都是使用同一个锁同步来说执行效果相同. 这是在jdk1.5之后增强了volatile关键字的语义,这个语义保证了对单个volatile变量的读/写具有原子性.<br>volatile变量自身拥有如下特性:</p><ul><li>可见性: 对一个volatile变量的读,总是能看到对这个变量的最后写入</li><li>原子性: 对任意单个变量的读/写具有原子性,但是类似于volatile这种复合操作不具有原子性;</li></ul><p>###　内存屏障</p><ul><li>StoreStore 确保之前的写操作先行与之后的写操作</li><li>LoadLoad 确保之前的读操作先于之后所有的读操作</li><li>LoadStore 确保之前的读操作先行与之后所有的写操作</li><li>StoreLoad 确保之前的写操作先行与之后所有的读操作</li></ul><p>JMM在会在使用了volatile的变量使用之前之后加入不同的内存屏障来禁止指令的重排序.保证了单个变量的原子性与可见性.</p><ul><li>在每个volatile写操作之前插入一个storeStore屏障</li><li>在每个volatile写操作之后插入一个StoreLoad屏障</li><li>在每个volatile读操作之前插入一个LoadLoad屏障</li><li>在每个volatile读操作之后插入一个LoadStore屏障</li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReentrantLock源码解读</title>
      <link href="/2019/04/06/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/04/06/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="RentrantLock总览"><a href="#RentrantLock总览" class="headerlink" title="RentrantLock总览"></a>RentrantLock总览</h2><p>ReentrantLock是一个独占式的锁,支持重入.里面实现了公平锁与非公平锁;<br><img src="/2019/04/06/ReentrantLock源码解读/ReentrantLock.png" alt><br>其中ReentrantLock支持可公平锁与非公平锁,最顶层的父类是AQS.获取锁阻塞释放全部都是通过AQS来实现.接下来详细说明这些是怎么实现的. </p><h2 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h2><p>继承自AQS  </p><h3 id="abstract-void-lock"><a href="#abstract-void-lock" class="headerlink" title="abstract void lock();"></a>abstract void lock();</h3><p>抽象方法,让子类也就是两个公平和非公平类来实现.</p><h3 id="boolean-nonfairTryAcquire-int-acquires"><a href="#boolean-nonfairTryAcquire-int-acquires" class="headerlink" title="boolean nonfairTryAcquire(int acquires) ;"></a>boolean nonfairTryAcquire(int acquires) ;</h3><p>此为尝试获取非公平锁,非公平锁的实现就是首先CAS替换看自己是否能够获得锁,如果能够获得,则设置为拥有锁,如果不行,返回false;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>        <span class="hljs-keyword">int</span> c = getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            <span class="hljs-keyword">int</span> nextc = c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Maximum lock count exceeded"</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h3 id="boolean-tryRelease-int-releases"><a href="#boolean-tryRelease-int-releases" class="headerlink" title="boolean tryRelease(int releases)"></a>boolean tryRelease(int releases)</h3><p>释放掉指定的资源.如果当前线程没有拥有锁,则抛出异常.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> c = getState() - releases;<br>        <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>        <span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            free = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-comment">//用来设置获得锁的线程的方法</span><br>            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>        &#125;<br>        setState(c);<span class="hljs-comment">//设置状态,状态为0,表示没有线程获得锁</span><br>        <span class="hljs-keyword">return</span> free;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h3 id="boolean-isHeldExclusively"><a href="#boolean-isHeldExclusively" class="headerlink" title="boolean isHeldExclusively()"></a>boolean isHeldExclusively()</h3><p>表明当前线程是否是独占锁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// While we must in general read state before owner,</span><br>    <span class="hljs-comment">// we don't need to do so to check if current thread is owner</span><br>    <span class="hljs-keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p>ReentrantLock实现了两种锁,一种是非公平的,一种是公平的.两个的区别在于公平锁总是按照先来就先获得锁,非公平锁是谁抢到就算谁的.接下来看公平锁的实现:  </p><h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><p>锁主要是通过acquire()实现锁住,acquire(1)方法是AQS中定义好的方法,acquire首先会调用自己所实现的tryacquire()方法,如果不成功则加入队列中,成功就直接获取到锁.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>    acquire(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="boolean-tryAcquire-int-acquires"><a href="#boolean-tryAcquire-int-acquires" class="headerlink" title="boolean tryAcquire(int acquires)"></a>boolean tryAcquire(int acquires)</h3><p>首先判断锁状态是否为0,如果为0,在判断阻塞队列中是否有前驱,如果没有前驱则设置此线程为拥有锁的线程.如果状态不为0,查看是否是自己拥有锁,如果不是返回false;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>    <span class="hljs-keyword">int</span> c = getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>            compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-keyword">int</span> nextc = c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Maximum lock count exceeded"</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><p>非公平锁与公平所实现基本一样,但是是首先直接去获取锁,如果获取不到则加入队列,获取到就已经用有锁.<br>非公平锁有一点就是能够极大的提高系统吞吐量,公平所因为是先来先获得锁,所以在切换锁的时候会有很大的系统调度开销,而非公平锁是直接抢占,所以不会有很大的系统开销.但是可能会造成线程饥饿</p><h2 id="主要方法："><a href="#主要方法：" class="headerlink" title="主要方法："></a>主要方法：</h2><p>主要的一些方法都是通过调用内部类Sync的方法实现的.其实也就是用AQS定义好的框架来进行实现.</p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS源码解读</title>
      <link href="/2019/04/06/AQS%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/04/06/AQS%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="AbstractQueueSynchronizer"><a href="#AbstractQueueSynchronizer" class="headerlink" title="AbstractQueueSynchronizer"></a>AbstractQueueSynchronizer</h1><p>定义了一套多线程访问共享资源的同步框架<br>首先维护了一个volatile state状态量 和 一个阻塞队列,是FIFO队列,队列使用链表实现.state的访问方式有三种</p><ul><li>getstate()</li><li>setState()</li><li>compareAndSetState()<br>AQS 定义了两种资源共享状态,一种是独占(Exclusive 如ReentrantLock),一种是共享(Share可以同时多个线程执行).<br>不同的自定义同步实现器在实现时只需要实现共享资源state的获取和释放.至于具体的等待队列的维护与修改,顶层已了.自定义经实现好同步器主要实现一下几个方法.  </li><li>isHeldExclusive():表示该线程是否独占资源,只有用到condition才需要实现</li><li>tryAcquire():独占方式,尝试去获取资源,成功返回true,失败放回false</li><li>tryRelease():独占方式:尝试去释放资源</li><li>tryAcquireShared(int): 共享方式,尝试获取资源,负数表示失败,0表示成功,但没有剩余资源,正数表示成功并且有资源</li><li>tryReleaseShared(int): 共享方式:尝试释放资源,如果释放后允许释放后续等待资源返回true,否则放回false</li></ul><p>以ReentrantLock为例,首先初始化state为0,表示未锁定状态.一旦调用lock.lock(),会尝试调用tryAcquire()并且将state+1,此时其他线程会获取所失败,知道unlock()讲state置为0,在获取到此锁的时候,可以继续获取,但是每次都会是state+1.<br>CountDownLatch 中,任务分为N个子线程执行,state初始化为N,这个N个子线程是并行执行的,每个子线程执行完之后会countDown()一次,state会通过CAS减一,等待所有的线程都执行完之后,在unpark()会调用主线程继续执行自己的工作.</p><h2 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h2><p>队列是通过Node来保持一个队列的,就相当于链表中的普通节点,保存了同步的线程以及线程的状态,上一个节点,下一个节点.: </p><ul><li>int waitStatus 共有四种状态:<ul><li>CANCELLED: 值为1,在等待过程中被中断,需要从队列中取消该节点.</li><li>SIGNAL :值为-1,后继节点的线程处于等待状态,当前节点的线程如果释放了同步状态或取消,将会通知后集节点,使后继节点的线程得意运行.</li><li>CONDITION :值为-2,表示该节点处于等待队列中，节点的线程等待在condition上,当其他线程调用Condition.signal()方法会唤醒此线程,进入到同步队列中</li><li>PROPAGATE：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。</li></ul></li><li>Node prev,前驱节点,当节点加入同步队列时被设置   </li><li>Node next,后继节点,  </li><li>Node nextWaiter 等待队列中的后继节点.如果当前节点是共享的,那么这个字段是一个SHARED常量,也就是说节点类型(独占和共享)和等待队列中的后继节点共用同一个字段  </li><li>Thread thread 获取同步状态的线程.<h3 id="方法一览"><a href="#方法一览" class="headerlink" title="方法一览"></a>方法一览</h3>isShared() 判断是否是共享模式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isShared</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> nextWaiter == SHARED;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>predecessor() 返回前驱节点,如果前驱为空,抛出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> Node <span class="hljs-title">predecessor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NullPointerException </span>&#123;<br>        Node p = prev;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> p;<br>   &#125;<br></code></pre></td></tr></table></figure></p><h2 id="AQS内部属性"><a href="#AQS内部属性" class="headerlink" title="AQS内部属性"></a>AQS内部属性</h2><ul><li>Node head: 队列的头结点</li><li>Node tail: 队列的尾节点</li><li>int state: 锁的状态,独占模式下为0或1,0为空闲,1为已经有线程获取到锁.共享模式下为还剩余多少资源</li><li>long spinForTimeoutThreshold = 1000L: 最小的等待时间 在下面讲到</li></ul><h2 id="方法-独占模式方法"><a href="#方法-独占模式方法" class="headerlink" title="方法 独占模式方法"></a>方法 独占模式方法</h2><h3 id="acquire-获取锁"><a href="#acquire-获取锁" class="headerlink" title="acquire() 获取锁"></a>acquire() 获取锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-number">2</span>     <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br><span class="hljs-number">3</span>         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br><span class="hljs-number">4</span>         selfInterrupt();<br><span class="hljs-number">5</span> &#125;<br></code></pre></td></tr></table></figure><p>TryAcquire(arg)如果成功获取锁,则直接返回.而tryAcquire方法需要具体实现<br>addWaiter() 方法则将线程加入到队列的尾部,并标记为独占模式<br>acquireQueued() 使线程在等待队列中获取资源,知道获取资源后返回,如果被中断过,则返回true.</p><h3 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter()"></a>addWaiter()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">1</span> <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;<br> <span class="hljs-number">2</span>     <span class="hljs-comment">//以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）</span><br> <span class="hljs-number">3</span>     Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);<br> <span class="hljs-number">4</span>     <br> <span class="hljs-number">5</span>     <span class="hljs-comment">//尝试快速方式直接放到队尾。</span><br> <span class="hljs-number">6</span>     Node pred = tail;<br> <span class="hljs-number">7</span>     <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;<br> <span class="hljs-number">8</span>         node.prev = pred;<br> <span class="hljs-number">9</span>         <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<span class="hljs-comment">//利用CAS进行替换</span><br><span class="hljs-number">10</span>             pred.next = node;<br><span class="hljs-number">11</span>             <span class="hljs-keyword">return</span> node;<br><span class="hljs-number">12</span>         &#125;<br><span class="hljs-number">13</span>     &#125;<br><span class="hljs-number">14</span>     <br><span class="hljs-number">15</span>     <span class="hljs-comment">//上一步失败则通过enq入队。</span><br><span class="hljs-number">16</span>     enq(node);<br><span class="hljs-number">17</span>     <span class="hljs-keyword">return</span> node;<br><span class="hljs-number">18</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="enq-Node"><a href="#enq-Node" class="headerlink" title="enq(Node)"></a>enq(Node)</h3><p>如果直接添加到队尾失败则使用enq方法加入队尾<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">1</span> <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;<br> <span class="hljs-number">2</span>     <span class="hljs-comment">//CAS"自旋"，直到成功加入队尾</span><br> <span class="hljs-number">3</span>     <span class="hljs-keyword">for</span> (;;) &#123;<br> <span class="hljs-number">4</span>         Node t = tail;<br> <span class="hljs-number">5</span>         <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 队列为，空创建一个空的标志结点作为head结点，并将tail也指向它。</span><br> <span class="hljs-number">6</span>             <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))<br> <span class="hljs-number">7</span>                 tail = head;<br> <span class="hljs-number">8</span>         &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//正常流程，放入队尾</span><br> <span class="hljs-number">9</span>             node.prev = t;<br><span class="hljs-number">10</span>             <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br><span class="hljs-number">11</span>                 t.next = node;<br><span class="hljs-number">12</span>                 <span class="hljs-keyword">return</span> t;<br><span class="hljs-number">13</span>             &#125;<br><span class="hljs-number">14</span>         &#125;<br><span class="hljs-number">15</span>     &#125;<br><span class="hljs-number">16</span> &#125;<br></code></pre></td></tr></table></figure></p><p>使用CAS自旋,直到成功加入队尾</p><h2 id="acquireQueued-Node-int"><a href="#acquireQueued-Node-int" class="headerlink" title="acquireQueued(Node int)"></a>acquireQueued(Node int)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">1</span> <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br> <span class="hljs-number">2</span>     <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//标记是否成功拿到资源</span><br> <span class="hljs-number">3</span>     <span class="hljs-keyword">try</span> &#123;<br> <span class="hljs-number">4</span>         <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//标记等待过程中是否被中断过</span><br> <span class="hljs-number">5</span>         <br> <span class="hljs-number">6</span>         <span class="hljs-comment">//又是一个“自旋”！</span><br> <span class="hljs-number">7</span>         <span class="hljs-keyword">for</span> (;;) &#123;<br> <span class="hljs-number">8</span>             <span class="hljs-keyword">final</span> Node p = node.predecessor();<span class="hljs-comment">//拿到前驱</span><br> <span class="hljs-number">9</span>             <span class="hljs-comment">//如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。</span><br><span class="hljs-number">10</span>             <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br><span class="hljs-number">11</span>                 setHead(node);<span class="hljs-comment">//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。</span><br><span class="hljs-number">12</span>                 p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！</span><br><span class="hljs-number">13</span>                 failed = <span class="hljs-keyword">false</span>;<br><span class="hljs-number">14</span>                 <span class="hljs-keyword">return</span> interrupted;<span class="hljs-comment">//返回等待过程中是否被中断过</span><br><span class="hljs-number">15</span>             &#125;<br><span class="hljs-number">16</span>             <br><span class="hljs-number">17</span>             <span class="hljs-comment">//如果自己可以休息了，就进入waiting状态，直到被unpark()</span><br><span class="hljs-number">18</span>             <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br><span class="hljs-number">19</span>                 parkAndCheckInterrupt()) <span class="hljs-comment">//parkAndCheckiInterrupt方法会进行检查是否被中断过,并且阻塞线程,此处用自旋是为了保证唤醒的节点能够同步的获取到锁.</span><br><span class="hljs-number">20</span>                 interrupted = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true</span><br><span class="hljs-number">21</span>         &#125;<br><span class="hljs-number">22</span>     &#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-number">23</span>         <span class="hljs-keyword">if</span> (failed)<br><span class="hljs-number">24</span>             cancelAcquire(node);<br><span class="hljs-number">25</span>     &#125;<br><span class="hljs-number">26</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h3><p>用于检查状态,看看自己是否可以去休息,也就是阻塞<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">1</span> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;<br> <span class="hljs-number">2</span>     <span class="hljs-keyword">int</span> ws = pred.waitStatus;<span class="hljs-comment">//拿到前驱的状态</span><br> <span class="hljs-number">3</span>     <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br> <span class="hljs-number">4</span>         <span class="hljs-comment">//如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了</span><br> <span class="hljs-number">5</span>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br> <span class="hljs-number">6</span>     <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br> <span class="hljs-number">7</span>         <span class="hljs-comment">/*<br> 8          * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。<br> 9          * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！<br>10          */</span><br><span class="hljs-number">11</span>         <span class="hljs-keyword">do</span> &#123;<br><span class="hljs-number">12</span>             node.prev = pred = pred.prev;<br><span class="hljs-number">13</span>         &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br><span class="hljs-number">14</span>         pred.next = node;<br><span class="hljs-number">15</span>     &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-number">16</span>          <span class="hljs-comment">//如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！</span><br><span class="hljs-number">17</span>         compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br><span class="hljs-number">18</span>     &#125;<br><span class="hljs-number">19</span>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><span class="hljs-number">20</span> &#125;<br></code></pre></td></tr></table></figure></p><p>###　parkAndCheckInterrupt()　<br>将进程阻塞，并且返回中断状态.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>        LockSupport.park(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">return</span> Thread.interrupted();<br>    &#125;<br></code></pre></td></tr></table></figure></p><h3 id="doAcquireInterruptibly-int-arg"><a href="#doAcquireInterruptibly-int-arg" class="headerlink" title="doAcquireInterruptibly(int arg)"></a>doAcquireInterruptibly(int arg)</h3><p>此方法为支持中断的获取资源,如果在过程中发生了中断,则方法会抛出中断并且返回<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);<br>        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="hljs-comment">//首先看是否能够获取资源,获取不到则不会取消</span><br>                    setHead(node);<br>                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<span class="hljs-comment">//如果failed=true,说明没有获取到资源,并且有过中断,因为中断后会返回并且抛出异常.则取消该节点.</span><br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h3 id="doAcquireNanos-int-arg-long-nanosTimeout"><a href="#doAcquireNanos-int-arg-long-nanosTimeout" class="headerlink" title="doAcquireNanos(int arg, long nanosTimeout)"></a>doAcquireNanos(int arg, long nanosTimeout)</h3><p>是支持超时的获取同步状态,在时间限制到的情况下会直接返回false,否则获取到同步状态则返回true<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">doAcquireNanos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg, <span class="hljs-keyword">long</span> nanosTimeout)</span><br>            <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> deadline = System.nanoTime() + nanosTimeout;<span class="hljs-comment">//计算出deadline时间</span><br>        <span class="hljs-keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);<span class="hljs-comment">//将此节点加入队列</span><br>        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//自旋</span><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> Node p = node.predecessor();<span class="hljs-comment">//获取前驱,与普通获取一样</span><br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                    setHead(node);<br>                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>                nanosTimeout = deadline - System.nanoTime(); <span class="hljs-comment">//再次判断是否超时</span><br>                <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<span class="hljs-comment">//判断是否可以阻塞</span><br>                    nanosTimeout &gt; spinForTimeoutThreshold)<span class="hljs-comment">//必须得经过一次spinForTimeoutThreshold</span><br>                    LockSupport.parkNanos(<span class="hljs-keyword">this</span>, nanosTimeout);<br>                    <span class="hljs-comment">//如果nanosTimeout小于spinForTimeoutThreshold,将不会是线程进入超时等待,则会进入一个自旋的过程.原因在于非常短的超时无法做到十分精确,如果这个时候在进行超时等待,会让nanoTimeout的超时从整体上变现的不精确.</span><br>                <span class="hljs-keyword">if</span> (Thread.interrupted())<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<span class="hljs-comment">//如果线程被中断过,则会抛出一个异常并且放回</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<span class="hljs-comment">//如果没有获得资源或则被中断或者超时都会取消此节点.</span><br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></p><p><strong>realease</strong><br>会释放指定量的资源,首先执行tryrelease()方法,此方法为继承者实现.如果彻底释放,会唤醒队列中的其他线程来获取资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-number">2</span>     <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br><span class="hljs-number">3</span>         Node h = head;    <span class="hljs-comment">//找到头结点</span><br><span class="hljs-number">4</span>         <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<span class="hljs-comment">//在头结点不为空的情况下并且waitStatus不为0也就是不是刚初始化的情况</span><br><span class="hljs-number">5</span>             unparkSuccessor(h);    <span class="hljs-comment">//唤醒等待队列里的下一个线程</span><br><span class="hljs-number">6</span>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><span class="hljs-number">7</span>     &#125;<br><span class="hljs-number">8</span>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><span class="hljs-number">9</span> &#125;<br></code></pre></td></tr></table></figure></p><h3 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor()"></a><strong>unparkSuccessor()</strong></h3><p>用来唤醒等待对垒中的下一个线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">1</span> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;<br> <span class="hljs-number">2</span>     <span class="hljs-comment">//这里，node一般为当前线程所在的结点。</span><br> <span class="hljs-number">3</span>     <span class="hljs-keyword">int</span> ws = node.waitStatus;<br> <span class="hljs-number">4</span>     <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//置零当前线程所在的结点状态，允许失败。</span><br> <span class="hljs-number">5</span>         compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br> <span class="hljs-number">6</span> <br> <span class="hljs-number">7</span>     Node s = node.next;<span class="hljs-comment">//找到下一个需要唤醒的结点s</span><br> <span class="hljs-number">8</span>     <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果为空或已取消,则从尾节点开始找,知道找到第一个有效的节点</span><br> <span class="hljs-number">9</span>         s = <span class="hljs-keyword">null</span>;<br><span class="hljs-number">10</span>         <span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev)<br><span class="hljs-number">11</span>             <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<span class="hljs-comment">//从这里可以看出，&lt;=0的结点，都是还有效的结点。</span><br><span class="hljs-number">12</span>                 s = t;<br><span class="hljs-number">13</span>     &#125;<br><span class="hljs-number">14</span>     <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)<br><span class="hljs-number">15</span>         LockSupport.unpark(s.thread);<span class="hljs-comment">//唤醒</span><br><span class="hljs-number">16</span> &#125;<br></code></pre></td></tr></table></figure></p><h2 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h2><p>和独占模式差不多,但是在共享模式只有当前线程是头结点的下一个节点的时候,才可以去获取资源,有剩余的话会唤醒后续的节点,不会隔着来.</p><h3 id="acquireShared-int-arg"><a href="#acquireShared-int-arg" class="headerlink" title="acquireShared(int arg)"></a>acquireShared(int arg)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//尝试直接获取,小于0说明没有资源</span><br>            doAcquireShared(arg);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="doAcquireShared-int-arg"><a href="#doAcquireShared-int-arg" class="headerlink" title="doAcquireShared(int arg)"></a>doAcquireShared(int arg)</h3><p>与独占模式相同,只不过在加入队列的节点模式改变成了共享模式,还有一点就是在共享模式下如果还有剩余资源则会继续唤醒之后的节点.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-comment">// 首先以共享方式加入队列</span><br>    <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);<br>    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//标志位检查是否呗中断过</span><br>        <span class="hljs-comment">// 与独占模式相同,自旋保证获取资源,</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                    <span class="hljs-keyword">if</span> (interrupted)<br>                        selfInterrupt();<br>                    failed = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//加入阻塞队列之后进行中断检查,如果中断过则取消节点.</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="doAcquireSharedInterruptibly-int-arg"><a href="#doAcquireSharedInterruptibly-int-arg" class="headerlink" title="doAcquireSharedInterruptibly(int arg)"></a>doAcquireSharedInterruptibly(int arg)</h3><p>这里与独占模式不同,独占模式首先获取资源,将头结点设置为当前节点,获取不到则阻塞,并且被中断过就抛出异常,在这里首先会获取资源,设置头结点之后多了一条propagate操作.在这个会在判断后继节点是否为shared的,如果是,则会唤醒.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);<br>    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果还有资源,进入下一个方法</span><br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="setHeadAndPropagate-node-r"><a href="#setHeadAndPropagate-node-r" class="headerlink" title="setHeadAndPropagate(node, r)"></a>setHeadAndPropagate(node, r)</h3><p>在这里会先看后继节点,如果后继节点是shared状态则会继续唤醒后集节点<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java">    private void setHeadAndPropagate(Node node, int propagate) &#123;<br>        Node h = head; // Record old head for check below<br>        setHead(node);<br>        if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||<br>            (h = head) == null || h.waitStatus &lt; 0) &#123;<br>            Node s = node.next;<br>            if (s == null || s.isShared())<br>                doReleaseShared();<br>        &#125;<br>    &#125;<br>~~~ <br><br>### doReleaseShared()<br>首先先看头结点,如果头结点为signal状态,则会唤醒头结点的下一个节点.如果状态为0,则讲状态转换为propagate状态,继续向下传播.<br>~~~java<br>private void doReleaseShared() &#123;<br>        <br>        for (;;) &#123;<br>            Node h = head;<br>            if (h != null &amp;&amp; h != tail) &#123;<br>                int ws = h.waitStatus;<br>                if (ws == Node.SIGNAL) &#123;<br>                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))<br>                        continue;            // loop to recheck cases<br>                    unparkSuccessor(h);//在这里会唤醒h节点之后的一个等待节点<br>                &#125;<br>                else if (ws == 0 &amp;&amp;<br>                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))<br>                    continue;                // loop on failed CAS<br>            &#125;<br>            if (h == head)                   // loop if head changed<br>                break;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h3 id="unparkSuccessor-Node-node"><a href="#unparkSuccessor-Node-node" class="headerlink" title="unparkSuccessor(Node node)"></a>unparkSuccessor(Node node)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ws = node.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>    Node s = node.next;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        s = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev)<span class="hljs-comment">//这里从后向前遍历主要是保证了在共享模式下可能要唤醒多个,保证了每次唤醒的节点都是最开始的那个节点,如果从前向后遍历的话,可能会被已经唤醒的节点所打断,导致再次唤醒已经唤醒的节点. </span><br>        <span class="hljs-comment">// 还有一点就是从后向前便利保证了能够将失效的节点能更快的被回收.</span><br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)<br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="cancelAcquire-Node-node"><a href="#cancelAcquire-Node-node" class="headerlink" title="cancelAcquire(Node node)"></a>cancelAcquire(Node node)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancelAcquire</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-comment">//节点为空则直接返回</span><br>        <span class="hljs-keyword">return</span>;<br><br>    node.thread = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//将节点的线程置位空,方便GC</span><br>    Node pred = node.prev;<span class="hljs-comment">// 找到前驱节点</span><br>    <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//这里找到第一个有效的前驱节点</span><br>        node.prev = pred = pred.prev;<br>    Node predNext = pred.next;<br>    node.waitStatus = Node.CANCELLED; <span class="hljs-comment">// 将此节点状态设置为取消状态</span><br><br>    <span class="hljs-comment">//如果节点为尾节点,并且设置尾节点为最后一个有效节点,则把尾节点的next设置为null//有助于GC</span><br>    <span class="hljs-keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;<br>        compareAndSetNext(pred, predNext, <span class="hljs-keyword">null</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//否则将前驱节点替换为node的后继节点</span><br>        <span class="hljs-keyword">int</span> ws;<br>        <span class="hljs-keyword">if</span> (pred != head &amp;&amp;<br>            ((ws = pred.waitStatus) == Node.SIGNAL ||<br>             (ws &lt;= <span class="hljs-number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;<br>            pred.thread != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//如果前驱节点不为为头结点并且前驱节点的状态为signal而且线程不为空.</span><br>            Node next = node.next;<br>            <span class="hljs-keyword">if</span> (next != <span class="hljs-keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                compareAndSetNext(pred, predNext, next);<span class="hljs-comment">//将前驱有效节点的下一个节点设置为node的下一个节点</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            unparkSuccessor(node);<span class="hljs-comment">//如果前驱节点是头结点,就唤醒node之前的前驱节点.</span><br>        &#125;<br>        node.next = node; <span class="hljs-comment">// help GC</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="内部类ConditionObject"><a href="#内部类ConditionObject" class="headerlink" title="内部类ConditionObject"></a>内部类ConditionObject</h1><p>实现 Condition接口和serializable接口<br>condition的实现主要包括等待队列,等待和通知.等待队列是一个FIFO的队列,如果线程调用了Condition.await()方法,则会释放锁,构造成节点加入等待队列并进入等待状态.这里节点复用了同步器的节点定义.</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性:"></a>属性:</h2><ul><li>Node firstWaiter: 第一个等待节点</li><li>Node lastWaiter: 最后一个等待节点</li></ul><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法:"></a>主要方法:</h2><h3 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h3><p>调用await()方法回事当前线程进入等待队列并且释放锁,同事状态变为等待状态.在返回时,当前线程一定获取了Condition相关联的锁.<br>从队列的角度看await()方法,调用await()方法,相当于同步队列的首节点移动到了Condition的等待队列中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//因为此时节点还获取有锁,所以不会产生竞争,直接赋值就可以</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>    <span class="hljs-comment">//当前线程加入等待队列中</span><br>    Node node = addConditionWaiter();<br>    <span class="hljs-comment">//释放同步状态</span><br>    <span class="hljs-keyword">int</span> savedState = fullyRelease(node);<br>    <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123; <span class="hljs-comment">//这里判断是否应该等待,看节点状态是否为Condition状态</span><br>        LockSupport.park(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//阻塞</span><br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<span class="hljs-comment">//加入竞争中</span><br>        interruptMode = REINTERRUPT;<br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>        unlinkCancelledWaiters();<br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>        reportInterruptAfterWait(interruptMode);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>###　addConditionWaiter()<br>将节点加入到condition等带队列中.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addConditionWaiter</span><span class="hljs-params">()</span> </span>&#123;<br>    Node t = lastWaiter;<br>    <span class="hljs-comment">// If lastWaiter is cancelled, clean out.</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<br>        unlinkCancelledWaiters();<span class="hljs-comment">//断开已经取消的节点链</span><br>        t = lastWaiter;<br>    &#125;<br>    Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);<span class="hljs-comment">//创建一个新的节点.</span><br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>)<br>        firstWaiter = node;<br>    <span class="hljs-keyword">else</span><br>        t.nextWaiter = node;<br>    lastWaiter = node;<br>    <span class="hljs-keyword">return</span> node; <br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="unlinkCancelledWaiters"><a href="#unlinkCancelledWaiters" class="headerlink" title="unlinkCancelledWaiters()"></a>unlinkCancelledWaiters()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlinkCancelledWaiters</span><span class="hljs-params">()</span> </span>&#123;<br>    Node t = firstWaiter;<br>    Node trail = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">while</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>        Node next = t.nextWaiter;<br>        <span class="hljs-keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;<br>            t.nextWaiter = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">if</span> (trail == <span class="hljs-keyword">null</span>)<br>                firstWaiter = next;<br>            <span class="hljs-keyword">else</span><br>                trail.nextWaiter = next;<br>            <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>)<br>                lastWaiter = trail;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            trail = t;<br>        t = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h3><p>唤醒第一个节点,如果当前线程没有获取锁,则抛出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>    Node first = firstWaiter;<br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)<br>        doSignal(first);<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="doSignal"><a href="#doSignal" class="headerlink" title="doSignal()"></a>doSignal()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignal</span><span class="hljs-params">(Node first)</span> </span>&#123;<span class="hljs-comment">//循环唤醒下一个线程</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-keyword">null</span>)<br>            lastWaiter = <span class="hljs-keyword">null</span>;<br>        first.nextWaiter = <span class="hljs-keyword">null</span>;<br>    &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;<br>             (first = firstWaiter) != <span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="transferForSignal-Node-first"><a href="#transferForSignal-Node-first" class="headerlink" title="transferForSignal(Node first)"></a>transferForSignal(Node first)</h3><p>将节点设置状态为0,然后在加入队尾,在唤醒线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">transferForSignal</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    Node p = enq(node);<br>    <span class="hljs-keyword">int</span> ws = p.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))<br>        LockSupport.unpark(node.thread);<span class="hljs-comment">//这里唤醒线程后,线程会从await()方法的while循环中退出(isOnSyncQueue(Node node)方法返回ture,节点已经在同步队列中)借着在调用同步器的acquireQueued()方法加入竞争</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法:"></a>其他方法:</h2><ul><li>hasQueuedThreads() 返回是否有阻塞线程</li><li>hasContended 返回是否有线程在执行</li><li>isQueued(Thread thread) 返回当前线程是否在阻塞中</li><li>getQueueLength() 返回队列的长度</li><li>Collection<thread> getQueuedThreads 返回正在阻塞的线程</thread></li><li>getExclusiveQueuedThreads() 返回独占状态的阻塞线程,返回一个线程集合Collection<thread></thread></li><li>getSharedQueuedThreads() 返回共享状态下的线程集合</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>timSort源码剖析</title>
      <link href="/2019/04/05/timSort%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2019/04/05/timSort%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="TimSort"><a href="#TimSort" class="headerlink" title="TimSort"></a>TimSort</h1><p>timsort是jdk自带的一种特别高效的排序算法,大致思想使用的是归并排序,但是内部细节做了许多的优化.<br>在timsort中,主要是为待排序数组分为很多个run块,通过讲这些run块进行归并排序.最后实现总体排序.每个run块的大小为16-32大小.<br>优化地方: </p><ul><li>当待排序数组长度小于32就使用二分排序算法</li><li>分为多个run块,在通过把run块的起始位置和长度压入栈中,在进行合并.</li><li>在找到一个run块的时候会首先判断数组中有序元素的个数.通过二分排序从第一个无序的元素开始排序,加快排序速度</li><li>在进行合并的时候会进行”去头”,”去尾”操作,是的归并操作加快速度.</li></ul><h2 id="sort-T-a-int-lo-int-hi-Comparator-lt-super-T-gt-c-T-work-int-workBase-int-workLen"><a href="#sort-T-a-int-lo-int-hi-Comparator-lt-super-T-gt-c-T-work-int-workBase-int-workLen" class="headerlink" title="sort(T[] a, int lo, int hi, Comparator&lt;? super T&gt; c, T[] work, int workBase, int workLen)"></a>sort(T[] a, int lo, int hi, Comparator&lt;? super T&gt; c, T[] work, int workBase, int workLen)</h2><p>timsort对外的唯一接口.并且只能本包内访问<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T[] a, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi, Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; c,<br>                         T[] work, <span class="hljs-keyword">int</span> workBase, <span class="hljs-keyword">int</span> workLen)</span> </span>&#123;<br>        <span class="hljs-keyword">assert</span> c != <span class="hljs-keyword">null</span> &amp;&amp; a != <span class="hljs-keyword">null</span> &amp;&amp; lo &gt;= <span class="hljs-number">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;<br><br>        <span class="hljs-keyword">int</span> nRemaining  = hi - lo;<br>        <span class="hljs-comment">//小于2不用排序,直接返回</span><br>        <span class="hljs-keyword">if</span> (nRemaining &lt; <span class="hljs-number">2</span>) <br>            <span class="hljs-keyword">return</span>; <br>        <span class="hljs-comment">// 看是否小于min_merge,如果小于就直接二分排序,没必要进行复杂的timsort.</span><br>        <span class="hljs-keyword">if</span> (nRemaining &lt; MIN_MERGE) &#123;<br>            <span class="hljs-comment">//下面有详细说明.返回的是从lo开始已经有序的个数,对二分排序用</span><br>            <span class="hljs-keyword">int</span> initRunLen = countRunAndMakeAscending(a, lo, hi, c);<br>            <span class="hljs-comment">// 从第一没有排好序位置开始进行二分排序</span><br>            binarySort(a, lo, hi, lo + initRunLen, c);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//这个时候开始真正的timsort</span><br>        TimSort&lt;T&gt; ts = <span class="hljs-keyword">new</span> TimSort&lt;&gt;(a, c, work, workBase, workLen);<br>        <span class="hljs-comment">//主要将数组分为一个个的minRun,最后在进行合并,如果长度为2的n次幂,minRun为32,否则为16-32之间的数.</span><br>        <span class="hljs-keyword">int</span> minRun = minRunLength(nRemaining);<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">//再次找到a中已经有序的元素个数</span><br>            <span class="hljs-keyword">int</span> runLen = countRunAndMakeAscending(a, lo, hi, c);<br><br>            <span class="hljs-comment">//如果有序个数小于上面的最小minRun的话,就找到</span><br>            <span class="hljs-keyword">if</span> (runLen &lt; minRun) &#123;<br>                <span class="hljs-keyword">int</span> force = nRemaining &lt;= minRun ? nRemaining : minRun;<br>                binarySort(a, lo, lo + force, lo + runLen, c);<br>                runLen = force;<br>            &#125;<br><br>            <span class="hljs-comment">// 将此run块放入run数组中.</span><br>            ts.pushRun(lo, runLen);<br>            <span class="hljs-comment">//这里之心合并操作.</span><br>            ts.mergeCollapse();<br><br>            <span class="hljs-comment">// Advance to find next run</span><br>            lo += runLen;<br>            nRemaining -= runLen;<br>        &#125; <span class="hljs-keyword">while</span> (nRemaining != <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// Merge all remaining runs to complete sort</span><br>        <span class="hljs-keyword">assert</span> lo == hi;<br>        ts.mergeForceCollapse();<br>        <span class="hljs-keyword">assert</span> ts.stackSize == <span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h2 id="minRunLength"><a href="#minRunLength" class="headerlink" title="minRunLength"></a>minRunLength</h2><p>就是获得一个最小的Run块的大小,大小在16-32之间.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minRunLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">assert</span> n &gt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;      <span class="hljs-comment">// Becomes 1 if any 1 bits are shifted off</span><br>    <span class="hljs-keyword">while</span> (n &gt;= MIN_MERGE) &#123;<br>        r |= (n &amp; <span class="hljs-number">1</span>);<br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n + r;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="countRunAndMakeAscending-a-lo-hi-c"><a href="#countRunAndMakeAscending-a-lo-hi-c" class="headerlink" title="countRunAndMakeAscending(a, lo, hi, c)"></a>countRunAndMakeAscending(a, lo, hi, c)</h2><p>找到a数组中从lo开始并且已经有序的元素个数,返回已经有序的元素个数.在这里如果逆序在翻转一下,变为有序.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countRunAndMakeAscending</span><span class="hljs-params">(T[] a, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi,<br>                                                    Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; c)</span> </span>&#123;<br>        <span class="hljs-keyword">assert</span> lo &lt; hi;<br>        <span class="hljs-keyword">int</span> runHi = lo + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (runHi == hi)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 找见a从lo开始已经有序的元素个数</span><br>        <span class="hljs-keyword">if</span> (c.compare(a[runHi++], a[lo]) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Descending</span><br>            <span class="hljs-keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="hljs-number">1</span>]) &lt; <span class="hljs-number">0</span>)<br>                runHi++;<br>            reverseRange(a, lo, runHi);<span class="hljs-comment">//如果是逆序则翻转</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;                              <span class="hljs-comment">// Ascending</span><br>            <span class="hljs-keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="hljs-number">1</span>]) &gt;= <span class="hljs-number">0</span>)<br>                runHi++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> runHi - lo;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h2 id="binarySort-T-a-int-lo-int-hi-int-start-Comparator-lt-super-T-gt-c"><a href="#binarySort-T-a-int-lo-int-hi-int-start-Comparator-lt-super-T-gt-c" class="headerlink" title="binarySort(T[] a, int lo, int hi, int start,Comparator&lt;? super T&gt; c)"></a>binarySort(T[] a, int lo, int hi, int start,Comparator&lt;? super T&gt; c)</h2><p>此方法就是二分排序,二分排序就是插入排序,但是在寻找向前面插入的位置是通过二分法来查找,然后在插入的.<br>此方法是在a数组中排序从lo到hi的元素,从start开始.</p><h2 id="private-void-mergeCollapse"><a href="#private-void-mergeCollapse" class="headerlink" title="private void mergeCollapse()"></a>private void mergeCollapse()</h2><p>这个方法主要是用来合并已经分好的几个Run块的.但是是有条件的;</p><ol><li>runLen[i - 3] &gt; runLen[i - 2] + runLen[i - 1]</li><li>runLen[i - 2] &gt; runLen[i - 1]<br>满足这两个条件才合并,否则什么都不做.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeCollapse</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//最少都得有两个块,如果没有,则退出.</span><br>        <span class="hljs-keyword">while</span> (stackSize &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">int</span> n = stackSize - <span class="hljs-number">2</span>;<span class="hljs-comment">// stackSize为块的数量,-2相当与倒数第二个块</span><br>            <span class="hljs-comment">//如果块的数量大于三个并且倒数第三个Run块大小小于后面两个块的大小和进入</span><br>            <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span> &amp;&amp; runLen[n-<span class="hljs-number">1</span>] &lt;= runLen[n] + runLen[n+<span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">//如果倒数第三个块比倒一块的大小小,就从倒数第三个块进行合并</span><br>                <span class="hljs-keyword">if</span> (runLen[n - <span class="hljs-number">1</span>] &lt; runLen[n + <span class="hljs-number">1</span>])<br>                    n--;<br>                mergeAt(n);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (runLen[n] &lt;= runLen[n + <span class="hljs-number">1</span>]) &#123;<span class="hljs-comment">//第一个块大小小于第二个块大小,就合并这两个</span><br>                mergeAt(n);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//否则什么都不做    </span><br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// Invariant is established</span><br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="private-void-mergeAt-int-i"><a href="#private-void-mergeAt-int-i" class="headerlink" title="private void mergeAt(int i)"></a>private void mergeAt(int i)</h2><p>再来看mergeAt(i)方法,这个方法主要就是合并在run块数组中从i开始的两个块.run[i]和run[i+1]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> base1 = runBase[i];<br><span class="hljs-keyword">int</span> len1 = runLen[i];<br><span class="hljs-keyword">int</span> base2 = runBase[i + <span class="hljs-number">1</span>];<br><span class="hljs-keyword">int</span> len2 = runLen[i + <span class="hljs-number">1</span>];<br>runLen[i] = len1 + len2;<br><span class="hljs-comment">//观察如果是倒数第三个块,就倒数第一个块赋值给倒数第二个块</span><br><span class="hljs-keyword">if</span> (i == stackSize - <span class="hljs-number">3</span>) &#123;<br>    runBase[i + <span class="hljs-number">1</span>] = runBase[i + <span class="hljs-number">2</span>];<br>    runLen[i + <span class="hljs-number">1</span>] = runLen[i + <span class="hljs-number">2</span>];<br>&#125;<br>stackSize--;<br><br><span class="hljs-comment">//计算run2的第一个元素能插入到run1的位置</span><br><span class="hljs-comment">//如果属于run1的最后一个位置,就不需要排序,因为run1中的所有元素都比run2中的小,直接返回,</span><br><span class="hljs-comment">//这样可以忽略掉run1中之前的位置</span><br><span class="hljs-keyword">int</span> k = gallopRight(a[base2], a, base1, len1, <span class="hljs-number">0</span>, c);<br><span class="hljs-keyword">assert</span> k &gt;= <span class="hljs-number">0</span>;<br>base1 += k;<br>len1 -= k;<br><span class="hljs-keyword">if</span> (len1 == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">//计算run1的最后一个元素在run2中插入的位置,进行去尾.</span><br>len2 = gallopLeft(a[base1 + len1 - <span class="hljs-number">1</span>], a, base2, len2, len2 - <span class="hljs-number">1</span>, c);<br><span class="hljs-keyword">assert</span> len2 &gt;= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (len2 == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">// 经过上面的“去头”和“去尾”之后，保证run1的开始元素一定大</span><br><span class="hljs-comment">// 于run2的开始元素，并且run1的最后一个数据一定大于run2的最后一个数据  </span><br><span class="hljs-comment">// 然后进行合并,通过两个len的大小找到最好的合并方式</span><br><span class="hljs-keyword">if</span> (len1 &lt;= len2)<br>    mergeLo(base1, len1, base2, len2);<br><span class="hljs-keyword">else</span><br>    mergeHi(base1, len1, base2, len2);<br></code></pre></td></tr></table></figure></p><h2 id="private-void-mergeLo-int-base1-int-len1-int-base2-int-len2"><a href="#private-void-mergeLo-int-base1-int-len1-int-base2-int-len2" class="headerlink" title="private void mergeLo(int base1, int len1, int base2, int len2)"></a>private void mergeLo(int base1, int len1, int base2, int len2)</h2><p>mergeLo方法 合并两个run块<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs java">    T[] a = <span class="hljs-keyword">this</span>.a; <span class="hljs-comment">//首先赋值到一个临时数组中</span><br>    T[] tmp = ensureCapacity(len1);<br>    <span class="hljs-keyword">int</span> cursor1 = tmpBase;<br>    <span class="hljs-keyword">int</span> cursor2 = base2;   <span class="hljs-comment">// Indexes int a</span><br>    <span class="hljs-keyword">int</span> dest = base1;      <span class="hljs-comment">// Indexes int a</span><br>    <span class="hljs-comment">//先吧a从base1开始的元素赋值到tmp从tmpbase开始的元素,赋值len1个元素,因为len1肯定是最小的元素</span><br>    System.arraycopy(a, base1, tmp, cursor1, len1);<br><br>    <span class="hljs-comment">// 首先肯定run2的第一个元素小于run1的第一个元素,因为上面都已经去头了</span><br>    a[dest++] = a[cursor2++];<br>    <span class="hljs-keyword">if</span> (--len2 == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果run2长度为0,则赋值tmp过去,</span><br>        System.arraycopy(tmp, cursor1, a, dest, len1);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (len1 == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//如果run1只剩下一个元素,所以只需要先把run2复制过去,再讲Run1的唯一元素赋值过去</span><br>        System.arraycopy(a, cursor2, a, dest, len2);<br>        a[dest + len2] = tmp[cursor1]; <span class="hljs-comment">// Last elt of run 1 to end of merge</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; c = <span class="hljs-keyword">this</span>.c;  <span class="hljs-comment">// Use local variable for performance</span><br>    <span class="hljs-keyword">int</span> minGallop = <span class="hljs-keyword">this</span>.minGallop;    <span class="hljs-comment">// 定义一个最小Gallop</span><br>outer: <span class="hljs-comment">//定义跳出什么循环</span><br><br>    <span class="hljs-comment">//在这里有一个思路就是合并两个run,但是会记录两个块中连续个数的数量,如果连续个数的数量大于minGallop也就是7,那就会进入Gallop模式.此模式就是通过"去头","去尾"来减少比较次数</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">int</span> count1 = <span class="hljs-number">0</span>; <span class="hljs-comment">// Number of times in a row that first run won</span><br>        <span class="hljs-keyword">int</span> count2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// Number of times in a row that second run won</span><br><br>        <span class="hljs-comment">/*<br>         * Do the straightforward thing until (if ever) one run starts<br>         * winning consistently.<br>         */</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">assert</span> len1 &gt; <span class="hljs-number">1</span> &amp;&amp; len2 &gt; <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//开始比较</span><br>            <span class="hljs-keyword">if</span> (c.compare(a[cursor2], tmp[cursor1]) &lt; <span class="hljs-number">0</span>) &#123;<br>                a[dest++] = a[cursor2++];<br>                count2++;<br>                count1 = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (--len2 == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span> outer;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                a[dest++] = tmp[cursor1++];<br>                count1++;<br>                count2 = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (--len1 == <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">break</span> outer;<br>            &#125;<br>            <span class="hljs-comment">//当有一个块有连续大于另一个块的次数超过minGallop的时候,进入gallop模式</span><br>        &#125; <span class="hljs-keyword">while</span> ((count1 | count2) &lt; minGallop);<br><br>        <span class="hljs-comment">/*<br>         * One run is winning so consistently that galloping may be a<br>         * huge win. So try that, and continue galloping until (if ever)<br>         * neither run appears to be winning consistently anymore.<br>         */</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">assert</span> len1 &gt; <span class="hljs-number">1</span> &amp;&amp; len2 &gt; <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//如上,去掉run1的头部</span><br>            count1 = gallopRight(a[cursor2], tmp, cursor1, len1, <span class="hljs-number">0</span>, c);<br>            <span class="hljs-keyword">if</span> (count1 != <span class="hljs-number">0</span>) &#123;<br>                System.arraycopy(tmp, cursor1, a, dest, count1);<br>                dest += count1;<br>                cursor1 += count1;<br>                len1 -= count1;<br>                <span class="hljs-keyword">if</span> (len1 &lt;= <span class="hljs-number">1</span>) <span class="hljs-comment">// len1 == 1 || len1 == 0</span><br>                    <span class="hljs-keyword">break</span> outer;<br>            &#125;<br>            a[dest++] = a[cursor2++];<br>            <span class="hljs-keyword">if</span> (--len2 == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span> outer;<br>            <span class="hljs-comment">// 去掉run2的尾部</span><br>            count2 = gallopLeft(tmp[cursor1], a, cursor2, len2, <span class="hljs-number">0</span>, c);<br>            <span class="hljs-keyword">if</span> (count2 != <span class="hljs-number">0</span>) &#123;<br>                System.arraycopy(a, cursor2, a, dest, count2);<br>                dest += count2;<br>                cursor2 += count2;<br>                len2 -= count2;<br>                <span class="hljs-keyword">if</span> (len2 == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span> outer;<br>            &#125;<br>            a[dest++] = tmp[cursor1++];<br>            <span class="hljs-keyword">if</span> (--len1 == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">break</span> outer;<br>            minGallop--;<br>            <span class="hljs-comment">//在此模式每多循环一次minGallop减少1</span><br>        &#125; <span class="hljs-keyword">while</span> (count1 &gt;= MIN_GALLOP | count2 &gt;= MIN_GALLOP);<br>        <span class="hljs-keyword">if</span> (minGallop &lt; <span class="hljs-number">0</span>)<br>            minGallop = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//在离开这个gallop模式后值增加2</span><br>        minGallop += <span class="hljs-number">2</span>;  <span class="hljs-comment">// Penalize for leaving gallop mode</span><br>    &#125;  <span class="hljs-comment">// End of "outer" loop</span><br>    <br>    <span class="hljs-keyword">this</span>.minGallop = minGallop &lt; <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : minGallop;  <span class="hljs-comment">// Write back to field</span><br>    <span class="hljs-keyword">if</span> (len1 == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">assert</span> len2 &gt; <span class="hljs-number">0</span>;<br>        System.arraycopy(a, cursor2, a, dest, len2);<br>        a[dest + len2] = tmp[cursor1]; <span class="hljs-comment">//  Last elt of run 1 to end of merge</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len1 == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<br>            <span class="hljs-string">"Comparison method violates its general contract!"</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">assert</span> len2 == <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">assert</span> len1 &gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//最后将tmp的值赋值到a中</span><br>        System.arraycopy(tmp, cursor1, a, dest, len1);<br>    &#125;<br></code></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql查询优化</title>
      <link href="/2019/04/03/mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
      <url>/2019/04/03/mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h2><h3 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h3><ul><li>查询不需要的记录</li><li>多表关联是返回全部列</li><li>总是取出全部列 ,尽量不要使用select *,去除全部列,可能会使优化器无法完成索引覆盖扫描这种优化.还会为服务器带来额外的IO,内存和cpu开销.</li><li>重复查询相同的数据.可以将经常用到的数据放在缓存里,避免重复查询数据库<h3 id="是否在扫描额外的数据"><a href="#是否在扫描额外的数据" class="headerlink" title="是否在扫描额外的数据"></a>是否在扫描额外的数据</h3>确定了查询的数据列后,还应该看看查询是否为了返回结果是否扫描了过多的数据.对于mysql,最简单的衡量开销指标有三个:<ul><li>响应时间 包括服务时间(就是查询时间)和排队时间(也就是等待锁或者等待其他I/O完成的时间)</li><li>扫描行数 </li><li>返回行数<br>对于查询最好的就是扫描行数/返回行数在1:1到10:1之间<br>可以尝试使用索引覆盖扫描,把所有需要的列放入索引中,这样存储引擎就可以不需要回表就可以返回列,或者重写查询.以更优的方式查询结果</li></ul></li></ul><h2 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h2><ul><li>考虑是用一个大的查询还是用很多个小的查询.因为在实际应用中,如果一个查询很大的话可能会导致锁住整个表,耗尽系统资源,阻塞后面的查询.因此有时候可以使用多个小的查询来返回结果,最后在把小的查询组合起来.</li><li>分解关联查询,因为每个数据库都有自己的缓存,如果分解大的查询可以更好的应用自己的缓存</li></ul><h2 id="mysql查询执行过程"><a href="#mysql查询执行过程" class="headerlink" title="mysql查询执行过程"></a>mysql查询执行过程</h2><ol><li>客户端向服务器发送一条消息(这是半双工的,意思是同一时间只有一方能够发送数据)</li><li>服务器先查询缓存,如果缓存命中,直接返回给客服,否则进入下一阶段</li><li>服务端进行sql解析,预处理,在根据优化器生成对应的查询计划</li><li>调用存储引擎API查询数据,</li><li>将结果返回给客户端.</li></ol><h2 id="mysql能处理的优化类型"><a href="#mysql能处理的优化类型" class="headerlink" title="mysql能处理的优化类型"></a>mysql能处理的优化类型</h2><ul><li>重新定义关联表的顺序</li><li>将外部连接转化程内部连接  </li><li>使用等价变换规则, 比如 5=5 and a&gt;5 换成 a&gt;5</li><li>优化count(),min(),max(),如果在索引列找最小值,直接搜索最左边的值</li><li>覆盖索引查询,如果索引的列包含所有要查询的列的时候就无须在回表查询</li><li>子查询优化   </li><li>提前终止查询: 比如使用limit语句的时候,发现语句够了,就会直接终止  </li><li>列表in的比较,在mysql中,会把在in中的数据进行排序,然后在根据二分查找来查询,明显提高了查找速度.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中断与中断处理</title>
      <link href="/2019/04/01/%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/"/>
      <url>/2019/04/01/%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断就是使硬件发出通知给处理器,比如在敲击键盘的时候,键盘控制器会发送一个中断,通知操作系统有键按下,让操作系统尽快处理<br>不同的设备对应的中断不同,每个中断都通过一个唯一的数字标志,使得操作系统能够对中断进行区分,继而提供不同的处理程序.这些中断值通常被成为中断请求(IRQ)线.每个IRQ先都会被关联一个数值量;例如在经典的PC机上,IRQ 0 是时钟中断.1是键盘中断.但是对于连接在PCi总线上的设备而言,中断是动态分配的.</p><h2 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h2><p>在操作系统中,在响应一个特定中断的时候,内核会执行一个函数,该函数叫做中断处理程序,产生中断的每个设备都有一个特定的中断处理程序.<br>对于操作系统而言,中断处理程序在尽可能短的时间内完成很重要;但是对于硬件而言,操作系统能迅速对其中断进行服务也非常重要.<br>所以中断程序首先要通知硬件设备中断已接受.还要运行中断函数处理.例如要把硬件网络接收到的数据拷贝到内存,但是现在网速特别块,所以之后的工作量会很大.因此将响应中断分为两部分.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">在操作系统中一般中断分为两部分.中断处理程序是上半部---接收到一个中断,它就立即开始执行,但是只做有严格实现的工作.例如对接收的中断进行应答或复位硬件.能够允许稍后完后才能的工作会推迟到下半部.<br></code></pre></td></tr></table></figure></p><p>linux的中断处理程序是无须重入的,但一个给定的中断处理程序正在执行,相应的中断线上的所有处理器上的都会被屏蔽掉.</p><h2 id="注册中断处理程序"><a href="#注册中断处理程序" class="headerlink" title="注册中断处理程序"></a>注册中断处理程序</h2><p>每个设备都有相关的驱动程序,如果硬件使用中断,应该注册一个中断处理程序.通过reques_irq()函数注册,并且激活给定的中断线,以处理中断.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">int request_irq(unsigned int irq,  表示要分配的中断号<br>                irq_handler_t handler, //handler是一个指针,指向处理这个中断的实际中断处理程序<br>                unsigned long flags, //标志位: IRQF_FISABLED 表示不响应其他中断;IRQF_TIMER为系统定时器的中断处理而准备的;IRQF_SHARED:表明在多个中断处理程序之间共享中断线.<br>                const char *name, // 是与中断相关的设备的ASCII文本表示<br>                void *dev) // 拥有共享中断线,dev讲提供唯一的标识信息.当删除中断处理程序需要释放时,能够知道删除哪一个.<br></code></pre></td></tr></table></figure></p><p>request_irq()成功会返回0,否则返回非0值.<br>这里request_irq函数可能会睡眠,因此不能在中断上下文或者其他不允许阻塞的代码中调用该函数.<br>中断线共享仅仅指的是中断号共享,并不是处理程序共享.</p><h2 id="共享的中断处理程序"><a href="#共享的中断处理程序" class="headerlink" title="共享的中断处理程序"></a>共享的中断处理程序</h2><p>对于共享中断线的设备,首先request_irq()的flag参数为IRQF_SHARED标志<br>对于dev参数必须唯一.指向任意设备结构的指针就可以满足这一要求;通常选择设备结构,因为它是唯一的.这里设备结构是你要想响应的设备结构.<br>中断处理程序必须能够区分它的设备是否真的产生了中断.这需要硬件的支持,也需要程序中有相关的处理逻辑.</p><h2 id="释放中断处理程序"><a href="#释放中断处理程序" class="headerlink" title="释放中断处理程序"></a>释放中断处理程序</h2><p>使用free_irq(unsigned int irq, void *dev);<br>如果中断线是共享的,则传入dev参数,删除此dev对应的处理程序,知道最后一个处理程序时才会被禁用此中断线;如果不是共享的,则在删除处理程序的同时禁用此中断线.  </p><h2 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h2><p>上面提到了中断上下文.其实在执行一个中断处理程序时,内核处于中断上下文中.<br>中断上下文和进程没有瓜葛,因为没有后备进程,所以中断上下文不可以睡眠.因此在中断上下文中不能调用睡眠的函数.<br>在中断上下文具有较为严格的时间限制,所有的中断处理程序必须尽可能的迅速,简洁.尽量把工作从中断处理程序中分离出来.放在下半部执行．<br>在每个处理中有一个中断处理栈，大小为１页. 在栈中处理中断程序.</p><h2 id="中断控制"><a href="#中断控制" class="headerlink" title="中断控制"></a>中断控制</h2><p>禁止指定中断线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">void disable_irq(unsigned int irq);//会等待当前处理程序完成后才返回<br>void diable_irq_nosync(unsigned int irq);//强制返回<br>void enable_irq(unsigned int irq);<br>void synchronized_irq(unsigned int irq);<br></code></pre></td></tr></table></figure></p><p>前两个函数禁止中断控制器上制定的中断线.synchronized_irq等待一个特定的中断处理程序的退出.<br>对于调用禁用函数可以嵌套,但是有一点就是调用多少次禁用中断线函数,就要调用多少次启动函数才能够重新激活.</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程调度</title>
      <link href="/2019/04/01/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
      <url>/2019/04/01/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><p>linux采用两种不同的优先级范围.<br>第一种用nice值,范围为-20到19,越低优先级越高.<br>第二种是实时优先级,从0-99,越大优先级越高.  </p><p>在系统调度中总会解决I/O密集型的和CPU密集型的进程的协调,I/O密集型要求有更好的响应性,而执行时间应该更少.CPU要求有更好的执行时间,而不是花费更多时间用来调度.</p><h2 id="调度器类"><a href="#调度器类" class="headerlink" title="调度器类"></a>调度器类</h2><p>linux调度器是以模块方式提供的,每个模块化结构成为调度器类,允许多种不同的可动态添加的调度算法并存.每个调度器都有一个优先级,会按照优先级顺序便利调度类,拥有一个可执行进程的最高优先级的调度器类胜出,选出下面要执行的一个程序.</p><h2 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h2><p>在linux中采用公平调度算法CFS,允许每个进程运行一段时间,循环轮转,选择运行最少的进程作为下一个运行进程,而不在采用分配给每个进程时间片.CFS在所有可运行进程总数基础上计算出一个进程应该运行多久.通过用nice值作为进程获得处理器运行比的权重,越低的优先级进程获得更低的处理器使用权重.在这里nice值并不是通过绝对值值来进行划分的,而是通过相对差值来分配权重的.避免了优先级差值不大的两个进程得到的处理器使用权重相差过大的情况.<br>在这里是由操作系统来确定进程应该使用多久,假设nice=0的进程分配时间片为100ms,则另一个nice=20的进程时间片为5ms.<br>如果按照绝对差值来分配时间片可能出现下列情况:<br>两个进程优先级分别为0和1,一个为100ms,则另一个为95ms,这时候基本没有问题.但是当两个优先级分别为18和19,那么一个为10ms,一个为5ms,这样前者比后者多出了一倍的处理器时间,是相对不合理的.</p><h2 id="linux调度的实现"><a href="#linux调度的实现" class="headerlink" title="linux调度的实现"></a>linux调度的实现</h2><h3 id="时间记账"><a href="#时间记账" class="headerlink" title="时间记账"></a><strong>时间记账</strong></h3><p>CFS不再有时间片概念,维护每个进程运行的时间的记账,保存在进程描述符中.<br>每个进程都有一个虚拟运行时间,该运行时间的计算是所有可运行进程总数的标准化(是被加权的).虚拟时间以ns为单位.CFS使用vruntime变量来记录一个程序到底运行了多长时间以及还应该在运行多久.<br>vruntime运行时间计算如下:</p><ul><li>首先的到当前进程的执行时间,然后在根据当前可运行进程总数对运行时间进行加权计算,在将权重值与当前进程的vruntime相加.</li><li>vruntime准确的测量给定进程的运行时间,而且可知道谁应该是下一个被运行的进程,因为他是根据运行时间最小的进程优先调度的.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">static const int prio_to_weight[40] = &#123;<br>/* -20 */     88761,     71755,     56483,     46273,     36291,<br>/* -15 */     29154,     23254,     18705,     14949,     11916,<br>/* -10 */      9548,      7620,      6100,      4904,      3906,<br>/*  -5 */      3121,      2501,      1991,      1586,      1277,<br>/*   0 */      1024,       820,       655,       526,       423,<br>/*   5 */       335,       272,       215,       172,       137,<br>/*  10 */       110,        87,        70,        56,        45,<br>/*  15 */        36,        29,        23,        18,        15,<br>&#125;;<br></code></pre></td></tr></table></figure><p>在linux中CPU nice值每下降1,则获得多10%的cpu时间,而这10%有一个相对的概念.就像上文所说的,如果用绝对的方式来说那么就会出现两倍的差距;<br>这里一张表表明了40个优先级的权重表示.比如有A,B两个进程nice都为0,那么每个的cpu占用时间都为1024/(1024+1024)=50%(这里1024代表上面0对应的权值),但是B要少出10的cpu时间的话,则将B的nice值加1,则应该有1024/(1024+B的权值) = 45%;算出来B的权值为837,与820相差不多,所以这里是按照相对值来计算获得的cpu时间的.<br><strong>以上参考博文 <a href="https://blog.csdn.net/u010173306/article/details/46743491" target="_blank" rel="noopener">https://blog.csdn.net/u010173306/article/details/46743491</a></strong></p><h3 id="进程选择"><a href="#进程选择" class="headerlink" title="进程选择"></a><strong>进程选择</strong></h3><p>主要选择具有最小vruntime的任务;通过使用红黑树来保存这些进程</p><h3 id="调度器入口"><a href="#调度器入口" class="headerlink" title="调度器入口"></a><strong>调度器入口</strong></h3><p>进程调度的时候首先是以调度器的优先级为顺序从高到低一次检查每个调度类,并且从最高优先级的调度类中选择最高优先级的进程.这样就找到最高优先级的进程,也就是vruntime最小的进程.</p><h3 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a><strong>睡眠和唤醒</strong></h3><p>内核操作: 首先标记自己为休眠状态,从可执行红黑树中移除,放入等待队列.在选择一个可执行进程.唤醒相反.<br>等待队列: 维护一个等待队列,当要休眠的时候放入到等待队列.编码是一个while(true)循环中等待,在被唤醒后在此检查条件是否为真,为真就会退出循环,将自己移除出等待队列,加入可执行红黑树中.<br>唤醒:唤醒操作通过函数wake_up()进行,唤醒指定的等待队列上的所有进程.</p><h2 id="抢占和上下文切换"><a href="#抢占和上下文切换" class="headerlink" title="抢占和上下文切换"></a>抢占和上下文切换</h2><p>内核中有一个参数为need_resched参数,表明是否需要重新执行一次调度,此过程称为抢占.</p><ul><li>用户抢占:　在系统调用返回用户控件或从中断处理程序返回用户空间是会发生用户抢占，当然need_resched参数要设置</li><li>内核抢占: 除了need_resched参数还有一个preempt_count参数,表明是否持有锁,在preempt_count为0的时候说明在执行任务持有锁,此次抢占是不安全的.知道当前新进程持有的所有锁都释放了,才会重新执行调度.</li></ul><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用在用户空间进程和硬件设备之间添加了一个中间层,作用有三个:</p><ol><li>首先为用户空间提供了一种硬件的抽象接口.这样应用程序不管磁盘类型和介质,不管文件系统是那种类型</li><li>第二 系统调用保证了系统的稳定和安全.作为硬件设备和应用程序之间的中间人可以基于权限,用户类型和其他规则对需要进行的访问进行裁决,避免引用程序不正当的使用硬件设备.</li><li>每个进程都运行在虚拟系统中,而在用户控件和系统的其余部分提供这样一层公共接口.在linux中系统调用是用户空间进入内核的唯一手段,除了异常和陷入外,他们是内核唯一的合法入口.</li></ol><p>在linux中,每个系统调用被赋予一个系统调用号. 这样就可以根据一个独一无二的号关联系统调用.进程不会提及系统调用的名称.如果一个系统调用删除,他所占用的系统调用号不允许被回收,否则以前编译过的代码调用此系统调用,但是事实上却调用另一个系统调用容易引发错误.如果一个系统调用被删除会用sys_ni_syscall()替换,此函数返回-ENOSYS.内核记录了系统调用表中的所有已注册过的系统调用的列表.存储在sys_call_table中. </p><h3 id="指定系统调用"><a href="#指定系统调用" class="headerlink" title="指定系统调用"></a><strong>指定系统调用</strong></h3><p>所有的系统调用陷入内核方式都一样,所以必须吧系统调用号一并创给内核.在x86上,系统调用号通过eax寄存器传递给内核.在陷入内核前,用户空间就把响应系统调用锁对应的号放入eax中.</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a><strong>参数传递</strong></h3><p>调用系统调用有时需要一些参数,最简单的办法是把参数也存放在寄存器里.在ebx ecx edx esi edi按照顺序存放前5个参数.应用用一个单独的寄存器存放指向所有这些参数在用户空间地址的指针.给用户空间的返回值也通过寄存器传递.</p><h3 id="调用参数限制"><a href="#调用参数限制" class="headerlink" title="调用参数限制"></a><strong>调用参数限制</strong></h3><p>在进行系统调用之前会先检查他们所有的参数是否合法有效.在接受用户空间的指针前,内核必须保证:</p><ul><li>指针指向的内存区域属于用户空间.进程决不能哄骗内核去读内核空间的数据.</li><li>指针指向的内核区域在进程的地址空间里.进程绝不能哄骗内核去读取其他进程的数据.</li><li>如果是读,该内存可以被读;如果是写操作,该内存应该可写;如果是可执行,必须被标记为可执行.进程局不能绕过内存访问限制.<br>如果调用成功返回0,否则返回标准-EFAULT<h3 id="绑定系统调用"><a href="#绑定系统调用" class="headerlink" title="绑定系统调用"></a><strong>绑定系统调用</strong></h3>在编写完一个系统调用后，要把它注册程一个正式的系统调用</li></ul><ol><li>首先在系统调用表的最后加入一个表项,从0开始算起</li><li>系统调用必须被编译进内核映像(不能被编译成模块)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux进程管理</title>
      <link href="/2019/03/31/linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2019/03/31/linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="linux进程管理"><a href="#linux进程管理" class="headerlink" title="linux进程管理"></a>linux进程管理</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><blockquote><p>进程就是处于执行期的程序.但不仅仅局限于一段可执行程序代码.通常还要包括其他资源,打开的文件,挂起的信号,内核内部数据,处理器状态,一个或多个具有内存映射的内存地址空间或多个执行线程.<br>在linux中线程是一种特殊的进程.是内核调度的对象.每个线程都拥有一个独立的程序计数器,进程栈,一组进程寄存器.<br>在操作系统中进程提供两种虚拟机机制:虚拟处理器和虚拟内存   </p></blockquote><h2 id="进程描述符及任务结构"><a href="#进程描述符及任务结构" class="headerlink" title="进程描述符及任务结构"></a>进程描述符及任务结构</h2><blockquote><p>内核把进程的列表存在叫任务队列的双向循环链表中.链表的每一项类型为task_struct称为进程描述符的机构.主要保存有:打开的文件,进程的地址空间,挂起的信号,进程的状态等.<br>每个进程都有自己的父进程,父进程可以管理其子进程.通过fork创建子进程.<br>在系统中有一个进程内核栈,动态生成task_struct只需要在栈上创建一个新结构thread_info,thread_info中包含了指向task_struct的指针.</p></blockquote><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在linux中线程创建和普通进程的创建类似,但是在调用clone()(也就是复制父进程的资源)的时候要传入参数指明要共享的资源.因为在linux中线程和普通的进程差不多,只是有共享资源.  </p><h2 id="进程终结"><a href="#进程终结" class="headerlink" title="进程终结"></a>进程终结</h2><p>原因: </p><ul><li>可能是自身引起,调用exit()系统调用.可能被其他进程终结.<br>过程:</li></ul><ol><li>讲tast_struct中标志成员设置为PF_EXITING.</li><li>调用deltimersync()删除任意内核定时器.根据返回结果,确保没有定时器在排队,也没有定时器处理程序在运行.</li><li>如果BSD(伯克利软件套件)进程记账功能开启,do_exit()调用函数输出记账信息.</li><li>调用exit_files和exit_fs(),分别递减文件描述符,文件系统数据的引用技术.如果每个引用技术为0,则可以释放</li><li>把退出代码保存下来,供父进程随时检索.</li><li>调用exit_notify()向父进程发送信号,给子进程重新找养父,养父为线程组的其他线程或者init进程,并吧线程状态设置为EXIT_ZOMBIE</li><li>切换新的进程</li></ol><blockquote><p>在每个进程结束之后都会保留一个退出信息,等待父进程调用结束后在被释放.(通过wait()函数).<br>如果父进程在子进程之前退出,就会在当前线程组内找一个线程作为父亲,如果不行就让init做他们的父进程.保证了每个进程死亡之后不会僵死,会有父进程回收此进程的退出代码信息</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/30/hello-world/"/>
      <url>/2019/03/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
