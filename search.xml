<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis持久化</title>
      <link href="/2019/08/03/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2019/08/03/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>Redis为键值对提供了持久化功能，并且有两种持久化方式，分别是 ，RDB和AOF方式</p><h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><p>在Redis中有两个命令可以生成RDB文件，SAVE和BGSAVE。</p><ul><li>SAVE命令会阻塞Redi服务器进程，直到RDB文件创建完毕为止，在服务器阻塞期间不能处理任何请求。</li><li>BGSAVE命令则不会阻塞Redis服务器进程，它会fork一个子进程来执行持久化操作，然后父进程继续处理请求命令。</li></ul><p>对于SAVE命令，会拒绝掉所有的其他服务器命令，包括SAVE，BGSAVE。 BGSAVE虽然不会阻塞Redis服务器进程，但是它也会拒绝掉过来的SAVE和BGSAVE命令，如果有AOFREWRITE命令的话，会等待BGSAVE执行完成后再执行AOF重写命令。</p><p>在Redis中，它允许用户通过设置服务器配置的save选项，让服务器每隔一段时间就自动执行一次BGSAVE命令，因为此命令不会阻塞服务器进程。 用于可以设置多个条件，只要其中一个满足就会执行BGSAVE命令。 举个例子 ：  假设有如下配置：</p><p>save 900 1<br>save 300 10<br>save 60  10000<br>那么只要满足一下三个条件之一，服务器就会执行BGSAVE命令。</p><ul><li>在900秒之内，对数据库进行了一次修改</li><li>在300秒之内，对数据库进行了至少10次修改</li><li>在60秒之内，对数据库进行了至少10000次修改</li></ul><p>在Redis中，会把这些保存条件保存到redisServer中的saveparams属性中，这是一个数组。如下图<br><img src="/2019/08/03/Redis持久化/saveparams.png" alt></p><p>并且，除了saveparams数组之外，服务器状态还维护了一个dirty计数器以及一个lastsave属性。</p><ul><li>dirty计数器保存着距离上一次成功执行save命令或bgsave命令之后，服务器对数据库状态进行了多少次修改</li><li>lastsave属性是一个时间戳，记录着上一次执行保存的时间。</li></ul><p>Redis中的周期性操作函数默认每隔100ms就会执行一次，该函数用来对正在运行的服务器进行维护，其中有一项就是检查save条件是否成立。 主要就是判断dirty和lastsave是否满足saveparams数组中的任意一对条件。如果满足任意一个条件，那么就执行BGSAVE操作，否则，就什么都不做。</p><h2 id="载入"><a href="#载入" class="headerlink" title="载入"></a>载入</h2><p>Redis没有载入命令，它会在服务器启动的时候检查是否有RDB文件，如果有则会自动载入。但是如果有AOF文件的时候，就不会载入RDB文件，则会载入AOF文键。</p><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><p>Redis还提供了AOF(append only file)持久化的功能。与RDB通过保存数据库的键值对数据不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。  </p><p>AOF持久化功能可以分为命令追加、文件写入、文件同步三个步骤。 当AOF持久化功能打开时，服务器每执行完一个写命令，会将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。<br>然后会根据用户对于AOF的配置来决定什么时候写入和同步到aof磁盘。 对于aof配置有三种选项</p><ul><li>always 将aof_buf所有内容写入并同步到aof文件</li><li>everysec 将aof_buf所有内容写入aof文件，如果上次同步时间到现在超过一秒，则进行同步到aof文件</li><li>no  将aof_buf所有内容写入到sof文件，不手动进行同步，何时同步由操作系统来决定。 </li></ul><p>这里写入和同步又是写入什么，又同步什么呢？  写入就是讲aof_buf缓冲区的内容全部都追加到aof文件中。 然后在将文件中的内容同步到系统磁盘上。 写入不是已经写进去了么，为什么还要同步呢？ 这啊，是因为现代操作系统是有一个磁盘缓冲区的，等到这个缓冲区都满了或者超过时间了，才会真正的将缓冲区的数据真正写入到磁盘中。虽然这样效率高，但是可能会丢失更新，所以说提供了一个函数强制将缓冲区刷新回磁盘。用来确保写入数据的安全性。</p><h2 id="载入-1"><a href="#载入-1" class="headerlink" title="载入"></a>载入</h2><p>AOF文件里包含了重建数据库所需的所有命令，所以服务器只需要读取aof所有的写命令并且执行一遍，就可以恢复到之前的状态了。具体流程<br><img src="/2019/08/03/Redis持久化/aofwirte.png" alt></p><h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>因为AOF通过保存写命令来记录数据库状态的。因此，AOF文件会越来越多，并且可能会有很多重复的。比如说对某一个键进行了大量的修改，那么AOF文件就会有大量关于此键的记录，会对恢复造成很大的负担。  因此，有了AOF重写功能。</p><p>AOF重写并不会对旧的AOF进行读取，它是通过读取当前服务器的数据来进行新的AOF进行写入的。也就是说，会用最少的语句来对AOF文件进行更新，新的AOF文件一定只保存有用的信息，不会出现很多条命令对一个键值对的写入和修改，大大减少了AOF文件的大小。 </p><p>并且在AOF重写的时候，定义了一个常量，避免客户端的缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这四种元素的时候，会先判断元素数量是否太大，如果他打则会分成多条命令来写入。而不单单是一条命令。目前，这个值设置为64. </p><p><strong>AOF</strong>是后台实现的，也就是说是创建一个子进程，在子进程中进行AOF重写的，但是这个时候如果有新的写命令该怎么办呢，在Redis中，如果在执行后台AOF重写的过程中，写命令不仅会把命令写入AOF缓冲区，还会将命令写入AOF重写缓冲区。这个重写缓冲区的内容将在AOF重写完成之后添加到AOF文件末尾。</p><p>当子进程执行重写完毕之后，会向父进程发送一个信号，表示重写完成，这个时候父进程会将AOF重写缓冲区的内容全部写入新的AOF文件中，并且对新的文件改名，原子的覆盖旧的AOF文件，完成AOF重写。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis对象</title>
      <link href="/2019/08/03/Redis%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/08/03/Redis%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>在Redis中，包含有5中对象，分别是字符串对象，列表对象，哈希对象，集合对象和有序集合对象。每种对象都对应于一种或多中数据结构。这些数据结构就是上一篇文章讲集中底层的数据结构。   </p><p>通过这五种不同类型的对象，Redis在执行命令前，会根据对象的类型来判断一个对象是否可以执行给定的命令。并且使用这些对象，可以针对不同的使用场景来为对象设置不同的底层数据结构，以提供更好的效率。 </p><p>此外，Redis的对象系统实现了基于引用计数的内存回收机制，当程序不在使用使用某个对象的时候，对象占用的内存会被自动释放掉，并且通过引用计数法实现了对象共享机制，就是让多个键共享一个对象来节约内存，例如Redis的字符串对象缓存了0-9999这么多个对象用来共享.</p><h2 id="对象的类型和编码"><a href="#对象的类型和编码" class="headerlink" title="对象的类型和编码"></a>对象的类型和编码</h2><p>Redis中使用一个叫RedisObject来表示的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//指向底层数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="comment">//引用计数</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="comment">//空转时长</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p><p>type 就是上面提到的5种类型之一，encoding则表示此对象所使用的编码方式，也就是该对象使用的底层数据结构是什么。 refcount是用引用计数实现内存回收机制，当计数为0的时候回释放掉对象。空转时长lru则保存上次访问此对象的unix时间戳。 </p><p>type 表示是什么对象</p><table><thead><tr><th style="text-align:center">类型常量</th><th style="text-align:center">对象名称</th><th style="text-align:center">实现方式</th></tr></thead><tbody><tr><td style="text-align:center">REDIS_STRING</td><td style="text-align:center">字符串对象</td><td style="text-align:center">int实现，embstr编码的SDS，普通SDS</td></tr><tr><td style="text-align:center">REDIS_HASH</td><td style="text-align:center">哈希对象</td><td style="text-align:center">压缩列表或字典</td></tr><tr><td style="text-align:center">REDIS_LIST</td><td style="text-align:center">列表对象</td><td style="text-align:center">压缩列表或双端链表</td></tr><tr><td style="text-align:center">REDIS_SET</td><td style="text-align:center">集合对象</td><td style="text-align:center">整数集合或字典</td></tr><tr><td style="text-align:center">REDIS_ZSET</td><td style="text-align:center">有序集合对象</td><td style="text-align:center">压缩列表或跳跃表</td></tr></tbody></table><p><img src="/2019/08/03/Redis对象/redis对象.png" alt></p><h1 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h1><p>对于字符串对象，redis中有三种编码方式，一种是int整数编码，一种是embstr编码的SDS实现，还有就是普通的SDS实现。 int整数实现很容易理解，但是embstr编码是什么呢。<br><img src="/2019/08/03/Redis对象/string_int.png" alt></p><p>embstr其实就是为了很短的字符串对象而存在的。这种编码方式和raw一样，都是使用redisObject结构和sdshdr结构来表示字符串对象，但是raw编码的字符串会调用两次内存分配函数来分别创建这两个对象。而embstr编码的只需要调用一次来申请一块连续的空间，空间中依次包含这两个结构。但是这个embstr的长度不能超过44.这个网上很多人都说embstr大小不能超过39，超过就会变成raw格式，但是我试了一下，并不是如此，在小于等于44的时候都是embstr类型。至于为什么，我认为首先redisObject大小为16字节，其次，在Redis中的内存分配器一次最多分配64字节的数据，这64字节的数据减去redisObject的16字节还有48字节，这48字节需要被sdshdr来分配，为了减少内存使用，在embstr编码下，free和len分别采用两个字节来表示，这个样子的话就是最大44字节。 当然了，这个是我认为的，有理解错误的地方请忽略。<br><img src="/2019/08/03/Redis对象/string_embstr.png" alt></p><p>而raw方式编码的字符串就是普通的SDS字符串了。<br><img src="/2019/08/03/Redis对象/string_raw.png" alt></p><h1 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h1><p>列表对象可以是压缩列表编码 或者是 双端链表编码类型。 压缩列表主要是用在数据量比较少并且数据都很小的地方。</p><p>如果满足以下两个条件，列表会使用压缩列表来实现。否则用双端链表。</p><ul><li>列表对象保存的所有字符串元素都小于64字节</li><li>列表中的元素个数小于512个</li></ul><p>ziplist类型的列表：</p><p><img src="/2019/08/03/Redis对象/list_ziplist.png" alt></p><p>linkedlist类型的列表:</p><p><img src="/2019/08/03/Redis对象/list_linkedlist.png" alt></p><h1 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h1><p>哈希对象的底层实现可以是ziplist编码或者hashtable编码。</p><h2 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h2><p>在使用压缩列表作为哈希对象的底层实现的时候，每当有键值对插入的时候，会首先把键插入到压缩列表表尾，然后在将值插入到压缩列表表尾。因此同一键值对的两个节点总是紧紧挨在一起，保存键的节点在前，保存值的节点在后。</p><p>ziplist类型的哈希对象</p><p><img src="/2019/08/03/Redis对象/hash_ziplist.png" alt></p><h2 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h2><p>如果是使用hashtable来作为哈希对象的底层实现的话，哈希对象每个键值对都是用一个字典键值对来保存：</p><ul><li>字典的每个键都是一个字符串对象，对象中保存了键值对的键</li><li>字典中每个值都是一个字符串对象，对象中保存了键值对的值。</li></ul><p><img src="/2019/08/03/Redis对象/hash_hashtable.png" alt></p><p>既然有两种实现，那么什么时候会使用压缩列表，又是什么时候使用hashtable呢。当哈希对象同时满足以下两个条件的时候使用ziplist编码</p><ul><li>哈希对象的所有键值对的键和值的字符串长度都小于64字节</li><li>哈希对象保存的键值对小于512个。</li></ul><p>如果不满足以上两个条件，会转换成hashtable来实现。</p><h1 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h1><p>集合对象的编码可以是intset或者hashtable。<br>intset编码的集合对象底层使用整数集合来实现。集合中的所有元素都被保存在整数集合中。<br>hashtable编码的集合对象使用字典来实现。字典的每个键是一个字符串对象，字符串就是一个集合元素。而字典的值全部被设置为NULL。   </p><p>intset编码的集合对象</p><p><img src="/2019/08/03/Redis对象/set_intset.png" alt></p><p>hashtable编码的集合对象</p><p><img src="/2019/08/03/Redis对象/set_hashtable.png" alt></p><h2 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h2><ul><li>所有的元素都是整数</li><li>集合中的元素小于512个。</li></ul><p>满足以上两种条件使用intset来实现。否则就会转换成hashtable编码。</p><h1 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h1><p>对象编码可以是ziplist或者skiplist  </p><p>使用ziplist的时候，每个元素使用两个紧挨在一起的节点来表示，第一个节点保存元素成员，第二个保存分值。  采用从小到大的排序方式，第一个元素最小，越往后越大。</p><p><img src="/2019/08/03/Redis对象/zset_ziplist1.png" alt></p><p><img src="/2019/08/03/Redis对象/zset_ziplist2.png" alt></p><p>使用skiplist编码的有序集合对象使用zset结构作为底层实现。一个zset结构同时包含一个字典和一个跳跃表。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span>&#123;</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    dict *dict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>zset结构中的zsl跳跃表按照分值从小到大保存了集合中的所有元素。每个跳跃表节点保存了一个结合元素。 除此之外，还使用了一个dict字典为有序集合创建了一个从成员到分值的映射。字典中的每个键值对都保存了一个集合元素：字典键保存了元素成员，值保存了元素成员的分值。通过这个字典可以使用O(1)时间就能找到给定成员的分值。    </p><p>这里要说明一点，虽然zset同时使用跳跃表和字典来保存有序集合元素，但是两种数据结构都通过指针来共享相同的元素成员，所以不会产生重复保存成员和分值一说，因此内存浪费也就不多了。只是多了一个维护hashtable的内存而已。</p><p><img src="/2019/08/03/Redis对象/zset.png" alt></p><h2 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h2><ul><li>有序集合保存的对象元素数量少于128个。</li><li>有序集合保存的所有元素成员的长度都笑64字节。</li></ul><p>满足以上两个条件的有序集合对象会使用ziplist编码，否则使用skiplist编码。</p><h1 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h1><p>Redis中的命令基本上可以分为两类，一类是可以对任意类型的键执行，比如del，expire命令等。一种是只能对特定的键执行，比如set，hdel，rpush等命令。如果在对应类型的对象上执行了不属于此对象的命令，则会报错。  </p><p>而这个类型检查命令就是根据redisObject结构的type属性来实现的。Redis会在执行一个特定类型的命令之前，会先检查数据库键对象的值对象是否为执行命令所需要的类型，如果是则执行命令，如果不是，会返回一个类型错误。这里检查是否是对应的类型其实就是检查redisObject结构中的type属性是否是对应的类型.  </p><p>上面说过，在Redis中有5种对象，redisObject使用type属性类保证对应类型有命令。但是每种类型的对象还有不止一种编码方式，在这里还必须要针对不同的编码方式使用不同的操作函数。在这里Redis就会根据底层的编码不同，也就是redisObject中的encoding不同来调用不同的函数来处理。</p><p>下图展示了对键key执行LPOP命令的完整过程<br><img src="/2019/08/03/Redis对象/lpop执行过程.png" alt></p><h1 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h1><p>因为c语言并不具备自动内存回收功能，并且在redis中有时候会出现两个指针指向同一个对象的情况，比如在zskiplist实现的有序集合中，skiplist与hashtable共享成员对象。 这个样子导致在删除操作的时候并不能直接释放掉相应键值对的内存。所以redis实现了基于引用计数计数实现的内存回收机制。通过这一个机制，程序会在适当的时候释放对象并进行内存回收。</p><p>这一实现是根据redisObject中的refcount属性来实现的。每新创建一个对象，refcount就被初始化1，当对象被一个新程序所引用的时候，引用数会加1，每当对象不再被新程序引用时候，会减1，当引用计数变为0的时候，对象所占用的内存会被释放。</p><h1 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h1><p>对象共享会极大的节约空间，Redis在初始化服务器的时候会创建10000个字符串对象：0-9999用来共享。</p><p>Redis只提供了数字类型的字符串对象的共享实现，因为比较数字的时间是O(1)，而其他如果要比较对象的话会很吃cpu和时间，因此不提供其他种类对象的共享。</p><h1 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h1><p>redisObject结构中有一个属性为lru属性，该属性记录了该对象最后一次被访问的时间。 这个属性主要用于内存回收。 在服务器打开了maxmemory选项，并且服务器用于回收内存的算法为lru算法时候，如果服务器内存超过了maxmemory所设置的上限值，那么就会回收掉空转时长比较高的那部分键值对。  这里又涉及到一个 内存淘汰机制。 因为内存是有限的，因此会为Redis所使用的内存做一个限制，以免内存爆炸系统假死。因此设置了最大内存之后，如果又有新来的数据怎么办，这就是内存淘汰机制了。 而这个内存淘汰机制就是通过这个lru来实现的。  就是通过随机选取N个Key ,然后随便找到这个N个key中空转时长最长的key，然后释放掉内存。然后在进行添加。</p><p>还有一种算法是LFU算法。 这个算法还会根据最近访问的频率来进行排序，就是如果访问时间距离现在比较长，但是特别频繁，也不会选择释放这个对象。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据库</title>
      <link href="/2019/08/03/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/08/03/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>Redis中的数据库是保存在一个redisServer结构中的db数组中的。db数组的每一项都是一个redisDb结构，每个结构代表着一个数据库。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 数组，保存着服务器中的所有数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    <span class="comment">// 服务器的数据库数量</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>dbnum属性的值未服务器 包含的数据库的数量，由服务器配置决定，默认为16个数据库。<br><img src="/2019/08/03/Redis数据库/db数组.png" alt></p><p>并且在服务器内部，客户端状态redisClient结构的db属性记录了当前客户端的目标数据库，这个属性是一个redisDb结构的指针，指向redisServer.db中的其中一个元素，而被指向的元素就是客户端的目标数据库。</p><p>每个数据库和其他数据库都是互不相干的。都存储着自己的数据，使用dict字典保存数据库中的所有键值对。称之为键空间。 这个键空间的键也就是数据库的键，每个键对象都是一个字符串对象。而值可以是5中基本对象类型之一。</p><p>比如下图：<br><img src="/2019/08/03/Redis数据库/数据库例子.png" alt></p><h1 id="过期键"><a href="#过期键" class="headerlink" title="过期键"></a>过期键</h1><p>Redis支持设置键的过期时间，使用expire命令来实现。 </p><p>在Redis中，过期键是保存在redisDb结构中的expires属性里的，expires也是一个字典。字典的键是指向设置有过期时间的键对象的指针，值是过期时间，用一个long long类型的整数表示–是一个毫秒精度的unix时间戳。  </p><p>看下面带有过期键的redis数据结构<br><img src="/2019/08/03/Redis数据库/过期键例子.png" alt></p><p>在这里，为了清楚，所以book对象和alphabet对象有两个表示，实际上在Redis中，键空间中的键和过期字典中的键都指向同一个键对象，所以不会浪费空间。</p><h1 id="过期键删除"><a href="#过期键删除" class="headerlink" title="过期键删除"></a>过期键删除</h1><p>对于过期键删除策略：</p><ul><li>定时删除： 在设置键的过期时间的同时，创建一个定时器，让定时器在过期时间来临的时候，立即执行删除操作</li><li>惰性删除： 放任过期键不管，但是每次从键空间获取键的时候，都检查取得的键是否过期，如果过期的话就删除该键，否则返回。</li><li>定期删除： 每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键，至于删除多少键以及检查多少数据库，由算法来决定。</li></ul><p>对于这三种情况来说，</p><ul><li>定时删除是对内存友好的，因为只要时间一到，过期键就会被删除，然后释放过期键占用的内存。但是这样的话会对cpu造成很大的负担，比如在cpu时间非常紧张的情况下，又有大量的过期键，这个时候用大量的时间来删除过期键显然不是一个明智的选择。 并且，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式—-无序链表，查找一个事件的时间复杂度为O(N),并不能高效的处理大量时间事件。 所以这种情况不好</li><li>惰性删除是对CPU友好的，以为程序只会在取出键的时候才对键进行过期检查，这可以保证删除过期键的操作只在非做不可的情况下才会删除。 但是这也会导致浪费内存，因为只有再取出键的时候才会删除键，因此，当有大量的过期数据并且不再需要访问了，那么就会堆积在数据库，对数据库造成一定的影响。 比如说日志，在某个时间点之后就没有用了。</li><li>定期删除 ： 上面来看，定时删除和惰性删除都是有一定的缺陷的，而定期删除是这两种方式的一种中和。这种策略是每隔一段时间进行一次数据库的过期键删除操作，并通过限制操作执行的时长和频率来减少删除操作对CPU时间的影响。 对于定期删除，要把握好删除操作的执行时长和执行频率，否则会退化成为定是删除或者惰性删除。</li></ul><h2 id="Redis中删除策略的实现"><a href="#Redis中删除策略的实现" class="headerlink" title="Redis中删除策略的实现"></a>Redis中删除策略的实现</h2><p>在Redis中，使用惰性删除和定期删除两种方式来实现过期键删除的。<br>首先，Redis会在每次读写之前首先检查键是否过期，如果过期就删除，否则执行相应操作。<br><img src="/2019/08/03/Redis数据库/删除过期键.png" alt></p><p>其次，Redis定义一个时间事件，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。    </p><p>Redis会在每次执行时间事件的时候，从一定数量的数据库中随机选取一部分键进行检查，并且删除其中的过期键。 用一个current_db来保存当前遍历到那一个数据库了。以便下一次从这里开始执行。</p><h2 id="RDB持久化对过期键的处理"><a href="#RDB持久化对过期键的处理" class="headerlink" title="RDB持久化对过期键的处理"></a>RDB持久化对过期键的处理</h2><p>在服务器对RDB文件载入的过程中：</p><ul><li>如果是主服务器，那么在载入RDB文件的时候回对键进行检查，未过期的键会被加载到数据库中，过期键会被忽略。</li><li>如果是从服务器，那么服务器会载入RDB文件中的所有键，而不会管是不是过期了。 因为在之后的主从同步的时候从服务器的数据库也会被清空，所以说，过期键对载入RDB文件的从服务器不影响。</li></ul><h2 id="AOF持久化对过期键的处理"><a href="#AOF持久化对过期键的处理" class="headerlink" title="AOF持久化对过期键的处理"></a>AOF持久化对过期键的处理</h2><p>和RDB类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。</p><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>在复制模式下，从服务器的过期键删除由主服务器控制</p><ul><li>主服务器在删除一个键之后，会显示的向所有服务器发送一个del命令，告知从服务器删除这个过期键。</li><li>从服务器在执行客户端发送的命令，即使碰到过期键也不管，直接向客户端返回数据。 只有收到来自主服务器发来的del命令才会删除过期键。</li></ul><p>这样子做主要是为了保证主服务器和从服务器的数据一致性。</p><blockquote><p>但是我觉得这样可能会有bug，本来应该过期的数据，我到从服务器竟然取到了，可能又bug。不好。在此我认为，应该让从服务器碰到过期键向主服务器发送一条消息。告知主服务器应该删掉这个过期键。</p></blockquote><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>Redis是一对多服务器程序，一个服务器可以与多个客户端建立连接，并且每个客户端都可以发送命令请求向服务器。  服务器通过使用I/O多路复用计数来实现文件事件处理器。 并且Redis服务器使用单线程单进程的方式来处理命令请求。</p><p>在Redis服务器中，为每个连接过来的客户端保存一个称为redisClient结构的客户端状态，这个结构保存了当前客户端的状态，以及执行相关功能时需要用到的数据结构。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="built_in">list</span> *clients；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Redis服务器中，用一个双向链表来保存所有已连接的客户端信息。如下图所示：<br><img src="/2019/08/03/Redis数据库/redisClient结构.png" alt></p><p>下面来看一下redisClient结构中都有哪些属性 ：</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">变量名</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">int</td><td style="text-align:center">fd</td><td style="text-align:center">描述客户端正在使用的套接字。整形，如果为-1，表示为伪客户端，来源于AOF恢复或LUA脚本。</td></tr><tr><td style="text-align:center">robj *</td><td style="text-align:center">name</td><td style="text-align:center">名字，默认每个客户端是没有名字的，可以设置</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">flag</td><td style="text-align:center">记录客户端处于什么角色或者说正处于什么状态</td></tr><tr><td style="text-align:center">sds</td><td style="text-align:center">querybuf</td><td style="text-align:center">输入缓冲区，客户端发来的请求命令将保存到这里</td></tr><tr><td style="text-align:center">robj **</td><td style="text-align:center">argv</td><td style="text-align:center">一个数组，保存着从输入缓冲区分析出来的请求命令的参数。 命令名称也算一个参数</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">argc</td><td style="text-align:center">整数，表示有多少个参数</td></tr><tr><td style="text-align:center">struct redisCommand *</td><td style="text-align:center">cmd</td><td style="text-align:center">命令的实现函数，在解析完命令之后，会找到命令所对应的执行函数的redisCommand结构，然后将cmd指向此结构</td></tr><tr><td style="text-align:center">char*</td><td style="text-align:center">buf</td><td style="text-align:center">固定长度的输出缓冲区，用来实现一些简短的命令回复， 默认大小16KB</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">bufpos</td><td style="text-align:center">记录了buf中已使用的字节数量</td></tr><tr><td style="text-align:center">list*</td><td style="text-align:center">reply</td><td style="text-align:center">变长的输出缓冲区，当输出太大或者溢出固定的输出缓冲区，输出缓冲区会转变为一个链表结构</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">authenticated</td><td style="text-align:center">用于记录客户端是否通过了身份验证，1为通过，0 为没通过</td></tr><tr><td style="text-align:center">time_t</td><td style="text-align:center">ctime</td><td style="text-align:center">记录创建客户端的时间，用来计算客户端与服务器连接了多少秒</td></tr><tr><td style="text-align:center">time_t</td><td style="text-align:center">lastinteraction</td><td style="text-align:center">记录客户端与服务器最后一次互动的时间</td></tr><tr><td style="text-align:center">time_t</td><td style="text-align:center">obuf_soft_limit_reached_time</td><td style="text-align:center">记录输出缓冲区第一次达到软性内存限制的时间</td></tr></tbody></table><p><strong>创建与关闭</strong><br>创建的时机就是在客户端连接服务器的时候，服务器会为客户端创建一个redisClient结构，并且存放在服务器的redisClient链表中。</p><p><strong>关闭</strong></p><ul><li>客户端退出</li><li>客户端发送的命令请求不符合协议格式</li><li>客户端是Client Kill命令的目标</li><li>设置了timeout选项，并且客户端的空转时长超过了timeout选项</li><li>客户端发送的命令请求的大小超过了输入缓冲区的限制大小（1GB）</li><li>要发送给客户端的命令恢复大小超过了输出缓冲区大小</li></ul><h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><p>服务器在接受到客户端的命令之后，首先会解析协议，放到客户端状态的argv属性中，之后通过argv[0]参数，在命令表中查找参数所指定的命令。并将找到的命令保存到客户端状态的cmd属性里。<br>命令表其实是一个字典，键是一个个的命令名字，值是一个redisCommand结构，每个redisCommand结构记录一个redis命令的实现信息。如下图 ：</p><table><thead><tr><th style="text-align:center">属性名</th><th style="text-align:center">类型</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">name</td><td style="text-align:center">char *</td><td style="text-align:center">命令名字 ,如 “set”</td></tr><tr><td style="text-align:center">proc</td><td style="text-align:center">redisCommandProc *</td><td style="text-align:center">函数指针,执行命令的实现函数</td></tr><tr><td style="text-align:center">arity</td><td style="text-align:center">int</td><td style="text-align:center">命令参数的个数,用于检查命令请求的格式是否正确,如果值未-N,则表示数量大于等于N ,并且,命令名称也算一个参数</td></tr><tr><td style="text-align:center">sflags</td><td style="text-align:center">char *</td><td style="text-align:center">字符串形式的标示值,这个值记录命令的属性,比如此命令是一个写命令还是只读等等</td></tr><tr><td style="text-align:center">flags</td><td style="text-align:center">int</td><td style="text-align:center">对sflags标识进行分析的出的二进制标识,由程序自动生成</td></tr><tr><td style="text-align:center">calls</td><td style="text-align:center">long long</td><td style="text-align:center">服务器总共执行了多少次此命令</td></tr><tr><td style="text-align:center">milliseconds</td><td style="text-align:center">long long</td><td style="text-align:center">服务器执行这个命令所消耗的时间</td></tr></tbody></table><p>当有了执行命令的参数之后,服务器会在一次事件循环中,执行这个命令.执行命令的过程如下:</p><ol><li>进行执行命令前检查,比如客户端状态的cmd指针是否指向NULL,参数个数是否正确,是否通过了身份验证等等</li><li>通过cmd指针调用命令实现函数</li><li>执行后续工作,比如进行AOF持久化,添加慢查询日志,将此命令传给从服务器等等.</li><li>将命令产生的回复发送给客户端</li></ol><h2 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h2><p>Redis服务器中有一个serverCron函数,默认100毫秒执行一次,这个函数负责管理服务器资源,并保存服务器自身的良好运转. 下面来列一下serverCron函数都做了什么</p><ul><li>更新服务器时间缓存, Redis会缓存系统当前时间,因为获取系统当前时间会调用系统调用,为了减少系统调用次数,</li><li>服务器状态中的unixtime属性和mstime属性被用作时间缓存, Redis会每100毫秒更新一次这两个属性. 当然,这两个不精确的时间只会用在打印日志,更新服务器的LRU时钟,计算服务器上线时间等对时间精确度要求不高的功能上.</li><li>更新LRU时钟. 服务器状态保存了一个lrulock的值,用来计算某个对象的空转时长. 前面知道每个对象也是有一个lru属性,计算对象的空转时长就是用这个lru时钟减去对象的lru属性获得.并且,LRU时钟默认是每10秒更新一次,因此,计算出来的空转时长是一个大概的估计值</li><li>更新服务器每秒执行命令次数</li><li>更新服务器内存峰值记录,每次serverCron函数执行时候都会检查目前服务器的内存大小,和服务器状态中的内存峰值比较,如果比记录大,则替换掉</li><li>处理SIGTERM信号,这个信号就是将服务器的关闭状态设置为1. 在serverCron函数中会判断是否为1,如果为1,关闭数据库</li><li>管理客户端资源, 在这个函数中,会对一定的客户端数量进行检查,检查与客户端的连接是否超时,缓冲区是否耗费了过多内存等等.如果有,则释放掉连接</li><li>管理数据库资源.  对数据库中的一部分键值对进行检查,删除掉其中的过期键</li><li>检查持久化操作的运行状态,用两个字段来表示是否有子进程在进行持久化,如果有,则判断子进程是否发来完成信号,如果发来,则替换掉旧的持久化文件.如果没有,则什么都不做. 如果没有子进程在进行持久化,则判断是否满足持久化的条件,如果满足,则进行持久化.</li><li>将AOF缓冲区的内容写入AOF文件</li><li>增加cronloops的次数，cronloops记录了serverCron执行的次数</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis集群与哨兵</title>
      <link href="/2019/08/03/Redis%E9%9B%86%E7%BE%A4%E4%B8%8ESentinel/"/>
      <url>/2019/08/03/Redis%E9%9B%86%E7%BE%A4%E4%B8%8ESentinel/</url>
      
        <content type="html"><![CDATA[<h1 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h1><p>Sentinel（哨兵）是Redis的高可用的一个解决方案。有一个或多个Sentinel实例组成的Sentinel系统。用来监视任意多个主服务器和从服务器。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>使用Sentinel的时候，会启动Sentinel用来监视主服务器或者从服务器，应该在Sentinel配置文件中配置要监视的主服务器，之后Sentinel会从和主服务器之间的信息交换中获得主服务器的从服务器的信息。   </p><p>每个Sentinel都又一个SentinelState结构来表示，通过这个结构来保存所有此Sentinel用到的数据。<br>此Sentinel会保存所有监视的主服务器的信息（从配置文件知道监视哪些主服务器），用sentinelRedisInstance结构来表示，并且还会保存所有监视的主服务器的所有从服务器的信息（从和主服务器的交流看出），保存在对应主服务器sentinelRedisInstance结构的slave属性中，也是一个sentinelRedisInstance结构。除此之外， Sentinel还会保存其他监视此主服务器的Sentinel的结构信息（从订阅的<strong>Sentinel</strong>:hello频道得到)。</p><p>Sentinel服务器会向自己监视的所有主从服务器发起两个连接，一个是命令连接，一个是订阅连接。  命令连接用来和被监视服务器进行通信，比如服务器以每10秒一次通过命令向从服务器发送INFO命令，并获得此服务器的主服务器和复制偏移量等等。另一个是订阅连接，Sentinel会通过订阅连接向监视的服务器发送一条命令： SUBSCRIBE <strong>sentinel</strong>:hello。这里就是订阅服务器的这个频道，之后就可以通过这个频道发布的消息来获取其他同样监视此服务器的信息。</p><p>Sentinel服务器每两秒一次频率向所有被监视的主从服务器发送一条消息，<br>PUBLISH <strong>sentinel</strong>:hello “&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;”<br>保存了Sentinel本身的一些信息和正在监视的主服务器的信息。这条命令向服务器的<strong>sentinel</strong>:hello频道发送了一条消息，所有订阅了此频道的服务器都将收到消息。 而Sentinel发现其他对主服务器的监视者也是通过订阅主服务器的此频道来发现的。通过这条信息，能够及时发现其他同样在监视此主服务器的Sentinel。然后更新自己的记录。</p><h2 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h2><p>Sentinel会以每秒一次的频率向所有与它创建了命令连接的服务器（包括主从和Sentinel）发送PING命令，通过返回来判断是否在线。<br>在Sentinel服务器的配置文件中，有一个这样的配置： sentinel down-after-milliseconds master 50000. 这样的配置就是说，在50000毫秒内服务器都向Sentinel返回了无效回复或者没有回复，那么此Sentinel将会判断此服务器为主观下线状态。<strong>注意</strong> 这个配置不仅对主服务器有效，对从服务器同样有效。 并且每个Sentinel的配置可能不一样， 因此可能会出现一个Sentinel判断服务器为主观下线，另一个判断为没有主观下线。 因此判断完之后还会在判断是否客观下线。</p><h2 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h2><p>当一个Sentinel判断一个主服务器主观下线了。则会向其他监视此主服务器的Sentinel进行询问，用来判断此服务器是否是真的下线了。当收到同意下线的个数超过在配置的数量的时候。 配置在配置文件中 ： sentinel monitor master 127.0.0.1 6379 5 .表明收到5个Sentinel都同意主服务器下线的回复后，那么会设置主服务器为客观下线状态。  （注意因为么个Sentinel的配置不同，所以每个Sentinel判断客观下线的条件也不同)</p><h2 id="选举领头Sentinel"><a href="#选举领头Sentinel" class="headerlink" title="选举领头Sentinel"></a>选举领头Sentinel</h2><p>选举过程比较简单， 首先每个Sentinel都会有一个运行ID和当前纪元。然后在每个纪元内，每个发现主服务器进入客观下线状态的Sentinel都会要求其他Sentinel将自己选择为头领。并且每个Sentinel都有一此投票机会。 至于这个票投给谁，采用的是先到先得的方式，谁先给我发消息让我投它，我就投谁，投完票之后所有的请求都将被拒绝。  当有一个Sentinel的票数大于所有Sentinel数量的一半，则说明这个Sentinel为头领 。</p><p>每个Sentinel都有一个自己的超时时间，如果在给定时间内没有一个Sentinel票数超过一半，那么就将所有的配置纪元加一，开始新一轮的投票，直到选出领头Sentinel。并且Redis在实现的时候对于每个Sentinel在每个纪元的等待超时时间是随机产生的，就是说每个Sentinel在这一轮如果没有选举出结果的话,会等待一个随机1-2秒内的时间,之后在发送,这样保证了能够尽量有第一个Sentinel被选举出来,加快了选举的速度.这样的话就尽可能的第一个Sentinel被选举出来。那样就能够保证在短时间内出现一个票数超过一般的Sentinel。</p><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>选出领头Sentinel之后，会将已下线的主服务器执行故障转移操作</p><ul><li>在已下线的主服务器的从服务器中挑选一个服务器作为主服务器</li><li>让其他从服务器复制新的主服务器</li><li>让已下线的主服务器设置为新的主服务器的从服务器</li></ul><p>选择从服务器的规则： 首先根据从服务器优先级，其次是 复制偏移量，最后是运行ID。</p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>集群就是Redis提供的分布式数据库方案， 集群通过分片的方式来进行数据共享，并提供复制和故障转移功能。</p><h1 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h1><p>首先，一个集群肯定要包含很多节点。这些节点是怎么连接到一起的呢。 是通过CLUSTER MEET 命令来进行与其他节点握手，握手完成之后，这个两个节点就会处于同一集群了。之后其他节点在与集群中的任意一个节点握手，那么这个节点也就加入到这个集群中去了。</p><h2 id="ClusterNode"><a href="#ClusterNode" class="headerlink" title="ClusterNode"></a>ClusterNode</h2><p>每个集群中的节点都用一个clusterNode结构来表示。 每个节点都会为自己建立一个clusterNode节点，并且为集群中的其他节点也创建一个clusterNode结构。以此来记录其他节点的状态。   </p><p>clusterNode有一个clusterState结构，用来记录当前节点的视角下集群的状态。 比如集群是上线还是下线，集群包含有多少个节点，集群当前的纪元配置等等信息。 并且还保存了所有的集群节点名单。 用一个字典表示，键是节点名称，值是表示该节点的clusterNode结构。</p><h1 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h1><p>Redis集群通过分片的方式来保存数据库中的键值对：集群中的整个数据库被分为16384个槽，数据库中的每个键都是属于这16384个槽的其中一个，集群中的节点可以处理0个或16384个槽。</p><p>当着16384个槽都有节点在处理的时候，那么整个集群属于上线状态，否则，集群处于下线状态。 可以使用cluster addslots 命令来添加节点要处理的槽。</p><p>每个节点的clusterNode会记录每个槽被分配给了谁，并且还会记录自己负责处理那些槽。<br>使用一个二进制位数组来表示自己处理那些槽。 unsigned char slots[16384/8]. 如果该二进制位为1，表示节点处理此槽，否则不处理。 </p><p>并且在clusterState结构中还存储了一个槽的指派信息，表明了每个此槽被指派给那个节点。  用一个clusterNode数组表示。<br>每个数组项都是一个指向clusterNode的指针，如果指向NULL，则表示此槽没有被分配给任何节点，否则表示此槽被分派给了此clusterNode代表的节点。   </p><h2 id="传播"><a href="#传播" class="headerlink" title="传播"></a>传播</h2><p>每个节点会将自己的slots数组发送给其他节点。 这个slots数组包含在发送的消息头中，每个发送的消息都会包含此slots信息。  每当节点收到别人发来的slots数组之后，就会更新对应节点的clusterNode的信息。  </p><p>这里发现Redis中在两处都记录了槽的指派信息， 一个是在clusterNode的slots数组中，另一个是在clusterState的slots数组中。 但是两个里面的数据是不一样的。 clusterNode的slots数组是二进制位数组。 用char[]类型表示。只用来表示自己处理那些槽，并且如果要告诉其他节点自己处理那些槽，那么就会发送自己clusterNode的solts二进制数组。 这个时间是O（1）。当客户端发来指令，要知道指令是属于哪个槽的，那么就需要去寻找clusterState的slots数组，找到对应的节点然后进行处理。</p><h2 id="cluster-addslots命令实现"><a href="#cluster-addslots命令实现" class="headerlink" title="cluster addslots命令实现"></a>cluster addslots命令实现</h2><p>首先查找所有输入的slot是否已经被指派了，如果已经被指派了，那么就会返回错误。</p><h1 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h1><p>先来看一张图<br><img src="/2019/08/03/Redis集群与Sentinel/handle命令.png" alt></p><p>首先会根据键计算键属于哪个槽。是通过计算key的CRC-16检验和的出来的。之后会去检查clusterNode的slots数组的第i项是否为1，如果为1，则说明自己负责此槽，那么就会处理客户端的命令。 否则，去看clusterState中的slots数组的第i项，然后向客户端发出moved错误，指引客户端转向正在处理槽的节点。</p><h1 id="节点数据库"><a href="#节点数据库" class="headerlink" title="节点数据库"></a>节点数据库</h1><p>每个节点都会保存所有自己处理的槽的所有键值对，并且这些键值对也是用字典来实现， 与普通的单机数据库不一样的是只能使用-号数据库。 并且会使用一个跳跃表来保存槽和键的映射关系。跳跃表的每个节点的分值是槽号，每个节点的成员则是一个数据库键。当向数据库中添加一个键的时候，节点就会将这个键以及对应的槽号关联起来 。 这样就能得到对应槽都包含有那些键值对。 主要是用在集群的重新分片上。</p><h1 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h1><p>Redis可以将任意数量已经指派给某个节点的槽改为指派给另一个节点。  </p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="/2019/08/03/Redis集群与Sentinel/slot迁移0.png" alt></p><p>在更改槽指派的时候会使用redis-trib负责执行的。</p><ul><li>让目标节点准备好导入源节点中属于槽slot的键值对</li><li>之后向源节点发数据，让源节点准备好将槽slot的键值对发送到目标节点</li><li>向源节点发送执行获取count个属于槽slot的键值对的键名。并且对于这些获取到的键名发送给源节点，将被选中的键值对都迁移到目标节点。 重复此步骤，直到迁移完成</li><li>最后向集群中的任意节点发送集群设置槽命令，将槽slot指派给目标节点。这一指派信息会通过消息发送至整个集群。最终所有的节点都会知道。</li></ul><p>每个节点都有两个数组来保存当前节点正在从其他节点导入的槽和正在导入其他节点的槽<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    clusterNode * importing_slots_from[<span class="number">16384</span>]；</span><br><span class="line">    clusterNode * migrating_slots_to[<span class="number">16384</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ASK错误"><a href="#ASK错误" class="headerlink" title="ASK错误"></a>ASK错误</h2><p>在重新分片期间，可能会出现刚好槽的数据被迁移到了目标节点的情况，那么这个时候，节点首先判断自己是否有此键，如果没有，则回去检查自己的migrating_slots_to数组中，此槽是不是在迁移，如果是，则向客户端返回ASK错误，引导客户端去正确的节点去查找Key。</p><p>ASK错误是指这一次命令需要去指定的节点执行，下一次客户端还是会去之前的节点请求。<br>MOVED错误是指这个命令已经被移动到了指定的节点。客户端下一次回去请求新的节点。</p><h1 id="复制和故障转移"><a href="#复制和故障转移" class="headerlink" title="复制和故障转移"></a>复制和故障转移</h1><p>每个集群中的节点都可以拥有从节点。通过设置clusterState.myself.flags中的属性，打开REDIS_NODE_SLAVE标识。表示这个节点是一个从节点。然后开始向此从节点的主节点复制数据。</p><p>并且集群中的所有节点都会在对应主节点的clusterNode结构中的slaves属性和numslaves属性中记录正在复制这个主节点的从节点名单.</p><p>集群中的每个节点都会定期的向集群中的其他节点发送PING命令,以此来检测对方是否在线. 当发送了PING命令之后,节点没有给到有效回复,则将这个节点标记为疑似下线. 节点之间通过互发消息来共享消息. 如果一个节点A收到了节点B对节点C的疑似下线消息,那么会将这个报告记录下来,当有半数一上的节点认为一个节点疑似下线了.那么就会发送一条消息,标记此节点已经下线了. 这个时候就会选举一个此节点下的从节点来作为主节点.   </p><p>这个选举方式和Sentinel很像. 每个主节点都有一票.当从节点收到自己的主节点下线之后,会向所有的主节点发送消息.要求所有收到此消息的节点给这个从节点投票,所以这个也是先来先得票. 直到有某一个从节点的票数超过半数,那么就会当选为主节点 . 之后新的主节点撤销掉对已下线主节点的槽指派,并将这些槽全部指派给自己. 在向集群中广播一条消息，让其他节点知道自己已经是主节点了。</p><h1 id="复制操作"><a href="#复制操作" class="headerlink" title="复制操作"></a>复制操作</h1><h2 id="旧版"><a href="#旧版" class="headerlink" title="旧版"></a>旧版</h2><p>旧版复制的实现只能实现全量复制， 从服务器向主服务器发送同步消息，然后主服务器在后台生成RDB文件，并且用一个缓冲区缓存从现在开始执行的所有写命令，生成文件之后，再给从服务器发送过去，从服务器接收到文件会将自己数据库状态更新到主服务器执行BGSAVE命令时的状态。 之后主服务器将自己缓冲区里的命令发送给从服务器。</p><h2 id="新版"><a href="#新版" class="headerlink" title="新版"></a>新版</h2><h3 id="旧版的缺点"><a href="#旧版的缺点" class="headerlink" title="旧版的缺点"></a>旧版的缺点</h3><p>如果从服务器是第一次复制还好，因为必须要全量复制所有的键。 但是如果从服务器状态和主服务器是一致的， 但是中间掉线了， 那么这个时候主服务器可能只是执行了一条写命令。 之后从服务器连上来之后，就需要重新从主服务器中获取所有的键，极大的浪费了资源。  这个时候新版的复制功能就出现了。   </p><p>实现方法：<br>新版的主从复制命令为PSYNC，此命令有完整重同步和部分重同步两种模式</p><p>完整重同步用来处理初次复制的情况， 部分重同步用于处理断线后重连的情况。</p><p>PSYNC命令主要是用复制偏移量和复制积压缓冲区 和服务器的运行ID来实现的。</p><h3 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h3><p>主服务器和从服务器都会维护一个复制偏移量</p><ul><li>主服务器每发送N个字节的数据，就会将自己的复制偏移量加N</li><li>从服务器每接受N个字节的数据，就将自己的复制偏移量加N</li></ul><h3 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h3><p>复制积压缓冲区是在主服务器上的，是一个固定长度先进先出的队列，默认大小为1MB。<br>在主服务器执行完命令之后，不仅会将命令转发给所有的从服务器，还会将命令写入复制积压缓冲区，因此，复制积压缓冲区保存着最近执行的命令。并且会为每个字节都记录相应的偏移量</p><p>当从服务器重新连上主服务器之后，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，这个时候主服务器根据offset和自己复制积压缓冲区中保存的偏移量进行对比，如果还保存有offset+1的字节，则执行部分重同步，否则执行完整重同步。</p><h3 id="运行ID"><a href="#运行ID" class="headerlink" title="运行ID"></a>运行ID</h3><p>运行ID 就是主服务器用来判断之前这个从服务器是否是复制自己的。  这个运行ID是在从服务器第一次复制主服务器的时候主服务器发过去的。</p><h2 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h2><p>从服务器每秒一次向主服务器发送命令REPLCONF ACK 复制偏移量 。 主要用来检测主从连接状态和命令丢失</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构</title>
      <link href="/2019/08/03/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2019/08/03/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h1><p>在redis中，自己实现了一套字符串数据结构，使用一个sdshdr来表示一个字符串：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="comment">// 用来记录buf数组中已使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">// 用来保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/08/03/Redis数据结构/SDS.jpeg" alt></p><p>至于redis为什么要这么设计，首先是有三个好处： </p><ol><li>结构体中记录了字符串的长度，可以在O（1）时间内获取长度。如果只使用char数组来保存，得需要O（n)的时间</li><li>结构体内有free类型，减少了因为修改字符串所带来的内存重分配次数。</li><li>二进制安全。</li></ol><blockquote><p>为什么说减少了修改字符串所带来的内存重分配次数呢，因为有一个free类型在，并且当需要扩展字符串长度的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间。这样在下一次再次扩容的时候，可能就不需要再次重新分配了，因为上次分配的已经够了。</p></blockquote><p>那么在redis中，每次扩容要分配多少额外空间呢？ 这个其实是有一个算法的。下面来看一下这个算法</p><ul><li>如果对SDS进行修改之后，SDS的长度（也就是len属性的值）小于1MB，那么程序就会分配和len一样大小的未使用空间</li><li>如果修改之后大于1MB，那么会分配1MB大小的未使用空间。</li></ul><p>到这里可能会有疑问了，字符串增长的话会分配额外空间，那字符串len减少会是怎么样呢。 </p><p>在redis中，采用了<strong>惰性释放策略</strong>，也就是当我们的len从20减少到10之后，这个时候SDS的大小是不变的，也就是不释放那些空闲的空间，这个样子的话，如果之后字符串增长的话也许就不需要重新分配了，减少内存重新分配的次数。 但是可能又有人会问了，这个样子就会很浪费空间啊，如果之前一个10M的字符串变为了1b，那么就有将近10M的空间被浪费掉了，其实，在redis中还有对应的api函数来释放掉SDS的未使用空间。所以也不需要担心了。</p><p><strong>SDS是二进制安全的</strong>，<br>说到二进制安全可能有些人不明白，但是一说肯定就知道了，在c字符串中，所有的字符必须符合一定的编码规则，并且除了在字符串的末尾外，字符串里不能包含空字符。否则最先被程序读入程序的空字符将会被误认为是字符串结尾。 所以c风格字符串限定了不能存储2进制数据，比如图片等。但是，SDS是二进制安全的，因为他会将所有的数据都当成是二进制数据来处理，并且在SDS中是通过len属性来判断是否数据读完，所以也就不会有中间插入的空白字符影响读取了。</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>redis的链表和普通的双向链表节点一样：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在redis 中使用list来表示链表<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">// 链表包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于这里保存节点使用的是void*，所以链表中可以存储任意类型的值。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>双向链表，获取头结点和尾节点的时间复杂度尾O（n)</li><li>无环，表头结点的prev和尾节点的next都指向null</li><li>带有链表长度，获取长度为O(1)</li><li>多态，使用void *来保存值</li></ul><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表，在redis中的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">// 哈希表掩码大小，总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure></p><p>这里的table是一个数组，数组中的每个元素都是一个指向dictEntry结构的指针，每个dictEntry结构保存着一个键值对。 size属性记录哈希表的大小，used则记录键值对的数量。<br><img src="/2019/08/03/Redis数据结构/hashtable.png" alt></p><p>上图就是一个大小为4的空哈希表。   </p><h2 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h2><p>哈希表节点使用dictEntry结构表示，每个dictEntry结构保存着一个键值对<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125;v;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure></p><p>从这个Entry就能看出来，这里的哈希表是通过链地址法来解决hash冲突的。他有一个next指针。</p><h2 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h2><p>Redis中的字典定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">//私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash索引</span></span><br><span class="line">    <span class="comment">// 在rehash没有进行时候为-1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>这个里面的dictType主要就是包含了一系列用于操作对应类型键值对的函数。Redis会为用途不同的字典设置不同的类型特性函数。<ul><li>privdata这是保存了需要传给那些类型特定函数的可选参数。 这两个字段主要是为了实现多态的，根据不同的类型设置不同的操作函数。</li><li>ht属性包含两个项的数组，每个项都是一个dictht哈希表，一般只会用ht[0]，ht[1]是在rehash的时候才会用到的。</li><li>rehash 保存了rehash目前的进度，如果没有在rehash，则为-1；</li></ul></li></ul><p><img src="/2019/08/03/Redis数据结构/普通状态下的字典.png" alt="普通状态下的字典"></p><h2 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h2><p>上面也看到了，hash表中的节点都是dictEntry节点，每个dictEntry节点都有一个next指针，因此，Redis使用的是链地址法来解决冲突，但是由于dictEntry中没有指向链表尾部的指针，并且这里是使用的头插法。(这个并没有关系，因为链地址法的话每次插入必须遍历链上的每一个节点，不然可能出现一条链上出现两个相同的对象。因此头插和尾插时间都必须是O(n)) 。 但是可能就是 最近使用的数据会更多的使用，这样插入到头部，然后获取效率会很高。</p><h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>对于hash表来说，当数据量越来越多，为了保证负载因子维持在一个合理的范围，当哈希表保存的键值对数量太多或者太少时候，程序需要对哈希表的大小进行相应的扩展和收缩。 对于hash表的扩容来说，每次扩容大小为之前大小的二倍。</p><p>扩展和收缩一般是通过rehash来操作完成的。Redis对字典执行rehash采用了渐进式hash来进行，也就是说整个rehash并不是一次性就完成的。而是分多次，一次一次进行。下面来看一下具体的rehash的步骤。</p><ol><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个hash表。</li><li>在字典中维持一个索引计数器变量，rehashidx，将它设置为0，表示rehash正式开始。</li><li>在rehash期间，每次对字典执行添加、删除、查找或更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表上在rehashidx索引上的所有键值对都rehash到ht[1]上，在这个索引上的节点都被rehash到ht[1]上了的话，就将rehashidx自增1.</li><li>随着对字典操作的不断进行，在某个时刻，ht[0]哈希表上的所有键值对都被移动到了ht[1]上，这个时候将rehashidx赋值为-1，到此rehash操作完成。</li></ol><p>这里渐进式rehash的好处就是采取分而治之的方式，将rehash键值对所需要的计算工作摊到对字典的每个添加、删除、查找和更新<br>上。从而避免了集中式rehash带来的一时的程序不能运作。</p><h2 id="扩容期间进行的操作"><a href="#扩容期间进行的操作" class="headerlink" title="扩容期间进行的操作"></a>扩容期间进行的操作</h2><p>在扩容期间因为有两个表存在，所以操作会和平时显得不一样。</p><ul><li>查找，查找首先会在ht[0]进行查找，如果找到了，则返回，如果没有找到，会再去ht[1]里面找</li><li>插入，首先会先执行查找，如果找到了就会返回错误。没有找到会直接插入到ht[1]表中</li><li>删除，也是会先查找，查找的步骤和上面一样，找到了就删除。没找到则说明不存在。</li></ul><p>要注意一下： 在rehash期间，对于键值对的添加删除和更新查找操作和平时是不一样的。比如查找的话会同时在两个表中查询。现在ht[0]中查找，如果没找到再到ht[1]中去查找。</p><h2 id="hash表扩展和收缩的情况"><a href="#hash表扩展和收缩的情况" class="headerlink" title="hash表扩展和收缩的情况"></a>hash表扩展和收缩的情况</h2><p>先来看一下会发生扩展的情况：</p><ul><li>服务器没有在执行BGSAVE和BGREWRITEAOF命令，并且哈希表的负载因子大于等于1</li><li>服务器在执行这两个命令但是哈希表负载因子大于5</li></ul><p>收缩：</p><ul><li>当哈希表的负载因子小于0.1的时候，程序会对哈希表进行收缩操作。</li></ul><h1 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h1><p>跳跃表这里的实现和普通跳跃表类似，没有太多可以说的， 不懂可以去看看跳跃表数据结构。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>跳跃表主要是由zskiplistNode和zskiplist两个结构来定义的。zskiplistNode用来表示跳跃表节点。而zskiplist则用于保存跳跃表的相关信息，比如节点的数量、头结点或者尾节点。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">    <span class="comment">//头结点，尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>,*<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">//节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">//表中层数最大的节点的层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span></span><br><span class="line">        <span class="comment">//前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">//跨度，表示这一层的下一个节点跨过了多少个节点</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">    <span class="comment">//后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">//分值，按分值类排序</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">//成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure></p><p>整个结构如下图：<br><img src="/2019/08/03/Redis数据结构/skiplist.png" alt><br>最左边的结构是ziplist结构，包含有头尾节点的指针和节点数量。 右边几个都是zskiplistNode结构的节点。 节点包含一个表示层的数组和后退指针还有指向成员对象的指针。 通过分层能够很好的访问之后的很多个元素，达到快速找到节点的功能。</p><p>具体的跳跃表的原理参见百度。</p><p>跳跃表节点每一层的前进指针都只指向下一个具有此层的节点。</p><h2 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h2><p>跳跃表在redis一般用来表示整数集合和集群节点用作内部数据结构，其他地方是没有用到的。</p><h1 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h1><p>整数集合是集合键的底层实现之一，就是在Redis中会有一些优化，当一个集合只包含有整数值元素，并且这个元素不多，Redis会使用整数集合来作为底层的集合数据结构。下面来对整数集合做一下讲解。</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>整数集合可以保存int16_t、int32_t、int64_t的数值，并且保证集合中不会出现重复元素。整数集合用一个intset结构来表示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// 集合中包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure></p><ul><li>contents是整数集合的底层实现，就是用数组实现的。整数集合的数据是按照值得大小从小到大排列的，并且不包含任何重复项。虽然说，contents类型是int8_t类型的，但是contents并不保存int8_t类型的数据，而是根据encoding类型来保存不同类型的数据。比如如果encoding是int16_t类型，那么contents就保存int16_t类型的数据。</li><li>length 是整数集合包含的元素数量</li><li>encoding 也就是说的编码方式，有三种，分别是16位，32位和64位的整数集合。</li></ul><p>通过这个encoding类型，能够极大的减少内存的浪费，如果说整数集合都是存储的很小的整数，那么就可以int16_t来保存数据，减少内存浪费，但是这个时候又有一个问题出现了，就是如果这个时候来一个int32_t大小的数据该怎么办呢，Redis肯定有他的解决办法，这个办法就是升级操作。</p><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>每次添加一个新元素到整数集合里面，并且新元素的类型比整数集合现在的类型长度要长，那么就会先对这个整数集合进行升级，然后再将新元素添加到整数集合中。 下面看一下升级步骤：</p><ol><li>根据新元素的类型，扩展整数集合底层数组大小，并且为新元素分配空间</li><li>将底层数据现有的元素全部都转换成与新元素相同的类型，并且将类型转换后的元素放到对应的位置，并且保证元素的有序性</li><li>将新元素添加到底层数组中。</li></ol><p>Redis只支持升级操作而不支持降级操作，降级操作需要遍历所有的元素看是否能降级，得不偿失。所以就不支持降级操作。</p><p><strong>注意</strong> 整数集合的扩容大小为之前的length+1，所以每次插入都会重新分配空间扩容。 而对于<strong>删除</strong>操作来说，首先找见要删除的元素，然后将之后的元素向前移动，之后再释放掉多余的空间。</p><p>所以在整数集合中，每次插入或者删除元素都是要进行空间的重新分配的。</p><h1 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h1><p>压缩列表是列表键和哈希键的底层实现之一，当一个列表键只包含少量的列表项，并且每个列表项要么是小整数值，要么就是长度比较短的字符串，这个时候Redis就会使用压缩列表来实现列表键。 又或者一个哈希键的键值对都是小整数或者较短的字符串，也会使用压缩列表来实现。</p><h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><p>压缩列表主要是为了节约内存而开发的。是由一系列特殊编码的连续内存块组成的顺序性数据结构， 一个压缩列表包含任意多个节点（entry），每个节点保存一个字节数组或者一个整数值。<br>如下图所示：<br><img src="/2019/08/03/Redis数据结构/压缩列表.png" alt></p><table><thead><tr><th>属性</th><th>类型</th><th>长度</th><th>用途</th></tr></thead><tbody><tr><td>zlbytes</td><td>uint32_t</td><td>4字节</td><td>记录整个压缩列表的长度，在对压缩列表进行内存重分配或者计算zlend的位置时候使用</td></tr><tr><td>zltail</td><td>uint32_t</td><td>4字节</td><td>记录压缩列表表尾节点距离列表初始地址有多少字节</td></tr><tr><td>zllen</td><td>uint16_t</td><td>2字节</td><td>记录了压缩列表包含的节点数量，当这个值小于65535时候，这个值就是压缩列表的节点数量，等于65535时候，需要遍历列表才能得到所有节点数量</td></tr><tr><td>entryX</td><td>列表节点</td><td>不定</td><td>压缩列表包含的各个节点，节点的长度由节点保存的长度决定</td></tr><tr><td>zlend</td><td>uint8_t</td><td>1字节</td><td>特殊值0xFF（十进制255），用于标记压缩列表的末端</td></tr></tbody></table><h2 id="压缩列表的节点"><a href="#压缩列表的节点" class="headerlink" title="压缩列表的节点"></a>压缩列表的节点</h2><p>每个压缩列表节点都可以保存一个字节数组或者一个整数值，对于字节数组来说可以是一下三种长度的一种</p><ul><li>长度小于等于64字节</li><li>长度小于等于16383字节</li><li>长度小于2的32次方-1字节的字节数组</li></ul><p>整数值可以是各种长度，4位长，1字节长，3字节长，16位，32位，64位的。</p><p>每个压缩列表的节点都是由privious_entry_length、encoding、content三个部分组成</p><ul><li>privious_entry_length 这个字段记录了压缩列表的前一个节点的长度，它的长度可以是1字节或者5字节，如果前一节点的长度小于254字节，那么privious_entry_length的长度为1字节，保存着上一个节点的长度； 如果前一节点的长度大于等于254字节，那么privious_entry_length的长度为5字节，第一个字节设置为0xFE（254），之后四个字节保存前一个节点的长度。<ul><li>由于这个属性保存了上一个节点的长度，所以我们可以通过这个字段计算出上一个字段的起始地址，这样就能够实现从表尾遍历了。</li></ul></li><li><p>encoding  属性记录了节点的content属性保存的数据的类型以及长度。分一下几种情况</p><ul><li>1字节，两字节，五字节长，值得最高两位为00、01或10的是字节数组编码，这种编码表示节点的content属性保存的是字节数组，并且除去最高两位其余的表示字节数组的长度</li><li>1字节，值最高两位以11开头的是整数编码：这种编码表示节点的content属性，保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他记录。</li></ul></li><li><p>content属性则是存储真正值得地方。根据encoding类型，存储不同的类型值。</p></li></ul><p>从它的结构来看，就可以看出来，压缩列表是很节省空间的，尽可能的不浪费空间，要存多少东西就分配多少。不够了再动态扩张。这也是它叫压缩列表的原因。 </p><blockquote><p>但是在极端情况下，压缩列表可能会出现一个连锁更新的问题。比如说，现在在压缩列表中的节点大小都为250到253字节大小，但是这个时候向压缩列表头部插入一个259字节的数据，那么之后的第一个节点的privious_entry_length会变成5字节，导致节点大小超过254字节，接着就得更新下一个节点的privious_entry_length值，知道最后，引发了连锁更新。删除也可能会出现这种情况。但是这种情况一般很少见，其实是可以忽略的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java wait,join,notify解析</title>
      <link href="/2019/06/22/Java-wait-join-notify%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/06/22/Java-wait-join-notify%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h1><p>wait()方法只能在对象上调用,比如 obj.wait(),表明将当前线程阻塞,直到有其他线程调用此对象的notify()或notifyAll()方法.线程才会继续执行. 或者有其他线程中断了此线程,将会抛出一个中断异常.</p><h1 id="wait-long-timeout"><a href="#wait-long-timeout" class="headerlink" title="wait(long timeout)"></a>wait(long timeout)</h1><p>和wait()方法类似,但是此等待是有超时限制的,当等待的时间到了,也会自动被唤醒</p><h1 id="wait-long-timeout-int-nanos"><a href="#wait-long-timeout-int-nanos" class="headerlink" title="wait(long timeout,int nanos)"></a>wait(long timeout,int nanos)</h1><p>此方法就有点意思了,看名字好像等待超时时间的控制精确到了纳秒级别,但是看看源码就了解到了,事实并不是如此.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到,如果nanos大于0,则直接将timeout++,也就是说如果有设置纳秒参数,则再加1毫秒.所以,等待超时只能精确到毫秒级别</p><h1 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h1><p>notify就很简单了,就是随机唤醒一个在此对象上等待的线程.</p><h1 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll()"></a>notifyAll()</h1><p>All就是所有,就是唤醒在此对象上等待的线程</p><h1 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h1><p>他是thread的静态方法,对当前线程有效<br>yield()方法,此方法就是让出cpu的执行权,意思就是我不干了,你们谁有事谁就干吧.让出执行权,让其他线程去干活.<br>但是这个让出指的是让所有的线程重新争夺cpu的执行权,包括自己,所以,还是有可能继续轮到自己干的.</p><h1 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h1><p>join方法是在Thread类中的方法,调用join方法就是等待此线程执行完成,之后再执行.比如下面代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    Thread thread1= <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 省略代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里调用thread1.join()方法,就会将当前线程阻塞,知道thread1()完成返回之后才会继续执行   </p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB实例恢复</title>
      <link href="/2019/06/09/InnoDB%E5%AE%9E%E4%BE%8B%E6%81%A2%E5%A4%8D/"/>
      <url>/2019/06/09/InnoDB%E5%AE%9E%E4%BE%8B%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="InnoDB实例恢复"><a href="#InnoDB实例恢复" class="headerlink" title="InnoDB实例恢复"></a>InnoDB实例恢复</h1><p>在InnoDB引擎中,存在redo log用来做数据的恢复操作. 但是了解了redo log的原理之后发现,redo log中日志并不只是在事务提交的时候才会写入磁盘,而是在事务的进行中就可能已经写入磁盘了,并且一个redo log中的一个log块可能包含多个事务redo log. 当时当一个事务做了一系列事情之后,还未提交,但是数据库宕机了,并且redo log中某些操作已经写回了磁盘,这个时候把数据库恢复到之前的状态,将会有存在某些未提交的数据.<br>主要是redo log中不仅保存数据修改的日志,还会保存undo log日志信息.在数据库启动的时候,会首先使用redo log中的数据将数据库恢复到宕机之前的状态,之后在通过undo log来回滚数据库宕机的时候为提交的数据.这样就保证了数据库事务隔离性和一致性.</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> InnoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB事务的实现</title>
      <link href="/2019/06/09/InnoDB%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/06/09/InnoDB%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>数据库的事务有四大特性，即：原子性，隔离性，一致性和持久性．要保证这四个特性，InnoDB存储引擎做了一系列的操作,下面来看一下InnoDB是怎么保证数据库事务的这四个特性的.</p><h1 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h1><p><strong>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</strong></p><p>隔离性就很好说了,在InnoDB中,如果想要访问某一行记录的话,首先需要获取到它的锁,之后才能继续访问.通过锁,就能很好的实现了事务的隔离性. InnoDB默认的访问级别是Read Repeatable级别,避免了脏读,不可重复读等特性,并且在行锁的基础上又加上了gap Lock(间隙锁)来解决幻读的问题.InnoDB锁可以参见我之前的文章<a href="https://1fishman.github.io/2019/06/08/InnoDB存储引擎之锁的实现/" target="_blank" rel="noopener">InnoDB存储引擎之锁的实现</a></p><p>虽然锁可以很好的解决数据库事务的隔离性问题,但是性能也得到了一定的瓶颈,就是读写冲突.InnoDB又实现了MVCC机制(多版本并发控制).主要是通过每个行记录后面保存两个隐藏的列来实现的.两个列保存了行的创建时间和过期时间(或删除时间). 这里的事件就是事务的Id,每个事务都有一个Id,Id是自增的. 下面来看一下主要是如何操作的:</p><ul><li>select 会查找行记录的创建时间早于当前事务Id的行,或者说删除时间那一列Id大于自己的Id的行记录</li><li>insert 插入一条新的数据,并保存当前事务Id作为记录的创建时间.</li><li>delete 为删除的每一行保存当前事务Id为行删除标识</li><li>update 插入一条新的记录,并且把当前事务Id保存到新的行记录中,并设置旧的行记录的删除标识为此事务Id.</li></ul><p>MVCC只在Repeatable Read和Read Commited两个隔离级别下工作,其他情况下都不兼容.因为Read UnCommited总是读取最新的行,而Serializable总是会对所有读取的行都加锁.</p><h1 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h1><p><strong>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态.</strong></p><p>了解了隔离性,一致性也就好说了,每个事务都是相互隔离的,那么最终,数据肯定也是一致性的.因为每个事务都互相不影响,并且事务具备原子性,那么一致性也就是自然而然了.</p><h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><p><strong>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚.</strong>    </p><p>原子性的实现就需要用到undo日志了.<br>undo日志到底是个什么呢.undo就是重做,主要记录了事务的行为,可以很好的通过其对页进行”重做”,如果数据库事务发生了错误需要进行回滚,就会使用undo日志将数据库回滚到修改之前的样子.    </p><p>undo日志通过存储数据库修改的逻辑日志来回复数据库.比如,在进行回滚的时候,对于insert,InnoDB会完成一个delete操作;对于delete,InnoDB执行一个insert;对于update,InnoDB执行一个相反的update,来将修改前的行放回去.  </p><p>undo日志的另一个而作用是MVCC,就是在InnoDB存储引擎中MVCC的实现是通过undo来完成的.当用户读取一条记录的时候,若该记录已经被其他事务占用,当前事务可以通过undo读取之前的行版本信息,通过此来实现非锁定读取.</p><h1 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h1><p><strong>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作</strong> </p><p>InnoDB作为事务引擎,数据都是存储在磁盘上的,由于磁盘太慢,InnoDB引擎提供了缓存(Buffer Pool)实现,Buffer Pool中包含了磁盘中部分页的映射.在访问数据的时候会先去缓存池中访问,如果没有,就把数据页读取到缓冲池中.在写入数据的时候,也是会先写入Buffer Pool,并且Buffer Pool中的数据页会定时的刷新到磁盘上. 这样做虽然效率变高了,但是当某一时刻数据库忽然宕机,而此时Buffer Pool中的数据还没来得及刷新回磁盘,那么就会导致数据的丢失. </p><p>为了保证就算遇到故障的时候数据库系统也不会出现数据丢失的情况,redo日志就出现了.redo日志保存了对数据库的修改.<strong>并且,redo日志是物理格式的,即记录的是对于每个页的修改,而不是具体的sql语句.并且redo日志是预写式日志,也就是说,所有的修改会先写入redo日志中,再更新到Buffer Pool</strong>.</p><p>通过这个redo文件的写入,就能够保证数据库的持久性了.如果数据库在某一时刻宕机了,当数据库重启的时候就会通过redo文件来进行数据恢复操作. </p><p>当然了,如果redo日志是直接向磁盘进行写入的话,不免操作也会变慢很多,因此InnoDB也引入了redo log buffer,redo日志是会先写入redo log buffer中,之后再在一定的条件下刷新会磁盘.</p><ul><li>Master Thread每秒执行一次刷新操作,刷新回磁盘</li><li>每个事务提交的时候,会刷新回磁盘</li><li>当缓冲区的可用空间少于一半的时候,重做日志被刷新会磁盘.</li></ul><p>到这里就有人要问了,为什么把redo日志写入磁盘就会比把真正的数据写入磁盘快呢,这是因为</p><ul><li>刷新脏页的IO是随机IO,因为每次修改的数据位置随机,但是redo是顺序IO,是顺序写入的.因此会快一点</li><li>刷新脏页是以数据页为单位的,mysql默认大小是16k,在页上的每一次小的改动都要将整个页写入磁盘,而redo log只是写入真正写入的数据,无效IO大大减少.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> InnoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB存储引擎之锁的实现</title>
      <link href="/2019/06/08/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/06/08/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="InnoDB锁"><a href="#InnoDB锁" class="headerlink" title="InnoDB锁"></a>InnoDB锁</h1><p>在一般的数据库中为了保证数据库事务的四个特性,不可避免的要使用到锁.而InnoDB为我们提供了一个很好的行级锁,即锁定的是数据行,而不是整张表.,当然了,在某些情况下也会直接锁表,而不是行锁.下面来探讨一下InnoDB的行级锁.</p><h1 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h1><p>InnoDB存储引擎为我们提供了两种标准的行级锁.</p><ul><li>共享锁(S Lock),允许事务读取一行数据</li><li>排它锁(X Lock),允许事务删除或更新一条数据.</li></ul><p>正如名称所描述的,共享锁就是能够共享的,就是说在一个事务获取了共享锁之后,另一个事务依旧可以获取共享锁.排它锁是不共享的,当有一个事务获取排它锁之后,则不允许其他任何事务获取任何锁. 在InnoDB中如果想要读取或者写入一条数据,首先应该获得它的锁.   </p><p>并且,InnoDB存储引擎支持多粒度锁定,这种锁定允许事务在行级上的锁和表级上的锁同时存在. 为了实现这个操作,InnoDB提供了一种额外的锁的方式,称为意向锁. </p><p>在InnoDB中,可以将上锁的对象看成一颗树,如果想要对最下层的对象加锁,也就是行锁,就必须要先对上层的对象上锁.也就是说,如果想要在一行上加写锁,首先要在表上加意向排它锁,其次在行所在的页上也加入意向排它锁,最后在那一行上加入排它锁.   </p><p>这一要注意以下,意向锁本身互相都是相互兼容的.意思就是如果表上加了意向共享锁,那么也可以继续在表上加入意向排它锁.</p><p>那这个意向锁又是用来干什么的呢. 意向锁主要是为了很容易的知道我即将要加锁的页或者表能不能被我加锁.  比如说,事务T1为表A中的一行记录加了排他锁,这个时候事务T2要做全表扫描,也就是说要在表级别加共享锁,这个时候,T2首先要判断这个表上是否能加共享锁.如果没有意向锁,那么T2就必须扫描全表,看是否能够加意向共享锁,也就是看看表中有没有任意一行加了排它锁,如果加了,就阻塞,等待,如果任意一行都没有排它锁,则可以加共享锁. 但是有了意向锁之后,因为如果要锁定某一行,就必须先在行锁的页和表上加意向锁.这个时候T2事务只需要看看表上是否有意向排他锁,如果有,则说明,表中有行记录被排它锁锁上了,阻塞,如果没有意向排它锁和排它锁,则自己就可以加锁.  </p><h1 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h1><p>对于行锁有三种算法,分别是:</p><ul><li>Record Lock:　单个行记录上的锁</li><li>Gap Lock :间隙锁，锁定一个范围，但不包含本身</li><li>Next-Key Lock : Gap Lock+ Recork Lock,锁定一个范围,并且锁定记录本身</li></ul><h2 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h2><p>Record Lock总是会锁住索引记录,如果InnoDB存储引擎在建立标的时候没有设置索引,这个时候会用隐式的主键来锁定.</p><h2 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h2><p>Gap Lock锁主要是用来锁住间隙的.也就是为了阻止多个事务将记录插入到同一范围内,这会导致幻读问题的产生.</p><h2 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h2><p>Next-Key Lock是结合了Gap Lock 和Record Lock的一种锁定算法.这种算法锁定的并不是单个值,而是一个范围.这个锁的出现也是为了防止幻读的出现. 比如:现在有一个索引: 10,11,13,20四个值.<br>那么索引可能被Next-Key Locking的区间为:</p><p>(-无穷,10),(10,11],(11,13],(13,20],(20,+无穷].  </p><p>通过这种锁,在自己锁定记录行的时候,还会锁住行记录之前的间隙. 分以下几种情况:</p><ul><li>对于主键索引: Next-Key Lock会自动降级为Record Lock,单单锁住一个行记录.这里主要是为了提高并发性,</li><li>对于唯一辅助索引:  同主键索引一样.会自动降级为Record Lock锁</li><li>对于普通的辅助索引: 会首先加上Next-KeyLock锁,并且在行记录后的空隙加上gap Lock锁.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> InnoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty之EventLoop</title>
      <link href="/2019/06/06/Netty%E4%B9%8BEventLoop/"/>
      <url>/2019/06/06/Netty%E4%B9%8BEventLoop/</url>
      
        <content type="html"><![CDATA[<h1 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h1><p>Netty线程模型是被精心设计的,提升了框架的并发性能,并且在很大程度上避免锁.下面来讲一下Netty中的线程模型和它的EventLoop.</p><h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><p>一说到线程模型,很容易能够想到Reactor线程模型.Reactor又有单线程模型,多线程模型和主从多线程模型. </p><h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h2><p>单线程模型,显而易见就是只有一个线程,即所有的I/O操作都在同一个NIO线程模型.对于此I/O模型的职责则有很多: </p><ul><li>作为服务端,接受TCP连接</li><li>作为客户端,发起TCP连接</li><li>读取通信对端的请求和应答消息</li><li>向通信对端发送请求或应答消息</li></ul><p>这种模型由于只有一个线程处理I/O,因此当并发量提高之后,一个线程很难处理那么多的请求,系统的吞吐量将变的很低.这个时候就演进出了Reactor多线程模型.使用多个线程来处理请求</p><h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><p>Reactor多线程模型和单线程模型的最大的区别就是有一组I/O线程来处理I/O请求.多线程模型的特点如下: </p><ul><li>有专门一个线程用来监听服务端,接受客户端的TCP连接请求</li><li>网络I/O操作读写等由一个NIO线程池负责.通过很多的NIO线程能够处理高并发的网络读写请求</li><li>一个NIO线程可以同时处理N条连接,但是一个连接只对应与一个NIO线程,防止发生并发操作问题.</li></ul><p>这个样子很好的解决了一般并发的问题.但是当如果一个时候有数百万个连接过来,或者服务端需要对客户端握手进行安全验证,但是验证本身非常损耗性能.这个时候,一个Acceptor线程会存在性能不足的问题,这个时候就又出现了第三种Reactor线程模型,主从多线程模型.   </p><h2 id="主从Reactor多线程模型"><a href="#主从Reactor多线程模型" class="headerlink" title="主从Reactor多线程模型"></a>主从Reactor多线程模型</h2><p>此线程模型的特点就是服务端接受客户端连接的不在是一个单独的NIO线程,而是一个独立的NIO线程池.Acceptor接受到客户端TCP连接请求后,将新创建的SocketChannel注册到I/O线程池中的某个线程上.接下来又此线程来处理网络读写问题.</p><h1 id="Netty的线程模型"><a href="#Netty的线程模型" class="headerlink" title="Netty的线程模型"></a>Netty的线程模型</h1><p>Netty的线程模型并不是一成不变的.它实际拒绝域用户的启动参数配置.通过设置不同的启动参数,Netty可以同事支持Reactor单线程模型,多线程模型和主从多线程模型.<br>比如下面三种方式:</p><p><strong>单线程模式</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup work = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">bootstrap.group(work)</span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        .childHandler(<span class="keyword">new</span> StringEncoder());</span><br></pre></td></tr></table></figure></p><p>只有一个线程,并且没有线程池,设置EventLoopGroup的线程数为1.将上面代码改成如下形式:</p><p><strong>Reactor多线程模式</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup work = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">8</span>);</span><br><span class="line">ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">bootstrap.group(boss,work)</span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        .childHandler(<span class="keyword">new</span> StringEncoder());</span><br></pre></td></tr></table></figure></p><p><strong>主从Reactor多线程模式</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">8</span>);</span><br><span class="line">EventLoopGroup work = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">8</span>);</span><br><span class="line">ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">bootstrap.group(boss,work)</span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        .childHandler(<span class="keyword">new</span> StringEncoder());</span><br></pre></td></tr></table></figure></p><p>只需要将BossGroup的参数设置为多个就可以了. 里面的参数就是用几个线程来处理.</p><p>一般来说,都使用主从Reactor多线程模型.主要分为两个线程组,如上所示:boss线程组主要用来接受连接,然后注册到work线程池上的某个线程上.work线程主要用来处理读写请求,并且执行系统调用Task和定时任务.如心跳检测.</p><h1 id="NioEventLoop源码分析"><a href="#NioEventLoop源码分析" class="headerlink" title="NioEventLoop源码分析"></a>NioEventLoop源码分析</h1><p>Netty中的NioEventLoop并不是一个纯粹的I/O线程,它除了负责I/O操作外,还兼顾处理定时任务和系统任务.在Netty中有很多系统Task任务,主要就是为了在I/O线程和用户线程同事操作网络资源的时候,为了防止并发操作导致锁的竞争,将用户线程的操作封装成Task放入消息队列中,由I/O线程负责执行.这样实现了局部无锁化. 说完了EventLoop的功能,来看一下它的实现,这里NioEventLoop是它的一个子类,也是最常用的,因此主要分析一下此类.</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>先来看一下构造方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">                 SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;</span><br><span class="line">    <span class="comment">// 调用父类方法初始化线程池,和回绝策略</span></span><br><span class="line">    <span class="keyword">super</span>(parent, executor, <span class="keyword">false</span>, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);</span><br><span class="line">    <span class="keyword">if</span> (selectorProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"selectorProvider"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strategy == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"selectStrategy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    provider = selectorProvider;</span><br><span class="line">    <span class="comment">// 这里打开一个Selector</span></span><br><span class="line">    <span class="keyword">final</span> SelectorTuple selectorTuple = openSelector();</span><br><span class="line">    selector = selectorTuple.selector;</span><br><span class="line">    unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">    selectStrategy = strategy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>作为Nio的多路复用线程,必须得有一个多路复用器,先来看一下它的多路复用器.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 经过Netty包装过的Selector</span></span><br><span class="line"><span class="keyword">private</span> Selector selector;</span><br><span class="line"><span class="comment">// 没有包装过的selector</span></span><br><span class="line"><span class="keyword">private</span> Selector unwrappedSelector;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectorProvider provider;</span><br></pre></td></tr></table></figure></p><p>Selector的初始化特别简单,就是直接调用Selector.open()创建一个新的Selector.而Netty对Selector的selectedKeys进行了优化,可以通过io.netty.noKeySetOptimization开关来决定是否启用优化,默认不打开selectedKeys优化功能. 下面来看一下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SelectorTuple <span class="title">openSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Selector unwrappedSelector;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 一个为包装的Selector,通过provider打开一个Selector</span></span><br><span class="line">        unwrappedSelector = provider.openSelector();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"failed to open a new selector"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有开启优化,则直接返回一个SelectorTuple对象</span></span><br><span class="line">    <span class="comment">// 这个SelectorTuple就是未包装的Selector和包装的Selector的集合.</span></span><br><span class="line">    <span class="keyword">if</span> (DISABLE_KEY_SET_OPTIMIZATION) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SelectorTuple(unwrappedSelector);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略部分代码 这里就是将Netty自己的selectedKeys将JDk的selectedKeys替换掉.</span></span><br><span class="line">    <span class="comment">// 主要是通过反射来从Selector实例中获取selectedKeys和publicSelectedKeys,将上述</span></span><br><span class="line">    <span class="comment">// 两个变量设置为可写,在通过反射替换掉.</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是Selector的初始化. 初始化Selector完成后就应该</p><h2 id="run-方法"><a href="#run-方法" class="headerlink" title="run()方法"></a>run()方法</h2><p>在EventLoop中,所有的逻辑操作都在for循环体中执行,只有当NioEventLoop接受到退出指令的时候,才会退出循环.</p><p>下面看一方法实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> run&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//通过 select/selectNow 调用查询当前是否有就绪的 IO 事件</span></span><br><span class="line">            <span class="comment">// 当 selectStrategy.calculateStrategy() 返回的是 CONTINUE, 就结束此轮循环,进入下一轮循环;</span></span><br><span class="line">            <span class="comment">// 当返回的是 SELECT, 就表示任务队列为空,就调用select(Boolean);</span></span><br><span class="line">        <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks()))&#123;</span><br><span class="line">        <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class="line">        <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">            <span class="comment">// 调用Select方法</span></span><br><span class="line">            select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line">            <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                selector.wakeup();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 如果发生异常就重建Selector并且处理异常</span></span><br><span class="line">        rebuildSelector0();</span><br><span class="line">        handleLoopException(e);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略部分代码,待下面分析</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先向将wakenUp设置为false,之后在调用select()方法,并且将之前的wakenUp作为参数传进去.<br>来看一下select方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Selector selector = <span class="keyword">this</span>.selector;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 设置选择次数为0</span></span><br><span class="line">        <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> currentTimeNanos = System.nanoTime();</span><br><span class="line">        <span class="comment">// 设置select执行的终止时间</span></span><br><span class="line">        <span class="keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 设置超时时间</span></span><br><span class="line">            <span class="keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="number">500000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line">            <span class="comment">// 如果超时时间到了,并且还没有选择过,就立即选择一次,这里selectNow()会立即触发Selector的选择操作,如果有准备就绪的Channel,则返回就绪的Channel的集合,否则返回0.</span></span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selectCnt == <span class="number">0</span>) &#123;</span><br><span class="line">                    selector.selectNow();</span><br><span class="line">                    selectCnt = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果有任务,并且wakenUp之前是false,则立即调用一次选择方法</span></span><br><span class="line">            <span class="keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里调用带超时的select()方法</span></span><br><span class="line">            <span class="keyword">int</span> selectedKeys = selector.select(timeoutMillis);</span><br><span class="line">            <span class="comment">// 循环中每次选择都会将selectCnt加1.</span></span><br><span class="line">            selectCnt ++;</span><br><span class="line">            <span class="comment">// 如果有事件发生或odlWakeup为true或者线程被系统唤醒或者有任务都会直接跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (selectedKeys != <span class="number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果循环次数过多,超过了默认次数,则说明出现了JDK的空轮询BUG.</span></span><br><span class="line">            <span class="comment">// 需要重建Selector.</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">                selector = selectRebuildSelector(selectCnt);</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currentTimeNanos = time;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Selector.select() returned prematurely &#123;&#125; times in a row for Selector &#123;&#125;."</span>,</span><br><span class="line">                        selectCnt - <span class="number">1</span>, selector);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(CancelledKeyException.class.getSimpleName() + <span class="string">" raised by a Selector &#123;&#125; - JDK bug?"</span>,</span><br><span class="line">                    selector, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个selector的方法的就是选择出已经发生的事件.具体逻辑就是:</p><p>首先计算下一个将要触发定时任务的剩余超时时间,转换为毫秒,为超时时间增加0.5毫秒的调整值.对剩余的超时时间进行判断,如果需要立即执行或者已经超时,则调用selector.selectNow()进行轮询操作,将selectCnt设置为1.并且退出循环.  </p><p>只有将定时任务剩余的超时时间作为参数进行select操作,没完成一次select操作就对selectCnt加1.   </p><p>Select操作完成之后对结果进行判断,如果出现一下集中情况就退出循环:</p><ul><li>有Channel处于就绪状态,就是selectedKeys不为0,说明有读写事件需要处理</li><li>oldWakenUp为true</li><li>系统或者用户调用了wakeup操作,唤醒当前的多路复用器</li><li>系统队列中有新的任务需要处理.</li></ul><p>如果本次selector的轮询结果为空,也没有wakeup操作或者是新的消息需要处理,则说明是个空轮询.将计数器加1. 这里会有一个判断,就是如果在一段时间内空轮询次数过多,则说明导致了一个JDk的空轮询bug,这里解决办法就是调用selectRebuildSelector()方法,来重建Selector.   </p><p>看一下selectRebuildSelector()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Selector <span class="title">selectRebuildSelector</span><span class="params">(<span class="keyword">int</span> selectCnt)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    logger.warn(</span><br><span class="line">            <span class="string">"Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;."</span>,</span><br><span class="line">            selectCnt, selector);</span><br><span class="line">    <span class="comment">// 这里执行重建操作</span></span><br><span class="line">    rebuildSelector();</span><br><span class="line">    Selector selector = <span class="keyword">this</span>.selector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重建完成后立即选择一次</span></span><br><span class="line">    selector.selectNow();</span><br><span class="line">    <span class="keyword">return</span> selector;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rebuildSelector0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Selector oldSelector = selector;</span><br><span class="line">    <span class="keyword">final</span> SelectorTuple newSelectorTuple;</span><br><span class="line">    <span class="keyword">if</span> (oldSelector == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        newSelectorTuple = openSelector();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Failed to create a new Selector."</span>, e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Register all channels to the new Selector.</span></span><br><span class="line">    <span class="keyword">int</span> nChannels = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (SelectionKey key: oldSelector.keys()) &#123;</span><br><span class="line">        Object a = key.attachment();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!key.isValid() || key.channel().keyFor(newSelectorTuple.unwrappedSelector) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> interestOps = key.interestOps();</span><br><span class="line">            key.cancel();</span><br><span class="line">            SelectionKey newKey = key.channel().register(newSelectorTuple.unwrappedSelector, interestOps, a);</span><br><span class="line">            <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">                <span class="comment">// Update SelectionKey</span></span><br><span class="line">                ((AbstractNioChannel) a).selectionKey = newKey;</span><br><span class="line">            &#125;</span><br><span class="line">            nChannels ++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Failed to re-register a Channel to the new Selector."</span>, e);</span><br><span class="line">            <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">                AbstractNioChannel ch = (AbstractNioChannel) a;</span><br><span class="line">                ch.unsafe().close(ch.unsafe().voidPromise());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">                invokeChannelUnregistered(task, key, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    selector = newSelectorTuple.selector;</span><br><span class="line">    unwrappedSelector = newSelectorTuple.unwrappedSelector;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// time to close the old selector as everything else is registered to the new one</span></span><br><span class="line">        oldSelector.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Failed to close the old Selector."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Migrated "</span> + nChannels + <span class="string">" channel(s) to the new Selector."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重建的逻辑也特别简单,首先新打开一个Selector,接着在将原来的Selector中的Channel取消注册,并且注册到新的Selector中,   </p><p>在继续来看run方法中的循环 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cancelledKeys = <span class="number">0</span>;</span><br><span class="line">    needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//ioRatio表示:此线程分配给IO操作所占的时间比(即运行processSelectedKeys耗时在整个循环中所占用的时间).</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">    <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//查询就绪的 IO 事件, 然后处理它;</span></span><br><span class="line">            processSelectedKeys();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//运行 taskQueue 中的任务.</span></span><br><span class="line">            runAllTasks();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">//查询就绪的 IO 事件, 然后处理它;</span></span><br><span class="line">            processSelectedKeys();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">            runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">看到在run的方法中,执行完上面的select方法逻辑后,会开始执行I/O事件和Task.这里有一个ioRatio值,这个值就代表着线程分配给IO操作所占的时间比,例如ioRatio值为<span class="number">50</span>,则IO执行的时间和执行task的时间为<span class="number">1</span>:<span class="number">1</span>.</span><br><span class="line"></span><br><span class="line">在来看一下processSelectedKeys()方法</span><br><span class="line">~~~java</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (selectedKeys != <span class="keyword">null</span>) &#123;</span><br><span class="line">        processSelectedKeysOptimized();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两种情况,一种是有I/O事件发生和没有I/O事件发生.重点来看一下有事件发生的时候也就是processSelectedKeysOptimized()方法;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysOptimized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对每个准备好的I/O通道进行处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; selectedKeys.size; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> SelectionKey k = selectedKeys.keys[i];</span><br><span class="line">            <span class="keyword">final</span> Object a = k.attachment();</span><br><span class="line">            <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">                processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">                processSelectedKey(k, task);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needsToSelectAgain) &#123;</span><br><span class="line">                selectedKeys.reset(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                selectAgain();</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>首先是获取到SelectionKey上附加的对象,这个对象是在注册通道的时候将自己附加上去的.也就是获取了一个NioChannel.之后继续执行procesSelectedKey()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 获取到unsafe实例</span></span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">    <span class="comment">// 判断此键是否无效,如果是无效的,则使用unsafe来关闭连接.</span></span><br><span class="line">    <span class="keyword">if</span> (!k.isValid()) &#123;</span><br><span class="line">        <span class="keyword">final</span> EventLoop eventLoop;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop = ch.eventLoop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (eventLoop != <span class="keyword">this</span> || eventLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取准备好的事件</span></span><br><span class="line">        <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">        <span class="comment">// 如果是连接事件,将连接事件取消,表明已经简历好连接,</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line">            <span class="comment">// 调用finishConnect方法传播连接完成事件</span></span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是可写事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 直接调用强制刷新函数来写数据到通道中</span></span><br><span class="line">            ch.unsafe().forceFlush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是读事件或者接受连接事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用读方法,来处理</span></span><br><span class="line">            unsafe.read();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发生异常就关闭通道.</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的逻辑,注释也写的很清楚了,这里不在细说了.大致就是处理应有的事件.在Netty中的事件都是通过Channel的内部类unsafe实现的.这里就调用了unsafe的不同的方法来处理不同的事件.对于unsafe的处理这里就不多说了,可以看我之前的博文对于unsafe的讲解.</p><p>到这里,NioEventLoop就说完了.说白了,这个EventLoop就是通过在一个循环中不断检测是否有事件发生,如果有I/O事件发生或者有task在队列中,就去执行任务.  并且在循环等待I/O事件发生时候,会记录空轮询的次数,如果在一定的时间内,空轮询的次数超过一定限制,则会从新建立一个Selector,并且把之前的Selector中的Channel重新注册到新的Selector上.</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Netty </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡</title>
      <link href="/2019/06/05/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2019/06/05/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在分布式系统架构中,负载均衡是很有必要的.当有负载均衡的系统中,可以将请求均匀的分布在多个主机中,不至于一个所有的请求都一股脑到了一个主机中,会导致假的分布式系统.因此就有了负载均衡的出现.有两种负载均衡.一种是硬件的负载均衡,比较好的有F5负载均衡,这里就不说了.一种是软件提供的负载均衡.目前有集中主流的比较好的软件负载均衡算法.这里简单说一下.</p><h1 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h1><h2 id="加权随机算法"><a href="#加权随机算法" class="headerlink" title="加权随机算法"></a>加权随机算法</h2><p>思想: 很多服务器,都有自己的权重,将权重平铺到一个一维坐标上.比如有3个服务器A,B,C,权重分别为5,3,2.总权重为10.之后,选一个随机数出来,落在区间[0,5)就是A服务器的区间.[5,8)就是B,[8,10)就是C.</p><p>实现: 先计算所有服务器的总权重,获取一个小于总权重的随机数,然后从第一个服务器开始,让此随机数减去服务器的权重.直到此随机数小于0,当它小于0,说明此随机数落在了这个服务器的区间内.</p><h2 id="最少活跃负载均衡"><a href="#最少活跃负载均衡" class="headerlink" title="最少活跃负载均衡"></a>最少活跃负载均衡</h2><p>思想: 主要就是保存每个服务器正在处理的请求数量.每次向服务器发送一个数据就加1,请求完成则减1. 每次寻找服务器都找活跃数最小的服务器. 如果有几个相同活跃数的服务器,则使用加权随机算法找出服务器.</p><p>实现: 这个可以使用优先队列实现.很方便的找到最少活跃的节点.</p><h2 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h2><p>思想: 将节点hash值分布一个圆环上.寻找节点时候,通过获得的hash值,从此hash值在圆环的位置开始,在圆环上顺时针行走,遇见的第一个服务器就是要选择的.<br>这个样子的好处就是如果在添加节点或者删除节点的时候,受到影响的数据只是在此节点之间的数据.不会影响全部的数据.   </p><p>因为这个样子还是会出现负载不均衡的情况,比如说得到的hash值都分布在圆的前半个,那么处于后半个圆的hash节点就会空闲.这时候就引入了虚拟节点的概念.每个节点都可以有很多个虚拟节点.比如下图:<br><img src="/2019/06/05/负载均衡/一致性hash.jpg" alt><br>颜色一样的代表的是同一个节点.  这个样子能够实现更好的负载均衡.</p><p>实现: 因为要快速的找见第一个比自己hash值大的节点.节点序列可以用TreeMap来存储. 高效找到圆环上的第一个节点.虚拟节点的实现可以使用算法,给每个节点生成很多个不同的hash值,比如按照服务器地址的地位高位和底位分别算出不同的hash来实现虚拟节点.</p><h2 id="轮询负载均衡"><a href="#轮询负载均衡" class="headerlink" title="轮询负载均衡"></a>轮询负载均衡</h2><p>思想: 很简单,就是不断轮询,从第一个到最后一个,每次调用时候一次向后加1.轮询所有的服务器就可以了.</p><h2 id="加权轮询负载均衡"><a href="#加权轮询负载均衡" class="headerlink" title="加权轮询负载均衡"></a>加权轮询负载均衡</h2><p><strong>思想</strong>: 就是在轮询负载均衡的基础上再加按照权重来进行负载均衡.因为很多时候每个机器的配置可能不一样,如果一样,可以使用轮询方法.但是如果不一样,就最好使用加权轮询负载均衡. 举个例子.比如有三个服务器为A,B,C.权重分别为5,2,1. 这个时候,如果有8次请求,那么会分别请求到A五次,B两次,C一次.并且这些请求都是错开的,并不是说先请求A五次,在请求B两次.这样错开能够导致一个服务器的压力不会在一个时刻忽然增高.能够实现一个良好的负载.</p><p><strong>实现</strong>: 平滑的加权轮询负载均衡. Ngnix的护两个数实现.通过两个数组,一个是服务器权重集合weights.一个是当前轮询的权重数组currentWeights. 第一次轮询的时候currentWeigh都为0. 每次选择服务器的时候,首先将currentWeights和weights加起来,然后选出其中最大的权重的节点,将其减去权重总和.然后返回相应的服务器即可.当选择完权重总和的次数过后,currentWeights就会又变为初始状态.<br>举个例子:<br>假设现在有三个服务器A,B,C,权重分别为[5,1,1].这里来模拟一下这个过程<br>| 请求编号 | 当前currentWeights状态|与Weights相加后的状态 |  选择结果 | 减去权重后的creentWeights数组 |<br>| :—-: | :—–: | :——: | :——: | :——: |<br>| 1 | [0,0,0] | [5,1,1] | A | [-2,1,1]|<br>| 2| [-2,1,1]|[3,2,2] | A|[-4,2,2]|<br>| 3 | [-4,2,2] | [1,3,3] | B | [1,-4,3]|<br>| 4 | [1,-4,3] | [6,-3,4] | A | [-1,-3,4] |<br>| 5 | [-1,-3,4]| [4,-2,5] | C | [4.-2,-2] |<br>| 6 | [4,-2,-2]| [9,-1,-1] | A | [2,-1,-1]|<br>| 7 | [2,-1,-1]| [7,0,0]| A |[0,0,0]|</p><p>可以看到这个算法每次是按照权重来分配的.但是又有轮询的特性.并且B和C是穿插在A中间出现的.</p><p>没有那种算法是最好的,最好要根据自己的具体业务来决定使用那种负载均衡算法.  </p><p>这里我说一下我对于这几种算法的应用场景吧:</p><ul><li>加权随机算法:　实现简单，用在有服务器权重的场景，就是每个服务器的处理能力不一样的情况．实现有随机性</li><li>一致性哈希算法: 对于节点的增加和删除比较频繁.这时候可以使用这个算法.可以实现较良好的负载均衡.</li><li>轮询负载均衡: 实现简单,使用在服务器性能一样的情况,并且都比较稳定.</li><li>加权轮询负载均衡: 主要使用在服务器性能不一样的情况下.如果服务器性能一样,可以直接使用普通的轮询方式,编程简单也好用.</li></ul><h1 id="最少连接数"><a href="#最少连接数" class="headerlink" title="最少连接数"></a>最少连接数</h1><p><strong>思想</strong> 找到处理请求最少的服务器,然后将任务分配给他</p><p><strong>实现</strong> 实现很简单,为每个服务器存储一个目前的请求数量,然后每次都找连接数最小的那个服务器来.可以用堆数据结构.</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-InnoDB行记录格式</title>
      <link href="/2019/05/29/Mysql-InnoDB%E8%A1%8C%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F/"/>
      <url>/2019/05/29/Mysql-InnoDB%E8%A1%8C%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h1><p>InnoDB存储引擎是面向列的,就是说数据是按照行进行存放的. 每个页存放的行记录也是有硬性定义的,最多允许存放16KB/2-200行的记录.这里主要介绍两种行记录格式.Compact和Redundant格式.</p><h1 id="Compact行记录格式"><a href="#Compact行记录格式" class="headerlink" title="Compact行记录格式"></a>Compact行记录格式</h1><p><img src="/2019/05/29/Mysql-InnoDB行记录格式/compact.png" alt></p><p>首先首部是一个非NULL变长字段长度列表,并且是按照列的顺序逆序放置的,其长度为:</p><ul><li>若列的长度小于255字节,用1字节表示</li><li>若大于255字节,用2字节表示</li></ul><p>变长字段的长度最大不可以超过2字节,因为在MySQL数据库中varchar类型的最大长度限制为65535.<br>也就是列表中的最后一个数据就是表中第一个变长字段的数据列的数据的长度.</p><p>变长字段之后的第二个部分就是NULL标志位,该位只是了该行数据中是否有NULL值,有则用1表示,该部分所占的字节为1字节.记下来是记录头信息,占用5字节.主要含义为:<br><img src="/2019/05/29/Mysql-InnoDB行记录格式/记录头信息.png" alt></p><p>这里的n_owned是该记录拥有的记录数,因为在InnoDB中,页中的行数据是存储在一个个槽中的,每个槽中可能有多条数据,这个值就是记录所在的槽中有几条记录的.<br>最后就是实际的每个列的数据. 这里需要注意的是,NULL不占该部分任何空间.就是NULL除了有NULL标志位外,没有任何的存储空间.<br>每行数据除了用户定义的列之外,还有两个隐藏列,事务ID列和回滚指针列.如果没有制定主键,还会增加一个6字节的worid列.</p><h1 id="Redundant行记录格式"><a href="#Redundant行记录格式" class="headerlink" title="Redundant行记录格式"></a>Redundant行记录格式</h1><p><img src="/2019/05/29/Mysql-InnoDB行记录格式/redundant.png" alt><br>首部不同与Compact,这里存储的是字段长度偏移列表.同样按照列的顺序逆序放置.是判断每一列的起始位置的偏移量来找见每个列的.<br>记录头信息:<br><img src="/2019/05/29/Mysql-InnoDB行记录格式/redundant记录头.png" alt></p><p>对于Redundant记录格式,记录头占用6字节,其中n_fields值代表一行中列的数量.占10位,也就是最多有1023个列.  </p><p>对于NULL值的处理与Compact不一样,在REdundant中只有varchar的NULL值不占空间,而其他确定长度的字段类型还是要占用空间.而Compact中都不占用空间.</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> InnoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL-InnoDB索引</title>
      <link href="/2019/05/29/MYSQL-InnoDB%E7%B4%A2%E5%BC%95/"/>
      <url>/2019/05/29/MYSQL-InnoDB%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引在Mysql中是很有用的,通过索引能够很快速的找到我们所要查询的数据.这里讲一下InnoDB存储引擎中的索引实现.</p><h1 id="B-索引"><a href="#B-索引" class="headerlink" title="B+索引"></a>B+索引</h1><p>在InnoDB引擎中,索引是通过B+树来实现的.并且是聚集索引.B+树不理解的可以去搜一下,网上教程挺多的.B+树索引在数据库中有一个特性就是高扇出性,在数据库中,树的高度一般都是2-4层.这也就是说一般查找某一个键值的记录只需要进行2-4次IO就可以.   </p><p>在InnoDB引擎中中B+树索引可以分为聚集索引和辅助索引,他们两个不同的地方在与聚集索引的叶子节点中存放的是行记录,辅助索引中存放的是主键值.在B+树中,非叶子节点也就是索引节点,非叶子节点是真正存储数据的节点.两种索引不同的地方在于叶子节点存放的数据是不同的.</p><h2 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h2><p>InnoDB引擎表是索引组织表,就是表中数据按照主键顺序存放.而聚集索引就是按照每张表的主键id构造一颗B+树,同时叶子节点中存放的就是整张表的行记录数据,就是聚集索引的叶子节点为数据页.上一篇博文说过在InnoDB中的数据都是按照页来存储的.这里B+树中的每个节点都对应一个页.大小为16KB.每个数据页都是由一个双向链表来连接的.    </p><h2 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h2><p>辅助索引,叶子节点并不包含行记录的全部数据.叶节点除了包含键值以外,每个叶子节点中的索引行中还包含了一个书签.该书签用来告诉InnoDB在哪里可以找到与索引相对应的行数据.这个书签其实就是对应的行数据的聚集索引键.     </p><p>因此在InnoDB中如果通过辅助索引来查找数据的,IO次数会比按照主键查询多一倍.</p><h2 id="B-树索引的分裂"><a href="#B-树索引的分裂" class="headerlink" title="B+树索引的分裂"></a>B+树索引的分裂</h2><p>传统的B+树索引的分裂是直接从中间开始分裂的.这种情况可能会导致一个问题就是分裂之后的数据页大部分空间都被浪费了.比如说一页中存储4条数据.插入1,2,3,4.是一页.这时候再插入5.会将1,2为一页,但是这一个节点中不会在存储其他的任何东西.会导致空间浪费.</p><p>针对这一点,INnoDB对于B+树索引的分裂做了一点小优化.对此InnoDB做了简单调整.<br>在InnoDB引擎中的PageHeader中有一下几个部分用来保存插入的顺序信息:</p><ul><li>PAGE_LAST_INSERT </li><li>PAGE_DIRECTION</li><li>PAGE_N_DIRECTION</li></ul><p>通过这些信息,InnoDB引擎可以决定是向左还是向右进行分裂.同时决定分裂点记录为哪一个.如果插入是随机的,则取页的中间记录作为分裂点的记录.这里没有优化.而如果上次的插入是递增或递减的,那么会做出一些优化.<br>比如向某一方向插入的记录数量为5,并且目前已经定位到的记录(InnoDB引擎插入时,首先需要进行定位,定位到的记录为带插入记录的前一条记录)之后还有三条记录,则分裂点的记录为定位到的记录后的第三条记录.</p><h2 id="Multi-Range-Read优化"><a href="#Multi-Range-Read优化" class="headerlink" title="Multi-Range Read优化"></a>Multi-Range Read优化</h2><p>MySQL5.6版本开始支持Multi-Range Read优化.简称(MRR)优化,这个优化主要目的就是为了减少磁盘的随机访问,并且将随机访问转化为较为顺序的数据访问.因为顺序访问磁盘效率会高,这里MRR会根据辅助索引查询的结果对主键进行排序,按照主键排序的顺序进行书签查找. 其次就是能够减少缓冲池中页被替换的次数. 批量处理对键值的查询操作.</p><p>MRR工作方式如下:</p><ul><li>将查询到的辅助索引键放入一个缓存中,这是缓存的数据根据辅助索引键排序</li><li>借着按照ROWID来进行排序</li><li>根据RowID的排序顺序来访问实际的数据文件.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> InnoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB表存储格式</title>
      <link href="/2019/05/28/InnoDB%E8%A1%A8%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F/"/>
      <url>/2019/05/28/InnoDB%E8%A1%A8%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><p>InnoDB引擎作为现在mysql的默认引擎,支持事务处理与外键约束,并且有很高的性能.今天这里来说一下InnoDB存储引擎中表的存储格式.  </p><h1 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h1><p>在InnoDB中,表都是根据主键顺序组织存放的.在InnoDB引擎中,每个表都有一个主键,如果在创建表的时候没有显示定义,则将表中的第一个非空唯一索引设为主键,如果没有这样的索引,则会自动创建一个6字节大小的指针.<br>看一个例子:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> mysql&gt; create table t( a int not null, unique key(a) );</span><br><span class="line"> mysql&gt; insert into t select 1;</span><br><span class="line"> mysql&gt; select _rowid from t;</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| _rowid |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">|      1 |</span><br><span class="line">+<span class="comment">--------+</span></span><br></pre></td></tr></table></figure></p><p>这里没有定义主键,会将第一个唯一非空索引设置为主键.也就是a作为主键.</p><h2 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h2><p>从InnoDB存储引擎的逻辑存储结构来看,所有数据都被逻辑地存放在一个空间中,称之为表空间.表空间又有由段(segment),区(extent),页(page)组成.页中存放着一个个的记录.<br><img src="/2019/05/28/InnoDB表存储格式/表空间结构.jpg" alt></p><h2 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h2><p>表空间可以看做是InnoDB存储引擎逻辑结构的最高层,所有的数据都被存放在表空间中.InnoDB引擎中有一个参数innodb_file_per_table,用来设置表空间的.如果开启了此参数,每张表内的数据可以单独放在一个表空间内,如果没开,则所有的表共享一个表空间. </p><h1 id="段"><a href="#段" class="headerlink" title="段"></a>段</h1><p>上图说明了表空间是由各个段组成的,常见的段有数据段,索引段,回滚段.在InnoDB中,表是索引组织的,因此就是索引就是数据.<br>就是数据段即为B+树上的叶子节点.索引段就是B+树上的非叶子节点. </p><h1 id="区"><a href="#区" class="headerlink" title="区"></a>区</h1><p>区是由连续的页组成的空间.在任何情况下每个区的大小都是1MB.默认情况下,InnoDB引擎中的页大小为16KB,即一个区中一共有64个连续的页.在InnoDB1.2.x版本中增加了innodb_page_size参数,该参数可以将默认的页大小设置为4K,8K,但是页中的数据库不压缩,这时候区中页的数量变为256,128.<br>这里有一个问题就是当启用了innodb_file_per_table后,创建的表的默认大小是96KB,区是连续的64个页,创建的表大小至少应该是1MB才对.这是因为在每个段开始的时候,先用32个页大小的碎片页来存放数据,在使用完这些页之后才是64个连续页的申请.这主要是对于一些小表或者undo这类的段,可以在开始时候申请较少的空间,节省磁盘容量的开销.   </p><h1 id="页"><a href="#页" class="headerlink" title="页"></a>页</h1><p>页是InnoDB磁盘管理的最小单位,在InnoDB引擎中,默认每个页的大小为16KB.<br>在InnoDB存储引擎中,常见的页类型有:</p><ul><li>数据页 </li><li>undo页  </li><li>系统页  </li><li>事务数据页 </li><li>插入缓冲位图页</li><li>插入缓冲空闲列表页</li><li>未压缩的二进制大对象页</li><li>压缩的二进制大对象页</li></ul><h1 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h1><p>InnoDB数据页由一下7个部分组成.</p><ul><li>File Header 文件头 38字节</li><li>Page Header (页头) 56字节</li><li>Infimun和Supremum Records</li><li>User Records(用户记录,就是行记录)</li><li>Free Space(空闲空间)</li><li>Page Directory(页目录)</li><li>File Trailer(文件结尾信息)<br><img src="/2019/05/28/InnoDB表存储格式/InnoDB数据页结构.png" alt></li></ul><h2 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h2><p>File Header用来记录页的一些头信息.包含此页的一些头信息.<br><img src="/2019/05/28/InnoDB表存储格式/FileHeader.png" alt></p><h1 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h1><p><img src="/2019/05/28/InnoDB表存储格式/PageHeader.png" alt></p><h2 id="Infimum-和-Supremum-Record"><a href="#Infimum-和-Supremum-Record" class="headerlink" title="Infimum 和 Supremum　Record"></a>Infimum 和 Supremum　Record</h2><p>在InnoDB存储引擎中,每个数据页中有两个虚拟的行记录,用来限定边界.Infimum记录的是比该页中任何主键值都要小的值,Supremum是比任何可能值都要大的值.这俩值在页创建时被简历,并且在任何情况下都不会被删除.</p><h2 id="User-Record-和Free-Space"><a href="#User-Record-和Free-Space" class="headerlink" title="User Record 和Free Space"></a>User Record 和Free Space</h2><p>User Record就是实际存储行记录的内容.在InnoDB中,每个行记录都会存储下一条记录的相对位置.因此这里存储的行记录可以想成是一个链表数据结构.<br>Free Space则就是空闲空间,同样也是链表数据结构.在一条记录被删除后,该空间会被加入空闲链表中.</p><h2 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h2><p>页目录中存放了记录的相对位置.有时候这些记录指针称为Slots(槽)或者目录槽.但是在InnoDB中并不是每个记录一个槽,这里的槽是个稀疏目录,即一个槽中可能有多个记录.每个记录都有一个n_owned的值,记录此记录所在槽中有多少个记录.伪记录Infimum的n_owned值总是1,记录Supremum的n_owned的取值范围为[1,8],当记录被插入或删除的时候需要对槽进行分裂或平衡的维护操作.<br>在Slots中记录按照索引键值顺序存放,这样利用二叉查找迅速找到记录的指针.由于Slots是一个稀疏目录,所以二叉查找是一个粗略的结果,之后在根据记录的下一个指针继续查找相关的记录.  </p><h2 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h2><p>为了检测页是否已经完整的写入磁盘(如可能发生的写入过程中磁盘损坏,机器关机等),InnoDB存储引擎的也中设置了File Trailer部分.File Trailer中只有一个FIL_PAGE_END_LSN部分,占用8字节.前4字节代表该页的checksum值,最后四字节和FileHeader中的FIL_PAGE_LSN相同.将这两个值与FileHeader中的两个值相比,是否一致,(这里checksum的比较需要通过InnoDB的checksum函数来进行比较,不是简单的等值比较),以此来保证页的完整性.</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> InnoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty之ChannelHandler事件</title>
      <link href="/2019/05/21/Netty%E4%B9%8BChannelHandler%E4%BA%8B%E4%BB%B6/"/>
      <url>/2019/05/21/Netty%E4%B9%8BChannelHandler%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="ChannelHandler事件"><a href="#ChannelHandler事件" class="headerlink" title="ChannelHandler事件"></a>ChannelHandler事件</h2><p>Netty是一款基于事件驱动的异步I/O框架.因此有很多事件.有时候不清楚事件是什么时候触发的,这里总结一下.</p><h2 id="inbound事件"><a href="#inbound事件" class="headerlink" title="inbound事件"></a>inbound事件</h2><p>入站事件,在Netty中入站事件是相对于被动发生的一些事件．比如说可读，写事件改变．是从管道的头部向尾部流动．<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMethodHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在将此handler添加到管道中的时候会触发此事件.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HandlerAdd"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在将此handler从管道中移除的时候会触发此事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HandlerRemove"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在此handler对应的pipeline对应的Channel注册到多路复用器上时触发.在handlerAdd之后</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"registered"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消注册时候触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"unregistered"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接建立之后触发,在handlerAdd和channelRegister之后</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channelActive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 连接关闭之后触发,在handlerRemove之前</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channelInActive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当Channel可读之后,会触发.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channelRead"</span>);</span><br><span class="line">        ctx.write(Unpooled.copiedBuffer(<span class="string">"hello"</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">        ctx.fireUserEventTriggered(<span class="string">"bac"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一次读操作完成会调用.并不一定是读取一个数据包.这里一次可能读取不了全部的消息,所以分步读取.如果很大的数据包,会分很多次读取.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"readComplete"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发的用户事件,可以自己定义.需要自己手动调用ctx.fireUserEventTriggered()方法触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eventTriggered"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在写状态改变的时候触发.这个情况一般发生在发送数据太多,对方的接收缓冲区满了,因此不可写,之后等待对方可写之后会触发此事件.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"writeChanged"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发生异常时候触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"exception"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="outbound事件"><a href="#outbound事件" class="headerlink" title="outbound事件"></a>outbound事件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">出站事件，相对来说是主动发生的事件，需要用户手动去调用的事件．数据流动为从尾部到头部．</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOutboundMethodHandler</span> <span class="keyword">extends</span> <span class="title">ChannelOutboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行绑定端口的时候调用此函数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bind"</span>);</span><br><span class="line">        <span class="keyword">super</span>.bind(ctx, localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发起连接的时候调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"connect"</span>);</span><br><span class="line">        <span class="keyword">super</span>.connect(ctx, remoteAddress, localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 断开连接时候调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"disconnect"</span>);</span><br><span class="line">        <span class="keyword">super</span>.disconnect(ctx, promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭Channel时候调用,或者手动触发ctx.close()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"close"</span>);</span><br><span class="line">        <span class="keyword">super</span>.close(ctx, promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用ctx.deregister()方法才可以</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deregister</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"deregister"</span>);</span><br><span class="line">        <span class="keyword">super</span>.deregister(ctx, promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里的读事件并不同于入站的读事件,而是注册读事件,是一个主动的动作.</span></span><br><span class="line">    <span class="comment">// 如果设置了自动读参数,则会在每次读操作完成之后调用此函数.</span></span><br><span class="line">    <span class="comment">// 为什么会有这个方法存在呢,首先是因为有些服务器只接受消息,没必要注册读事件,因此可以设置为不注册读</span></span><br><span class="line">    <span class="comment">// 其次是因为Netty在每次读事件发生的时候总是先取消掉selectionKey的可读事件,因此在读玩之后需要再次加上去</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"read"</span>);</span><br><span class="line">        <span class="keyword">super</span>.read(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写数据会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"write"</span>);</span><br><span class="line">        <span class="keyword">super</span>.write(ctx, msg, promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 刷新数据才会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"flush"</span>);</span><br><span class="line">        <span class="keyword">super</span>.flush(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Netty </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty之unsafe</title>
      <link href="/2019/05/19/Netty%E4%B9%8Bunsafe/"/>
      <url>/2019/05/19/Netty%E4%B9%8Bunsafe/</url>
      
        <content type="html"><![CDATA[<h1 id="unsafe简介"><a href="#unsafe简介" class="headerlink" title="unsafe简介"></a>unsafe简介</h1><p>Unsafe接口实际上是Channel接口的辅助接口,它不应该被用户代码直接调用,实际上的I/O操作都是有Unsafe接口负责完成的.</p><h1 id="API定义"><a href="#API定义" class="headerlink" title="API定义"></a>API定义</h1><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">返回值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">localAddress()</td><td style="text-align:center">SocketAddress</td><td style="text-align:center">返回本地绑定的Socket地址</td></tr><tr><td style="text-align:center">remoteAddress()</td><td style="text-align:center">SocketAddress</td><td style="text-align:center">返回通信对端的Socket地址</td></tr><tr><td style="text-align:center">register(EventLoop eventLoop, ChannelPromise promise)</td><td style="text-align:center">void</td><td style="text-align:center">注册Channel到多路复用器上,一旦注册操作完成,通知ChannelFuture</td></tr><tr><td style="text-align:center">bind(SocketAddress localAddress, ChannelPromise promise)</td><td style="text-align:center">void</td><td style="text-align:center">绑定指定的localAddress到当前的Channel上,完成后通知ChannelFuture</td></tr><tr><td style="text-align:center">connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</td><td style="text-align:center">void</td><td style="text-align:center">绑定完成之后,连接服务器,操作完成之后通知ChannelFuture</td></tr><tr><td style="text-align:center">disconnect(ChannelPromise promise)</td><td style="text-align:center">void</td><td style="text-align:center">断开连接,完成后通知ChannelFuture</td></tr><tr><td style="text-align:center">close(ChannelPromise promise)</td><td style="text-align:center">void</td><td style="text-align:center">关闭Channel连接,完成后通知</td></tr><tr><td style="text-align:center">closeForcibly()</td><td style="text-align:center">void</td><td style="text-align:center">强制关闭连接</td></tr><tr><td style="text-align:center">deregister(ChannelPromise promise)</td><td style="text-align:center">void</td><td style="text-align:center">取消此Channel在多路复用器上的注册</td></tr><tr><td style="text-align:center">beginRead()</td><td style="text-align:center">void</td><td style="text-align:center">设置网络操作位为用于读取消息</td></tr><tr><td style="text-align:center">write(Object msg, ChannelPromise promise)</td><td style="text-align:center">void</td><td style="text-align:center">发送消息,完成之后通知ChannelFuture</td></tr><tr><td style="text-align:center">flush()</td><td style="text-align:center">void</td><td style="text-align:center">将发送缓冲数组中的消息写入到Channel中</td></tr><tr><td style="text-align:center">voidPromise()</td><td style="text-align:center">ChannelPromise</td><td style="text-align:center">返回一个特殊的可重用和传递的ChannelPromise,它不用于操作陈宫或失败的通知器,仅仅作为容器使用</td></tr><tr><td style="text-align:center">outboundBuffer()</td><td style="text-align:center">ChannelOutboundBuffer</td><td style="text-align:center">返回消息发送缓冲区</td></tr></tbody></table><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="继承类图"><a href="#继承类图" class="headerlink" title="继承类图"></a>继承类图</h2><p><img src="/2019/05/19/Netty之unsafe/对比类图.jpg" alt><br>这里继承类图,左边是Unsafe的继承类图,右边是Unsafe所属的类.<br>这里依旧从顶自下的分析unsafe的原理.</p><h1 id="AbstractUnsafe源码分析"><a href="#AbstractUnsafe源码分析" class="headerlink" title="AbstractUnsafe源码分析"></a><strong>AbstractUnsafe源码分析</strong></h1><p>这相当于是最顶层的实现类,实现了大部分方法.</p><h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a><strong>字段</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractUnsafe</span> <span class="keyword">implements</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新建一个输出缓冲区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ChannelOutboundBuffer outboundBuffer = <span class="keyword">new</span> ChannelOutboundBuffer(AbstractChannel.<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// recvhandler</span></span><br><span class="line">    <span class="keyword">private</span> RecvByteBufAllocator.Handle recvHandle;</span><br><span class="line">    <span class="comment">// 是否刷新数据 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> inFlush0;</span><br><span class="line">    <span class="comment">/** true if the channel has never been registered, false otherwise */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> neverRegistered = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a><strong>API</strong></h2><p><strong>获取地址</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SocketAddress <span class="title">localAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> localAddress0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SocketAddress <span class="title">remoteAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remoteAddress0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用外部类的方法,这些方法也就是AbstractChannel的方法,但是并没有被实现,要子类自己去实现.</p><p><strong>注册</strong><br>注册方法主要是将当前Unsafe对应的Channel注册到EventLoop的多路复用器上,然后调用pipeline.fireChannelRegistered()传播注册事件,之后如果已经激活了,调用pipeline.fireChannelActive()方法传播事件.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (eventLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"eventLoop"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRegistered()) &#123;</span><br><span class="line">        promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">"registered to an event loop already"</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</span><br><span class="line">        promise.setFailure(</span><br><span class="line">                <span class="keyword">new</span> IllegalStateException(<span class="string">"incompatible event loop type: "</span> + eventLoop.getClass().getName()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(</span><br><span class="line">                    <span class="string">"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;"</span>,</span><br><span class="line">                    AbstractChannel.<span class="keyword">this</span>, t);</span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里是注册的代码.首先判断一些先决条件,eventLoop不能为空,再判断是否已经被注册过了,之后,设置此eventLoop为此Channel的evetnLoop.之后有一个是否要异步执行的判断,如果当前线程就是与Channel对应的EventLoop所对应的线程,则不存在异步,直接调用register0()方法,如果不是.则异步调用,在eventLoop所有的线程去调用注册方法.  再来看一下register0()方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先Channel是否取消和是否打开着.接着调用doRegister()方法.此方法是由AbstractNioUnsafe对应的AbstractNioChannel实现,下面再介绍.接着唤醒handlerAdd()事件.然后传播.在向ChannelPromise中设置成功标识.接着在pipeline中传播register事件.然后在判断此Channel是否被激活,如果被激活,在判断是否是第一次注册,如果是,传播active事件.在判断是否是自动读,如果设置了自动读,则自动向多路复用器上注册读事件.如果中间出现异常,强制关闭连接,将异常信息写入promise中.</p><p><strong>bind</strong><br>bind方法主要用于绑定指定的端口.对于服务端,用于绑定监听端口,可以设置backlog参数,对于客户端,用于指定客户端Channel的本地绑定socket地址,具体实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line">    <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doBind(localAddress);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        closeIfClosed();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    safeSetSuccess(promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>绑定操作首先判断Channel是否取消和是否打开,不符合直接返回.然后调用doBind()方法执行绑定操作.此绑定操作在NioSocketChannel和NioServerSocketChannel中有不同的实现.<br>客户端代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">    SocketUtils.bind(javaChannel(), localAddress);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    SocketUtils.bind(javaChannel().socket(), localAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务端代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到客户端就是直接将Channel绑定到本地地址,服务端还有一个配置参数,也就是backlog参数.<br>再来看bind()方法的如下代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">    invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            pipeline.fireChannelActive();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码的意思就是说,如果在绑定之前是没有激活的,在绑定了之后被激活了,那么就会触发active事件.</p><p><strong>disconnect</strong><br>这个方法用于服务端或客户端主动关闭连接.代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!promise.setUncancellable()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doDisconnect();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        closeIfClosed();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wasActive &amp;&amp; !isActive()) &#123;</span><br><span class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.fireChannelInactive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    safeSetSuccess(promise);</span><br><span class="line">    closeIfClosed(); <span class="comment">// doDisconnect() might have closed the channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关闭连接方法就是调用了doDisconnect()方法执行具体操作,之后会异步调用fireChannelInactive()方法传播事件.</p><p><strong>deregister</strong><br>取消注册事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deregister</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise, <span class="keyword">final</span> <span class="keyword">boolean</span> fireChannelInactive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!promise.setUncancellable()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                </span><br><span class="line">                doDeregister();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Unexpected exception occurred while deregistering a channel."</span>, t);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fireChannelInactive) &#123;</span><br><span class="line">                    pipeline.fireChannelInactive();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Some transports like local and AIO does not allow the deregistration of</span></span><br><span class="line">                <span class="comment">// an open channel.  Their doDeregister() calls close(). Consequently,</span></span><br><span class="line">                <span class="comment">// close() calls deregister() again - no need to fire channelUnregistered, so check</span></span><br><span class="line">                <span class="comment">// if it was registered.</span></span><br><span class="line">                <span class="keyword">if</span> (registered) &#123;</span><br><span class="line">                    registered = <span class="keyword">false</span>;</span><br><span class="line">                    pipeline.fireChannelUnregistered();</span><br><span class="line">                &#125;</span><br><span class="line">                safeSetSuccess(promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果已经被取消注册,则直接设置成功.调用外部类的doDeregister()方法来执行取消注册操作.在AbstractNioChannel类中定义.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDeregister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    eventLoop().cancel(selectionKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用eventLoop中的cancel来取消注册.之后传播取消注册事件.</p><p><strong>write</strong><br>write方法并不是真正向Channel中写数据,而是将数据添加到发送缓冲区中.知道调用flush才真正将数据发送出去.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line">    ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</span><br><span class="line">    <span class="keyword">if</span> (outboundBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        safeSetFailure(promise, newWriteException(initialCloseCause));</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        msg = filterOutboundMessage(msg);</span><br><span class="line">        size = pipeline.estimatorHandle().size(msg);</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    outboundBuffer.addMessage(msg, size, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到,如果本channel不存在输出缓冲区,则直接将msg释放.在找到msg的size,之后添加到outboundBuffer中</p><p><strong>flush</strong><br>真正向Channel中写数据是在调用了此方法的时候.来看一下代码.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">outboundBuffer.addFlush();</span><br><span class="line">flush0();</span><br></pre></td></tr></table></figure></p><p>这里首先将输出缓冲区的消息标记为以刷新.然后调用flush0()方法,将消息发送出去.看一下flush0()的代码片段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">inFlush0 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!isActive()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isOpen()) &#123;</span><br><span class="line">            outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Do not trigger channelWritabilityChanged because the channel is closed already.</span></span><br><span class="line">            outboundBuffer.failFlushed(newFlush0Exception(initialCloseCause), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        inFlush0 = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    doWrite(outboundBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里首先看Channel是否是激活状态,如果不是,则报错.如果是,调用doWrite()方法,向Channel中写数据.这个doWrite()方法是根据子类的不同有不同的实现.分别在AbstractNioByteChannel(客户端)和AbstractNioMessageChannel(服务端)实现.具体的逻辑在上一篇Channel讲解中说过.这里就不细说了.总之,就是将此输出缓冲区中的数据写出去.</p><h2 id="AbstractNioUnsafe源码分析"><a href="#AbstractNioUnsafe源码分析" class="headerlink" title="AbstractNioUnsafe源码分析"></a><strong>AbstractNioUnsafe源码分析</strong></h2><p>AbstracNioUnsafe是AbstractUnsafe类的NIO实现.主要实现了connect,finishConnnect等方法.<br>方法解析<br><strong>connect</strong><br>连接方法,用来连接远程服务端.实现代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (connectPromise != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConnectionPendingException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">        <span class="keyword">if</span> (doConnect(remoteAddress, localAddress)) &#123;</span><br><span class="line">            fulfillConnectPromise(promise, wasActive);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            connectPromise = promise;</span><br><span class="line">            requestedRemoteAddress = remoteAddress;</span><br><span class="line">            <span class="keyword">int</span> connectTimeoutMillis = config().getConnectTimeoutMillis();</span><br><span class="line">            <span class="comment">// 设置定时任务,在这之后,</span></span><br><span class="line">            <span class="keyword">if</span> (connectTimeoutMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                connectTimeoutFuture = eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        ChannelPromise connectPromise = AbstractNioChannel.<span class="keyword">this</span>.connectPromise;</span><br><span class="line">                        ConnectTimeoutException cause =</span><br><span class="line">                                <span class="keyword">new</span> ConnectTimeoutException(<span class="string">"connection timed out: "</span> + remoteAddress);</span><br><span class="line">                        <span class="keyword">if</span> (connectPromise != <span class="keyword">null</span> &amp;&amp; connectPromise.tryFailure(cause)) &#123;</span><br><span class="line">                            close(voidPromise());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            promise.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (future.isCancelled()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (connectTimeoutFuture != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            connectTimeoutFuture.cancel(<span class="keyword">false</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        connectPromise = <span class="keyword">null</span>;</span><br><span class="line">                        close(voidPromise());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        promise.tryFailure(annotateConnectException(t, remoteAddress));</span><br><span class="line">        closeIfClosed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用doConnect()方法来建立连接.主要的实现在NioSocketChannel类中实现.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doConnect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (localAddress != <span class="keyword">null</span>) &#123;</span><br><span class="line">        doBind0(localAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> connected = SocketUtils.connect(javaChannel(), remoteAddress);</span><br><span class="line">        <span class="keyword">if</span> (!connected) &#123;</span><br><span class="line">            selectionKey().interestOps(SelectionKey.OP_CONNECT);</span><br><span class="line">        &#125;</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> connected;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            doClose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在发起连接请求后,操作可能有三种结果.</p><ol><li>连接成功,返回true</li><li>暂时没有连接上,服务端没有返回ACK应答,结果不确定返回false,但是这个时候需要将NioSocketChannel中的SelectionKey设置为OP_CONNECT,监听连接应答消息.</li><li>连接失败,抛异常.关闭连接.   </li></ol><p>在调用玩doConnect()方法之后,会判断连接结果.如果成功出发ChannelActive事件.如下代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fulfillConnectPromise</span><span class="params">(ChannelPromise promise, <span class="keyword">boolean</span> wasActive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (promise == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> active = isActive();</span><br><span class="line">    <span class="keyword">boolean</span> promiseSet = promise.trySuccess();</span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; active) &#123;</span><br><span class="line">        <span class="comment">// 这里出发ChannelActive事件</span></span><br><span class="line">        pipeline().fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!promiseSet) &#123;</span><br><span class="line">        close(voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Active事件在最后会将此Channel中的SelectionKey设置为OP_READ,监听读事件.<br>如果没有连接上服务器.则根据连接超时事件设置定时任务,超时时间之后出发校验,如果发现还没有完成,则关闭连接句柄.释放资源.并且关闭连接.<br>之后在设置连接结果,如果接收到连接完成通知,则判断连接是否被取消,如果取消则关闭句柄,释放资源,发起取消注册操作.</p><p><strong>finishConnect</strong><br>客户端接受到服务端的TCP握手应答信息.通过finishConnect()方法对连接结果进行判断.代码如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">    doFinishConnect();</span><br><span class="line">    fulfillConnectPromise(connectPromise, wasActive);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    fulfillConnectPromise(connectPromise, annotateConnectException(t, requestedRemoteAddress));</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (connectTimeoutFuture != <span class="keyword">null</span>) &#123;</span><br><span class="line">        connectTimeoutFuture.cancel(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    connectPromise = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先获取连接状态,当前返回false,之后执行doFinishConnect()方法,在NioSocketChannel中实现,具体实现如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFinishConnect</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!javaChannel().finishConnect()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里连接成功返回true,连接失败返回false,发生异常的返回false. 只要连接失败就会抛出Error.<br>如果这里连接完成就会执行fulfillConnectPromise(connectPromise, wasActive)方法,负责将Socketchannel修改为监听读操作.监听网络读事件.传播channelActive事件.   </p><p>在检查期间发生异常之后,则由定时任务关闭客户端连接,将Channel从Reactor线程的多路复用器上擦除.</p><h2 id="NioByteUnsafe源码分析"><a href="#NioByteUnsafe源码分析" class="headerlink" title="NioByteUnsafe源码分析"></a><strong>NioByteUnsafe源码分析</strong></h2><p>这里就是实现了父类的read()方法,这里重点分析此方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">    <span class="keyword">if</span> (shouldBreakReadReady(config)) &#123;</span><br><span class="line">        clearReadPending();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">    <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line">    ByteBuf byteBuf = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure></p><p>这里,首先获取连接的配置信息.然后获取此Channel绑定的管道,从设置中获取缓冲区分配器,和分配器的handler.<br>在向下看<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">    allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">    <span class="keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        byteBuf.release();</span><br><span class="line">        byteBuf = <span class="keyword">null</span>;</span><br><span class="line">        close = allocHandle.lastBytesRead() &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (close) &#123;</span><br><span class="line">            readPending = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">    readPending = <span class="keyword">false</span>;</span><br><span class="line">    pipeline.fireChannelRead(byteBuf);</span><br><span class="line">    byteBuf = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br></pre></td></tr></table></figure></p><p>先为byteBuf分配一个合适的缓冲区.只有调用doReadBytes(byteBuf)方法将可读数据写入byteBuf中.实现代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取handler</span></span><br><span class="line"><span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line"><span class="comment">// 将可读数据变为byteBuf的可写数据</span></span><br><span class="line">allocHandle.attemptedBytesRead(byteBuf.writableBytes());</span><br><span class="line"><span class="comment">// 读取数据到buf</span></span><br><span class="line"><span class="keyword">return</span> byteBuf.writeBytes(javaChannel(), allocHandle.attemptedBytesRead());</span><br></pre></td></tr></table></figure></p><p>从javaChannel中读取数据到buf中,长度为bytebuf可写的长度.当然真正读取到的数据不一定比length长,可能会小,返回读取的字节数.<br>下面接着看read()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line"><span class="keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    byteBuf.release();</span><br><span class="line">    byteBuf = <span class="keyword">null</span>;</span><br><span class="line">    close = allocHandle.lastBytesRead() &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (close) &#123;</span><br><span class="line">        readPending = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>设置上次读取字节的数量,之后判断是否读取到数据,如果没有读取到数据,则释放byteBuf. 如果读取数据小于0,则说明发生了异常.设置close为false.读取失败.需要关闭.退出循环.<br>如果读取成功则说明完成了一次异步读取事件.这个时候会出发一次ChannelRead()事件,这里有一点就是,完成一次读操作并不代表着读到了一条完整的信息.也可能是一条不完整的.可能会有粘包现象.所以需要在pipeline中自行处理.之后再将bytebuf释放. 因为每次读操作都未必能够完成缓冲区的全部读取工作,所以会对读取的字节数进行累加.在累加之前会对长度上线做保护,如果累计读取的字节数已经发生溢出,则将读取的字节数设置为整形最大值,退出循环.主要是为了防止本次读取时间过长,影响后面排队的task任务.这里如果没有溢出,执行累加操作.   在循环体内,会判断读操作的次数,默认一次最多只能执行16此读操作.如果超过,不允许在读,等待下一次selector轮询周期在执行.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">    readPending = <span class="keyword">false</span>;</span><br><span class="line">    pipeline.fireChannelRead(byteBuf);</span><br><span class="line">&#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">continueReading</span><span class="params">(UncheckedBooleanSupplier maybeMoreDataSupplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> config.isAutoRead() &amp;&amp;</span><br><span class="line">            (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;</span><br><span class="line">            totalMessages &lt; maxMessagePerRead &amp;&amp;</span><br><span class="line">            totalBytesRead &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">~~~ </span><br><span class="line"></span><br><span class="line">这个默认的读消息次数为<span class="number">16</span>此,因此到达<span class="number">16</span>次之后会直接退出,等待下一次再继续读.当读取消息完成之后,出发读操作完成事件.如果中间失败过,则关闭此链接.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">allocHandle.readComplete();</span><br><span class="line">pipeline.fireChannelReadComplete();</span><br><span class="line"><span class="keyword">if</span> (close) &#123;</span><br><span class="line">    closeOnRead(pipeline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后如果设置了非自动读.则取消掉注册上去的读操作事件.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">        removeReadOp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="NioMessageUnsafe源码分析"><a href="#NioMessageUnsafe源码分析" class="headerlink" title="NioMessageUnsafe源码分析"></a><strong>NioMessageUnsafe源码分析</strong></h2><p>此类是用来给服务端使用的,用来接受新来的连接.有一个链表字段,用来存储新过来的连接.  也是只复写了父类的read()方法,与NioByteUnsafe的read()方法基本一致,但是在调用的实际子类的实现方法上,调用的是<br>doReadMessages()方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">eventLoop</span><span class="params">()</span>.<span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 获取配置</span></span><br><span class="line">    <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">    <span class="comment">// 获取管道</span></span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line">    <span class="comment">// 设置config</span></span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line">    Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 读取message到readBuf()中</span></span><br><span class="line">                <span class="keyword">int</span> localRead = doReadMessages(readBuf);</span><br><span class="line">                <span class="keyword">if</span> (localRead == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (localRead &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    closed = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 增加一次消息处理次数,最大为16</span></span><br><span class="line">                allocHandle.incMessagesRead(localRead);</span><br><span class="line">            &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            exception = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = readBuf.size();</span><br><span class="line">        <span class="comment">// 将缓冲区中的消息都传入管道中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            readPending = <span class="keyword">false</span>;</span><br><span class="line">            pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清除消息</span></span><br><span class="line">        readBuf.clear();</span><br><span class="line">        </span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        <span class="comment">// 出发读完成操作</span></span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果出现异常,关闭连接,出发异常事件</span></span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">            closed = closeOnReadError(exception);</span><br><span class="line">            pipeline.fireExceptionCaught(exception);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">            inputShutdown = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (isOpen()) &#123;</span><br><span class="line">                close(voidPromise());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">            removeReadOp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 读取消息操作</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SocketChannel ch = SocketUtils.accept(javaChannel());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果获取到一个新连接.</span></span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加入到缓冲区中</span></span><br><span class="line">            buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Failed to create a new channel from an accepted socket."</span>, t);</span><br><span class="line">        <span class="comment">// 失败之后关闭.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Failed to close a socket."</span>, t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Netty </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty之Channel</title>
      <link href="/2019/05/18/Netty%E4%B9%8BChannel/"/>
      <url>/2019/05/18/Netty%E4%B9%8BChannel/</url>
      
        <content type="html"><![CDATA[<h1 id="Channel简介"><a href="#Channel简介" class="headerlink" title="Channel简介"></a>Channel简介</h1><p>Channel是Netty网络操作的抽象类,聚合了一组功能包括但不限于网络的读写,客户端发起连接,主动关闭连接等.也包括了Netty框架相关的功能,比如获得该Channel的EventLoop和pipeline等.     </p><p>在Netty中Channel是和JDK的SocketChannel分开的. 通过自定义的Channel对网络的I/O操作,网络I/O相关联的其他操作封装起来.统一对外提供.并且为SocketChannel和ServerSocketChannel提供了统一的视图.由不同的子类实现不同的功能.公共功能在抽象父类实现.最大的实现了功能和接口的重用.</p><h1 id="Channel抽象类方法"><a href="#Channel抽象类方法" class="headerlink" title="Channel抽象类方法"></a>Channel抽象类方法</h1><p><img src="/2019/05/18/Netty之Channel/channel方法.png" alt><br>这里就是Channel的内部的方法.里面包含一个抽象接口unsafe,是Channel的辅助接口.实际上具体的网络读写操作都是unsafe来完成的.Channel使用来给用户提供的一个调用接口.接下来来分析一些它的实现类来看看是怎么实现的.</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>在Netty中,Channel的实现类特别多,但是最终我们用到的应该是NioServerSocketChannel和NIOSocketChannel.这里就着重介绍这两个核心类.先来看一下这两个核心类的继承类图</p><h2 id="NioServerSocketChannel"><a href="#NioServerSocketChannel" class="headerlink" title="NioServerSocketChannel"></a>NioServerSocketChannel</h2><p><img src="/2019/05/18/Netty之Channel/NioServerSocketChannel类图.png" alt></p><h2 id="NioSocketChannel"><a href="#NioSocketChannel" class="headerlink" title="NioSocketChannel"></a>NioSocketChannel</h2><p><img src="/2019/05/18/Netty之Channel/NioSocketchannel.png" alt></p><p>分析源码就从上向下分析吧,先从Abstractchannel类开始.这是一个抽象类.</p><h2 id="AbstractChannel源码分析"><a href="#AbstractChannel源码分析" class="headerlink" title="AbstractChannel源码分析"></a><strong>AbstractChannel源码分析</strong></h2><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a><strong>字段</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannel</span> <span class="keyword">extends</span> <span class="title">DefaultAttributeMap</span> <span class="keyword">implements</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 日志</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternalLogger logger = InternalLoggerFactory.getInstance(AbstractChannel.class);</span><br><span class="line">    <span class="comment">// 异常.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClosedChannelException ENSURE_OPEN_CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(</span><br><span class="line">            <span class="keyword">new</span> ExtendedClosedChannelException(<span class="keyword">null</span>), AbstractUnsafe.class, <span class="string">"ensureOpen(...)"</span>);</span><br><span class="line">    <span class="comment">// 关闭异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClosedChannelException CLOSE_CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(</span><br><span class="line">            <span class="keyword">new</span> ClosedChannelException(), AbstractUnsafe.class, <span class="string">"close(...)"</span>);</span><br><span class="line">    <span class="comment">// 写时关闭一次样</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClosedChannelException WRITE_CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(</span><br><span class="line">            <span class="keyword">new</span> ExtendedClosedChannelException(<span class="keyword">null</span>), AbstractUnsafe.class, <span class="string">"write(...)"</span>);</span><br><span class="line">    <span class="comment">// 刷新关闭异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClosedChannelException FLUSH0_CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(</span><br><span class="line">            <span class="keyword">new</span> ExtendedClosedChannelException(<span class="keyword">null</span>), AbstractUnsafe.class, <span class="string">"flush0()"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NotYetConnectedException FLUSH0_NOT_YET_CONNECTED_EXCEPTION = ThrowableUtil.unknownStackTrace(</span><br><span class="line">            <span class="keyword">new</span> NotYetConnectedException(), AbstractUnsafe.class, <span class="string">"flush0()"</span>);</span><br><span class="line">    <span class="comment">// 父Channel</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Channel parent;</span><br><span class="line">    <span class="comment">// ChannelId,每个Channel都会有一个全局id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelId id;</span><br><span class="line">    <span class="comment">// Unsafe实例,</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line">    <span class="comment">// 与Channel绑定的pipeline</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultChannelPipeline pipeline;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> VoidChannelPromise unsafeVoidPromise = <span class="keyword">new</span> VoidChannelPromise(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CloseFuture closeFuture = <span class="keyword">new</span> CloseFuture(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 本地地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> SocketAddress localAddress;</span><br><span class="line">    <span class="comment">// 远程地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> SocketAddress remoteAddress;</span><br><span class="line">    <span class="comment">// 当前Channel注册的EventLoop</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> EventLoop eventLoop;</span><br><span class="line">    <span class="comment">// 是否已经注册</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> registered;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> closeInitiated;</span><br><span class="line">    <span class="comment">// 初始化异常</span></span><br><span class="line">    <span class="keyword">private</span> Throwable initialCloseCause;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache for the string representation of this channel */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> strValActive;</span><br><span class="line">    <span class="keyword">private</span> String strVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里,AbstractChannel聚合了所有Channel使用到的能力对象.由AbstractChannel统一进行初始化和封装.如果功能和子类相关.则由子类去实现.这里不得不说一句,Netty的设计极大的利用了继承体系.代码复用规则利用的是淋漓尽致.接下来看具体实现.</p><h3 id="核心API分析"><a href="#核心API分析" class="headerlink" title="核心API分析"></a><strong>核心API分析</strong></h3><p><strong>初始化</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        id = newId();</span><br><span class="line">        unsafe = newUnsafe();</span><br><span class="line">        pipeline = newChannelPipeline();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AbstractUnsafe <span class="title">newUnsafe</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title">newChannelPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPipeline(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">~~~ </span><br><span class="line">就是新建一个新建一个pipeline,unsafe实例和id属性.unsafe与子类相关,所以这里是newUnsafe()抽象方法,由子类实现.pipeline都用的是默认的pipeline,在这里实现.</span><br><span class="line"></span><br><span class="line">**网络I/O操作**</span><br><span class="line">~~~java</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pipeline.connect(remoteAddress, localAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">disconnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pipeline.disconnect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pipeline.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">deregister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pipeline.deregister();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里可以看到网络I/O操作就是调用pipeline的网络操作进行.也就是调用其中的handler进行具体逻辑.</p><p><strong>公共API</strong><br>对于一些公共的API,例如remoteAddress()和localAddress()方法等,此类中提供了一些实现.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SocketAddress <span class="title">remoteAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SocketAddress remoteAddress = <span class="keyword">this</span>.remoteAddress;</span><br><span class="line">    <span class="keyword">if</span> (remoteAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.remoteAddress = remoteAddress = unsafe().remoteAddress();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// Sometimes fails on a closed socket in Windows.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> remoteAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先从自己变量中获取,如果没有,在调用通过unsafe来获取.此unsafe()是需要子类去自己实现的.   </p><h2 id="AbstractNioChannel源码分析"><a href="#AbstractNioChannel源码分析" class="headerlink" title="AbstractNioChannel源码分析"></a>AbstractNioChannel源码分析</h2><h3 id="字段-1"><a href="#字段-1" class="headerlink" title="字段"></a><strong>字段</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractNioChannel</span> <span class="keyword">extends</span> <span class="title">AbstractChannel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternalLogger logger =</span><br><span class="line">            InternalLoggerFactory.getInstance(AbstractNioChannel.class);</span><br><span class="line">    <span class="comment">// 关闭管道异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClosedChannelException DO_CLOSE_CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(</span><br><span class="line">            <span class="keyword">new</span> ClosedChannelException(), AbstractNioChannel.class, <span class="string">"doClose()"</span>);</span><br><span class="line">    <span class="comment">// 这里使用SelectableChannel来使得ServerSocketChannel和</span></span><br><span class="line">    <span class="comment">// SocketChannel可以共用.通过此引用可以代表任何一个JDK的Channel,因此实现了公用,提供了统一的接口.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SelectableChannel ch;</span><br><span class="line">    <span class="comment">// 感兴趣事件集合</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> readInterestOp;</span><br><span class="line">    <span class="comment">// 这是Channel注册到选择器上所返回的选择键,这里使用</span></span><br><span class="line">    <span class="comment">// volatile是为了为了保证多个线程并发写操作时SelectionKey的可见性</span></span><br><span class="line">    <span class="keyword">volatile</span> SelectionKey selectionKey;</span><br><span class="line">    <span class="keyword">boolean</span> readPending;</span><br><span class="line">    <span class="comment">// 保存连接操作结果</span></span><br><span class="line">    <span class="keyword">private</span> ChannelPromise connectPromise;</span><br><span class="line">    <span class="comment">// 连接超时定时器</span></span><br><span class="line">    <span class="keyword">private</span> ScheduledFuture&lt;?&gt; connectTimeoutFuture;</span><br><span class="line">    <span class="comment">// 请求通信地址</span></span><br><span class="line">    <span class="keyword">private</span> SocketAddress requestedRemoteAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="API"><a href="#API" class="headerlink" title="API"></a><strong>API</strong></h3><p><strong>初始化</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.ch = ch;</span><br><span class="line">        <span class="keyword">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ch.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(</span><br><span class="line">                            <span class="string">"Failed to close a partially initialized socket."</span>, e2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Failed to enter non-blocking mode."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>初始化就是根据传进来的参数设置Channel,此Channel是JDK内置的Channel.然后设置感兴趣事件,接着设置为非阻塞模式.如果中间发生异常,则抛出.</p><p><strong>doRegister</strong><br>首先来看一下doRegister()方法.也就是Channel的注册方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">                eventLoop().selectNow();</span><br><span class="line">                selected = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先定义一个变量来表示是否成功.调用此SelectableChannel的register方法,将当前的Channel注册到EventLoop的多路复用器上.这里的SelectableChannel就相当于是JDK中的实现了此类的任意一个Channel.这里的register方法由具体的Channel实现.也就是JDK中的Channel的register方法.<br>这里注册感兴趣的事件为0,也就是对任何事件都不感兴趣,仅仅完成注册操作,之后接受到网络事件通知的时候可以在设置SelectionKey的感兴趣事件.如果此Channel已经取消,则抛出异常.如果是第一次处理该异常,则立即调用selectNow()方法将已经取消掉的selectionKey从多路复用器中删掉.继续发起下一次操作.如果仍然有异常,说明无法删除已经被取消的selectionKey,JDK中出现的BUG,直接抛出异常. </p><p><strong>doBeginRead</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">    <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readPending = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的主要作用就是开始读,意思是开始监听读事件.上面注册也说到了,注册的时候并不会注册感兴趣事件.一般会在这里调用监听读事件,这里的doBeginRead()说的是注册读事件,并不是开始读数据.当调用调用Channel.read()或者ChannelHandlerContext.read()会调用此方法,注意这两个方法都是出站的方法.入站的方法是ctx.fireChannelRead(msg)方法.<br>代码也很容易看懂,首先看此选择键是否有效,如果有效,则将读事件添加上去.在设置读等待标志位.</p><h2 id="AbstractNioMessageChannel源码分析"><a href="#AbstractNioMessageChannel源码分析" class="headerlink" title="AbstractNioMessageChannel源码分析"></a><strong>AbstractNioMessageChannel源码分析</strong></h2><p><img src="/2019/05/18/Netty之Channel/NioMessageChannel方法类图.png" alt></p><p>类中依旧有一个unsafe类,类是覆盖的父类的方法.<br>只有一个变量是用来表示输入是否完成标志.接下来看一下基本的方法</p><p><strong>doBeginRead()</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inputShutdown) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里调用父类的方法,也就是AbstractNioChannel的方法</span></span><br><span class="line">    <span class="keyword">super</span>.doBeginRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>doWrite()</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(ChannelOutboundBuffer in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SelectionKey key = selectionKey();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = key.interestOps();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Object msg = in.current();</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">                key.interestOps(interestOps &amp; ~SelectionKey.OP_WRITE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = config().getWriteSpinCount() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (doWriteMessage(msg, in)) &#123;</span><br><span class="line">                    done = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                in.remove();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Did not write all messages.</span></span><br><span class="line">                <span class="keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) == <span class="number">0</span>) &#123;</span><br><span class="line">                    key.interestOps(interestOps | SelectionKey.OP_WRITE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (continueOnWriteError()) &#123;</span><br><span class="line">                in.remove(e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在一个循环中做写事件.首先获取选择键,接着获取此选择键的感兴趣的事件.接着就进入循环中写数据.看下面片段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object msg = in.current();</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">                key.interestOps(interestOps &amp; ~SelectionKey.OP_WRITE);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先先获得要写的数据.如果为空,则说明已经没有数据要写了.再将<br>key的可写事件取消注册.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = config().getWriteSpinCount() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (doWriteMessage(msg, in)) &#123;</span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先设置一个半包标识为false,这个半包标识是什么呢,就是当缓冲区的数据特别多的时候,不可能一下子就发送完成,但是Netty又是一个高性能的异步I/O框架.所以不可能会让你一直运行下去,所以就有了半包标识来判断是否写入数据完成了.<br>这里的doWriteMessage(msg, in)没有实现,等待子类去实现,由子类来执行真正的写数据操作.<br>这里进入循环中,首先获取写事件的循环次数,一般默认为16,如果写入数据成功,则设置done标识符为true,退出循环,删除掉输出缓冲区中的数据,并且在之后取消选择键上的写事件.如果调用子类方法失败,则继续调用,直到超过最大次数16次之后退出循环,这个时候done为false,需要将写事件重新注册上去,待下次多路复用器选择后继续执行写操作.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (done) &#123;</span><br><span class="line">   in.remove();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) == <span class="number">0</span>) &#123;</span><br><span class="line">        key.interestOps(interestOps | SelectionKey.OP_WRITE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的方法都不重要了.因此就不多说了.有兴趣可以自己看一看.</p><h2 id="AbstractNioByteChannel源码分析"><a href="#AbstractNioByteChannel源码分析" class="headerlink" title="AbstractNioByteChannel源码分析"></a><strong>AbstractNioByteChannel源码分析</strong></h2><p>字段比较简单,有一个用于刷新数据的runnable(),用来异步将数据写入Socket中.这里不多说了,建议自己去看一看比较好.接下来看一些主要方法:</p><h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a><strong>API</strong></h3><p><strong>doWrite()</strong><br>这个方法类似于AbstractNioMessageChannel的doWrite()方法,但是要发送的数据不一样.看代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(ChannelOutboundBuffer in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> writeSpinCount = config().getWriteSpinCount();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Object msg = in.current();</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clearOpWrite();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        writeSpinCount -= doWriteInternal(in, msg);</span><br><span class="line">    &#125; <span class="keyword">while</span> (writeSpinCount &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    incompleteWrite(writeSpinCount &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先的到此channel的writeSpinCount值,之后循环向channel中写数据.这个值为了在发送缓冲区满了的时候不会一直因为执行此操作而浪费cpu,将此消息等到下次轮询的时候在发送.<br>首先从发送消息缓冲区弹出一条消息,接着判断消息是否为空.如果为空,说明消息发送完成,清除半包标识则调用clearOpWrite()清除写事件.</p><p><strong>clearOpWrite</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clearOpWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SelectionKey key = selectionKey();</span><br><span class="line">    <span class="keyword">if</span> (!key.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = key.interestOps();</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">        key.interestOps(interestOps &amp; ~SelectionKey.OP_WRITE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>清除半包标识就是通过将SelectionKey的网络网络操作位的写操作位置0来实现.</p><p><strong>doWriteInternal</strong></p><p>上面doWrite()方法主要是通过此方法来发送数据.这里来看一下.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doWriteInternal</span><span class="params">(ChannelOutboundBuffer in, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBuf) &#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        <span class="keyword">if</span> (!buf.isReadable()) &#123;</span><br><span class="line">            in.remove();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> localFlushedAmount = doWriteBytes(buf);</span><br><span class="line">        <span class="keyword">if</span> (localFlushedAmount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            in.progress(localFlushedAmount);</span><br><span class="line">            <span class="keyword">if</span> (!buf.isReadable()) &#123;</span><br><span class="line">                in.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看一下代码,太长了,只写了一部分.首先判断是否是ByteBuf类型的,如果是,则进行强制类型转换. 如果不可此Bytebuf不可读,则从发送消息数组中移除此消息.继续循环处理其他消息.<br>如果buf中有数据,则调动doWriteBytes(buf)方法向Channel写数据,这里是需要子类去实现的.返回写入的字节数.如果此返回0,说明没有发送出去数据,可能发送缓冲区满了,则返回Integer.MAX_INT.这个时候需要设置写半包标识,待下一次选择写数据.<br>如果写入的数据大于0,则调用in.progress(localFlushedAmount)方法来更新输出缓冲区的发送进度信息.然后对发送的buf进行判断,如果没有数据,则从消息队列中删除.  </p><p><strong>incompleteWrite</strong><br>在doWrite()方法的最后会调用此函数,判断是否已经写入完成了.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incompleteWrite(writeSpinCount &lt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>看代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">incompleteWrite</span><span class="params">(<span class="keyword">boolean</span> setOpWrite)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (setOpWrite) &#123;</span><br><span class="line">        setOpWrite();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearOpWrite();</span><br><span class="line">        eventLoop().execute(flushTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法比较简单.首先判断是否需要设置半包标识,也就是上面doWrite()方法中的writeSpinCount是否小于0,小于0说明数据没有发送完成,因为如果数据发送完成会通过break退出循环,导致writeSpinCount大于0,只有在还有数据没有发送完成的时候才会小于0.则需要设置半包标识,待下次发送.如果发送完成了.则清除半包标识,获取eventloop执行冲刷数据操作.就是真正向Channel中写数据的操作.之前的只是一些向Channel中写数据的逻辑调用.</p><p><strong>setOpWrite</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setOpWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SelectionKey key = selectionKey();</span><br><span class="line">    <span class="keyword">if</span> (!key.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = key.interestOps();</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) == <span class="number">0</span>) &#123;</span><br><span class="line">        key.interestOps(interestOps | SelectionKey.OP_WRITE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主要就是设置半包标识,也就是向Channel中注册写事件.一般来说,写事件都会发生,只有在自己发送消息太多,对方的发送缓冲区满了的情况下写事件才不会发生.</p><h2 id="NioServerSocketChannel-1"><a href="#NioServerSocketChannel-1" class="headerlink" title="NioServerSocketChannel"></a><strong>NioServerSocketChannel</strong></h2><p>字段没有什么好说的,主要看一下方法.<br><strong>初始化</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//DEFAULT_SELECTOR_PROVIDER是默认的JDK的Selector的提供者</span></span><br><span class="line">    <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> provider.openServerSocketChannel();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(</span><br><span class="line">                <span class="string">"Failed to open a server socket."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里初始化父类,然后忽的默认的SelectorProvider,来创建新的ServerSocketChannel.  </p><p><strong>doBind()</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">绑定方法主要就是调用javaChannel也就是jdk的Channel的绑定地址的方法.不过这里有了判断,判断这里平台中的jdk版本,有不一样的调用措施.</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>doReadMessage</strong><br>NioServerSocketChannel是继承的AbstractNioMessageChannel类.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SocketChannel ch = SocketUtils.accept(javaChannel());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Failed to create a new channel from an accepted socket."</span>, t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Failed to close a socket."</span>, t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先accept等待有连接接入,如果有的话,新建一个NioSocketChannel加入buf中.之后传入pipeline中的handler处理事件.</p><h2 id="NioSocketChannel源码分析"><a href="#NioSocketChannel源码分析" class="headerlink" title="NioSocketChannel源码分析"></a><strong>NioSocketChannel源码分析</strong></h2><p>NioScketChannel是继承自AbstractNioByteChannel类,与NIOServerSocketChannel不一样.至于再向上层走就一样了.这就是Netty的设计的好处,极可能的找到所有的共同点,在父类进行公共功能的实现.依赖与具体的由子类来实现. </p><h3 id="API实现"><a href="#API实现" class="headerlink" title="API实现"></a><strong>API实现</strong></h3><p><strong>doBind</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    doBind0(localAddress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        SocketUtils.bind(javaChannel(), localAddress);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        SocketUtils.bind(javaChannel().socket(), localAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过此工具类来进行绑定操作.</p><p><strong>doConnect</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doConnect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (localAddress != <span class="keyword">null</span>) &#123;</span><br><span class="line">        doBind0(localAddress);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> connected = SocketUtils.connect(javaChannel(), remoteAddress);</span><br><span class="line">        <span class="keyword">if</span> (!connected) &#123;</span><br><span class="line">            selectionKey().interestOps(SelectionKey.OP_CONNECT);</span><br><span class="line">        &#125;</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> connected;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            doClose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>连接操作就是首先看本地地址,不为空则先执行绑定操作,之后调用工具类来执行连接操作.如果连接成功,返回成功,如果连接未完成,则向SelectionKey上添加连接事件.以便下一次轮询继续执行连接操作.如果出错,则执行doClose()操作.说明连接被拒绝或者被rest.</p><p><strong>doWriteBytes</strong><br>上面说道在AbstractNioByteChannel中的doWriteInternal()方法中调用了由子类复写的doWriteBytes(buf)方法,现在来看一下这里的实现.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doWriteBytes</span><span class="params">(ByteBuf buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedWrittenBytes = buf.readableBytes();</span><br><span class="line">    <span class="keyword">return</span> buf.readBytes(javaChannel(), expectedWrittenBytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先获取buf中的可读字节,之后在向channel中写入javaChannel中写入字节.</p><p><strong>doReadBytes</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadBytes</span><span class="params">(ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line">    allocHandle.attemptedBytesRead(byteBuf.writableBytes());</span><br><span class="line">    <span class="keyword">return</span> byteBuf.writeBytes(javaChannel(), allocHandle.attemptedBytesRead());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>直接将channel的数据写入到参数byteBuf中.</p><p><strong>doWrite</strong><br>重点看一下doWrite()方法,这个方法是执行写操作的.覆盖了父类的写方法<br>看一下实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(ChannelOutboundBuffer in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SocketChannel ch = javaChannel();</span><br><span class="line">    <span class="keyword">int</span> writeSpinCount = config().getWriteSpinCount();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (in.isEmpty()) &#123;</span><br><span class="line">            clearOpWrite();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxBytesPerGatheringWrite = ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();</span><br><span class="line">        </span><br><span class="line">        ByteBuffer[] nioBuffers = in.nioBuffers(<span class="number">1024</span>, maxBytesPerGatheringWrite);</span><br><span class="line">        <span class="keyword">int</span> nioBufferCnt = in.nioBufferCount();</span><br><span class="line">        <span class="keyword">switch</span> (nioBufferCnt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                writeSpinCount -= doWrite0(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                ByteBuffer buffer = nioBuffers[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> attemptedBytes = buffer.remaining();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> localWrittenBytes = ch.write(buffer);</span><br><span class="line">                <span class="keyword">if</span> (localWrittenBytes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    incompleteWrite(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                adjustMaxBytesPerGatheringWrite(attemptedBytes, localWrittenBytes, maxBytesPerGatheringWrite);</span><br><span class="line">                in.removeBytes(localWrittenBytes);</span><br><span class="line">                --writeSpinCount;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                <span class="keyword">long</span> attemptedBytes = in.nioBufferSize();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> localWrittenBytes = ch.write(nioBuffers, <span class="number">0</span>, nioBufferCnt);</span><br><span class="line">                <span class="keyword">if</span> (localWrittenBytes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    incompleteWrite(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                adjustMaxBytesPerGatheringWrite((<span class="keyword">int</span>) attemptedBytes, (<span class="keyword">int</span>) localWrittenBytes,</span><br><span class="line">                        maxBytesPerGatheringWrite);</span><br><span class="line">                in.removeBytes(localWrittenBytes);</span><br><span class="line">                --writeSpinCount;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (writeSpinCount &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    incompleteWrite(writeSpinCount &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看一下写操作.这里writeSpinCount就是对循环写的次数进行控制.因为如果发送缓冲区满了,则会阻塞,消息无法发送出去,如果不对写的次数进行限制的话,则线程无法对其他正在排队的task进行处理.因此对此做出控制,默认为16.<br>然后,首先获取到此输出缓冲区中的ByteBufffer的个数.如果为0,则直接看看是否还有其他东西可以写入.比如说文件等等.如果个数为1,则说明只有一个ByteBufffer,只写入第0个索引的缓冲区.如果超过1个,将此缓冲区数组中的数据都写入进去. 如果写入数据的操作返回0或负数,则调用incompleteWrite(true)方法,将此Channel设置为写半包状态,待下一次选择之后重新写入数据.  如果成功向其中写入数据,则移除输出缓冲区的响应的已经写入的字节.  意思就是 ch.write()方法会返回一个数值,就是已经写入的字节数.这个时候,会移除掉缓冲区中相应的字节数.再将可循环次数减1.<br>之后调用adjustMaxBytesPerGatheringWrite()方法来尽量使得系统的发送缓冲区的大小和自己设置的一样.这了主要是因为一些系统可能默认会改变自己设置的一些参数</p><p>剩下的还有一些方法就比较简单了,这里就不一一介绍了.可以自己去看一看源码.<br>这上面说的几个应该就是Channel旗下的几个核心类了.这里只说了api的实现,但是开头也说了,具体的操作很多还是靠其中的内部类unsafe来实现的.这里没有介绍,还是需要看看unsafe中怎么实现的.</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Netty </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty之事件传播机制</title>
      <link href="/2019/05/16/Netty%E4%B9%8B%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/05/16/Netty%E4%B9%8B%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Netty事件传播机制"><a href="#Netty事件传播机制" class="headerlink" title="Netty事件传播机制"></a>Netty事件传播机制</h1><p>使用过Netty应该都知道,Netty是通过在pipeline中设置一系列处理器来对数据进行一系列处理的.但是总是可能因为事件传播不过去而特别烦恼,也不知道是哪里出错了.今天这里来分析一下在Netty中的事件传播机制.</p><h1 id="入站和出站"><a href="#入站和出站" class="headerlink" title="入站和出站."></a>入站和出站.</h1><p>入站和出站首先要知道这三个类.ChannelHandler,ChannelOutboundHandler和ChannelInboundHandler.这两个一个是用来处理出站事件,一个处理入站事件.类文件结构图<br><img src="/2019/05/16/Netty之事件传播机制/class.jpg" alt><br>Netty对这两个接口都进行了一个适配.继承适配器之后只需要实现需要的方法就可以了,而不需要实现所有的方法.ChannelInboundHandlerAdapter和ChannelOutboundHandlerAdapter.<br>这两个类一个是处理入站,一个处理出站事件.入站事件(ChannelInboundHandler)就是数据从远程主机发送过来的事件,反之则是出站事件.而这些handler最终都被添加到一个pipeline中,在这个pipeline中流动.<br><img src="/2019/05/16/Netty之事件传播机制/pipeline.jpg" alt><br>这个管道中的handler的顺序取决于调用addLast()添加的顺序.能够看到,如果是入站事件,将会沿着pipeline中的头一直传入到尾部.出站事件则从尾部向头部传送.还有就是入站事件只传送给入站事件,出站事件只传送给出站事件.  </p><h1 id="pipeline初始化"><a href="#pipeline初始化" class="headerlink" title="pipeline初始化"></a>pipeline初始化</h1><p>想要明白pipeline中的事件传播过程,就首先要知道pipeline中的数据结构,要知道它中间到底存了些什么,都是干什么用的.<br>上一篇文章说到了当创建Channel的时候会自动创建与之绑定的Pipeline<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannel</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        id = newId();</span><br><span class="line">        unsafe = newUnsafe();</span><br><span class="line">        pipeline = newChannelPipeline();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其实就是创建一个DefaultChannelPipeline</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title">newChannelPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPipeline(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>进入看看这个DefaultChannelPipeline类,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelPipeline</span> <span class="keyword">implements</span> <span class="title">ChannelPipeline</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">"channel"</span>);</span><br><span class="line">        succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line">        voidPromise =  <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 建立一个尾节点</span></span><br><span class="line">        tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 新建头结点</span></span><br><span class="line">        head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里就能看出来了,在pipeline中的一个个处理器通过链表来连接起来的.但是在构造之初又添加了一个尾节点和头结点.就是在pipeline的两端都会有一个处理器.这两个个节点又是干什么的呢.下面再来看一下实现代码</p><p>再来看一下TailContext类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TailContext</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerContext</span> <span class="keyword">implements</span> <span class="title">ChannelInboundHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TailContext(DefaultChannelPipeline pipeline) &#123;</span><br><span class="line">        <span class="keyword">super</span>(pipeline, <span class="keyword">null</span>, TAIL_NAME, TailContext.class);</span><br><span class="line">        setAddComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        onUnhandledInboundChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        onUnhandledInboundChannelInactive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        onUnhandledChannelWritabilityChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> </span>&#123;</span><br><span class="line">        onUnhandledInboundUserEventTriggered(evt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        onUnhandledInboundException(cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        onUnhandledInboundMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        onUnhandledInboundChannelReadComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到这个类继承了AbstractChannelHandlerContext类,也就是它也是一个ChannelHandlerContext.在pipeline中的handler就是被封装到context中,然后通过链表连接起来的.<br>在发现实现了ChannelInboundHandler接口,也就是用来处理入站事件的.这个节点也能够看到是Tail也就是尾节点.不管怎么添加处理器节点,此节点永远在尾部处理程序.用来做善后.并且也用来作为输出数据的起始节点.<br>先来看一下具体的善后方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelPipeline</span> <span class="keyword">implements</span> <span class="title">ChannelPipeline</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个方法使用来善后异常捕获方法.如果异常传播到这里没有被处理,这里会发出警告,并且会释放异常</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.warn(</span><br><span class="line">                    <span class="string">"An exceptionCaught() event was fired, and it reached at the tail of the pipeline. "</span> +</span><br><span class="line">                            <span class="string">"It usually means the last handler in the pipeline did not handle the exception."</span>,</span><br><span class="line">                    cause);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundChannelActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundChannelInactive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传播事件,到这里 依旧会发出警告,接着如果可以释放掉,也就是释放此消息</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.debug(</span><br><span class="line">                    <span class="string">"Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. "</span> +</span><br><span class="line">                            <span class="string">"Please check your pipeline configuration."</span>, msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在来看一下HeadContextle<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadContext</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerContext</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span>, <span class="title">ChannelInboundHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line"></span><br><span class="line">        HeadContext(DefaultChannelPipeline pipeline) &#123;</span><br><span class="line">            <span class="keyword">super</span>(pipeline, <span class="keyword">null</span>, HEAD_NAME, HeadContext.class);</span><br><span class="line">            unsafe = pipeline.channel().unsafe();</span><br><span class="line">            setAddComplete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// NOOP</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// NOOP</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            unsafe.bind(localAddress, promise);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接方法  调用unsafe发起连接,出站事件</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                SocketAddress remoteAddress, SocketAddress localAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">                ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            unsafe.connect(remoteAddress, localAddress, promise);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断开连接方法,调用unsafe断开连接. 出站事件</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            unsafe.disconnect(promise);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            unsafe.close(promise);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deregister</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            unsafe.deregister(promise);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读消息事件.在有消息可以读取的时候会调用pipeline.read()方法,这个方法首先调用此方法,这里调用unsafe.beginRead()方法,开始读取,之后再传播可读事件.</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            unsafe.beginRead();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            unsafe.write(msg, promise);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            unsafe.flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">            ctx.fireExceptionCaught(cause);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            invokeHandlerAddedIfNeeded();</span><br><span class="line">            ctx.fireChannelRegistered();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            ctx.fireChannelUnregistered();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Remove all handlers sequentially if channel is closed and unregistered.</span></span><br><span class="line">            <span class="keyword">if</span> (!channel.isOpen()) &#123;</span><br><span class="line">                destroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            ctx.fireChannelActive();</span><br><span class="line"></span><br><span class="line">            readIfIsAutoRead();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            ctx.fireChannelInactive();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">            ctx.fireChannelRead(msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            ctx.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">            readIfIsAutoRead();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readIfIsAutoRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (channel.config().isAutoRead()) &#123;</span><br><span class="line">                channel.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> </span>&#123;</span><br><span class="line">            ctx.fireUserEventTriggered(evt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            ctx.fireChannelWritabilityChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到这里实现了入站和出栈顺序.入站是从pipeline的头部开始的.因此这里就是入站的开端.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    ctx.fireChannelRead(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过这个方法,可以看到,当有了可读事件之后,继续调用pipeline中的下一个入站处理器.调用ChannelRead()事件.<br>而出站是从后向前开始传递的.所有的处理器传递write事件,都会向前传递.知道这个头结点.然后执行unsafe.write(msg, promise)方法.这个unsafe就是调用具体的向Channel写数据的类.<br>到这里就能明白了.在我们定义的handler之外的数据是从哪里流入,又是从哪里流出. 从头结点开始读到可读事件开始,开始向后传递,如果一直向后传递会走到尾节点.之后会发出警告,然后释放掉可以释放的对象.<br>当最后执行可写事件之后,会一直向前传递写事件.最终会走到头结点.在调用unsafe.write(msg, promise);来把数据写入socket中.</p><p>到这里就能够明白在pipeline中管道中的数据的最终流向.这个头结点与尾节点就相当于是pipeline中的两个哨兵,为所有的操作都做一个善后工作.   </p><h1 id="pipeline中事件的传播"><a href="#pipeline中事件的传播" class="headerlink" title="pipeline中事件的传播"></a>pipeline中事件的传播</h1><h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p>我们知道pipeline中总会有两个节点,来处理事件的发生.可写事件是我们能够控制的.但是什么时候会调用pipeline中的fireChannelRead来传播可读事件呢.看下面代码.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">    unsafe.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体的调用栈如下图:<br><img src="/2019/05/16/Netty之事件传播机制/调用栈.png" alt></p><p>当有数据可以读取的时候,会调用unsafe.read()方法,去读取其中的内容.看一下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractNioByteChannel</span> <span class="keyword">extends</span> <span class="title">AbstractNioChannel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">NioByteUnsafe</span> <span class="keyword">extends</span> <span class="title">AbstractNioUnsafe</span> </span>&#123;</span><br><span class="line">        ... </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 首先获取到配置</span></span><br><span class="line">            <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">            <span class="keyword">if</span> (shouldBreakReadReady(config)) &#123;</span><br><span class="line">                clearReadPending();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 拿到此Channel对应的pipeline</span></span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">            <span class="comment">// 获取分配器</span></span><br><span class="line">            <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">            allocHandle.reset(config);</span><br><span class="line">            ByteBuf byteBuf = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 创建一个足够小的Buffer,能够接受所有入站数据,不会浪费空间</span></span><br><span class="line">                    byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">                    <span class="comment">// 获取上次操作已经读取的字节.这经常发生在要处理协议的地方. 其中的doREadBytes()则是将字节读取进入byteBuf中</span></span><br><span class="line">                    allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">                    <span class="keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        byteBuf.release();</span><br><span class="line">                        byteBuf = <span class="keyword">null</span>;</span><br><span class="line">                        close = allocHandle.lastBytesRead() &lt; <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                            readPending = <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// </span></span><br><span class="line">                    allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">                    readPending = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 这里调用pipeline传播读取数据操作.</span></span><br><span class="line">                    pipeline.fireChannelRead(byteBuf);</span><br><span class="line">                    byteBuf = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line"></span><br><span class="line">                allocHandle.readComplete();</span><br><span class="line">                pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                    closeOnRead(pipeline);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                handleReadException(pipeline, byteBuf, t, close, allocHandle);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">                    removeReadOp();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码可以看到.就是在这里调用pipeline.fireChannelRead(byteBuf)方法.来传播可读事件进行处理的.接下来就到了,pipeline中的事件传播了.<br>点进去这个方法可以看到以下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelPipeline</span> <span class="keyword">implements</span> <span class="title">ChannelPipeline</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里pipeline的启动读方法,也就是调用头结点的读方法</span></span><br><span class="line">        AbstractChannelHandlerContext.invokeChannelRead(head, msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用这个方法,传入参数为head,这里就会保证首先调用头结点的read方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">"msg"</span>), next);</span><br><span class="line">        EventExecutor executor = next.executor();</span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">            next.invokeChannelRead(m);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    next.invokeChannelRead(m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用头结点的channelRead()方法,开始向下传播</span></span><br><span class="line">                ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                notifyHandlerException(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fireChannelRead(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这就是上面提到的头结点的作用.有可读事件之后,首先调用pipeline的fireChannelRead方法.在方法内部.会继续调用头结点的channelRead()方法.之后通过头结点来向下传播事件.</p><p>也能发现.如果在入站事件,必须得显示调用fireChannelRead(byteBuf)才能够将可读事件继续向后传播.但是这个fireChannelRead()方法又是如何分辨出一个handler是处理入站事件或者处理出站事件的呢.先来看一下代码.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannelHandlerContext</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">        invokeChannelRead(findContextInbound(MASK_CHANNEL_READ), msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextInbound</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ctx = ctx.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((ctx.executionMask &amp; mask) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到首先先通过findContextInbound()方法找见下一个可以处理读事件的处理器.参数为MASK_CHANNEL_READ.这个MASK_CHANNEL_READ又是个什么呢.这个其实就是读事件的标识符.<br>这一系列事件标识符都定义在了ChannelHandlerMask类中.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_ALL_INBOUND = MASK_EXCEPTION_CAUGHT | MASK_CHANNEL_REGISTERED |</span><br><span class="line">        MASK_CHANNEL_UNREGISTERED | MASK_CHANNEL_ACTIVE | MASK_CHANNEL_INACTIVE | MASK_CHANNEL_READ |</span><br><span class="line">        MASK_CHANNEL_READ_COMPLETE | MASK_USER_EVENT_TRIGGERED | MASK_CHANNEL_WRITABILITY_CHANGED;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_ALL_OUTBOUND = MASK_EXCEPTION_CAUGHT | MASK_BIND | MASK_CONNECT | MASK_DISCONNECT |</span><br><span class="line">        MASK_CLOSE | MASK_DEREGISTER | MASK_READ | MASK_WRITE | MASK_FLUSH;</span><br></pre></td></tr></table></figure></p><p>上面的MASK_ALL_INBOUND和MASK_ALL_OUTBOUND就是区分入站和出站的数据的.但是这些常量是如何与pipeline中的handler中结合上的呢.这里就得说到pipeline中添加handler的操作了.在添加handler的时候,通过一系列的调用会到如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化默认的handlerContext</span></span><br><span class="line">DefaultChannelHandlerContext(</span><br><span class="line">        DefaultChannelPipeline pipeline, EventExecutor executor, String name, ChannelHandler handler) &#123;</span><br><span class="line">    <span class="comment">// 调用父类方法</span></span><br><span class="line">    <span class="keyword">super</span>(pipeline, executor, name, handler.getClass());</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor,</span><br><span class="line">                              String name, Class&lt;? extends ChannelHandler&gt; handlerClass) &#123;</span><br><span class="line">    <span class="comment">// 设置名字</span></span><br><span class="line">    <span class="keyword">this</span>.name = ObjectUtil.checkNotNull(name, <span class="string">"name"</span>);</span><br><span class="line">    <span class="comment">// 设置pipeline</span></span><br><span class="line">    <span class="keyword">this</span>.pipeline = pipeline;</span><br><span class="line">    <span class="comment">// 设置响应的执行器</span></span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="comment">// 设置可处理事件</span></span><br><span class="line">    <span class="keyword">this</span>.executionMask = mask(handlerClass);</span><br><span class="line">    <span class="comment">// Its ordered if its driven by the EventLoop or the given Executor is an instanceof OrderedEventExecutor.</span></span><br><span class="line">    ordered = executor == <span class="keyword">null</span> || executor <span class="keyword">instanceof</span> OrderedEventExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向管道中添加handler其实就是向管道中添加一个个的ChannelHandlerContext的过程.在这些Context中包含这处理器.<br>借着调用如下方法.mask().将自己的class类型传进去.来获取自己所能够处理的事件.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelHandlerMask</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mask0</span><span class="params">(Class&lt;? extends ChannelHandler&gt; handlerType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mask = MASK_EXCEPTION_CAUGHT;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ChannelInboundHandler.class.isAssignableFrom(handlerType)) &#123;</span><br><span class="line">                mask |= MASK_ALL_INBOUND;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelRegistered"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_CHANNEL_REGISTERED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelUnregistered"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_CHANNEL_UNREGISTERED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelActive"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_CHANNEL_ACTIVE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelInactive"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_CHANNEL_INACTIVE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelRead"</span>, ChannelHandlerContext.class, Object.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_CHANNEL_READ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelReadComplete"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_CHANNEL_READ_COMPLETE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelWritabilityChanged"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_CHANNEL_WRITABILITY_CHANGED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"userEventTriggered"</span>, ChannelHandlerContext.class, Object.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_USER_EVENT_TRIGGERED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ChannelOutboundHandler.class.isAssignableFrom(handlerType)) &#123;</span><br><span class="line">                mask |= MASK_ALL_OUTBOUND;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"bind"</span>, ChannelHandlerContext.class,</span><br><span class="line">                        SocketAddress.class, ChannelPromise.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_BIND;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"connect"</span>, ChannelHandlerContext.class, SocketAddress.class,</span><br><span class="line">                        SocketAddress.class, ChannelPromise.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_CONNECT;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"disconnect"</span>, ChannelHandlerContext.class, ChannelPromise.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_DISCONNECT;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"close"</span>, ChannelHandlerContext.class, ChannelPromise.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_CLOSE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"deregister"</span>, ChannelHandlerContext.class, ChannelPromise.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_DEREGISTER;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"read"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_READ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"write"</span>, ChannelHandlerContext.class,</span><br><span class="line">                        Object.class, ChannelPromise.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_WRITE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"flush"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_FLUSH;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"exceptionCaught"</span>, ChannelHandlerContext.class, Throwable.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_EXCEPTION_CAUGHT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// Should never reach here.</span></span><br><span class="line">            PlatformDependent.throwException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法应该能看出来,如果你的handler继承的是inboundHandler类的话,mask |= MASK_ALL_INBOUND;就相当与将此掩码设置为处理所有的入站事件.如果是outboundHandler会吃力所有的默认方法. 剩下的isSkippable()方法就是检索是否方法上有skip注解,如果有,则不处理这些事件.<br>下面在来看fireChannelRead(byteBuf)方法的实现.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextInbound</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ctx = ctx.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((ctx.executionMask &amp; mask) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里就是看下一个context是否能够处理此掩码所对应的事件.找到了就返回此Context.在调用此Context的对应方法来处理数据.<br>到这里就应该能明白了管道的传输机制了.<br>因为在添加handler的时候,为持有此handler的context添加了一些可处理事件的掩码.通过此掩码能够找到下一个能够处理此事件的Context.接着着处理此事件.   </p><h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><p>对于出站事件.也就是写数据的事件传播.也有自己的一套.<br>先来看一下最基本的写事件.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture ch1 =  ch.channel().writeAndFlush(Unpooled.copiedBuffer(<span class="string">"abc"</span>.getBytes()));</span><br></pre></td></tr></table></figure></p><p>如果是客户端发起写操作,那么应该会调用这句话.那这个writeAndFlush到底干了什么呢.看下面代码就知道了.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannel</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pipeline.writeAndFlush(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现会调用pipeline的写事件.这里pipeline在启动的时候也已经分析过了,其实就是DefaultChannelPipeline.看一下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelPipeline</span> <span class="keyword">implements</span> <span class="title">ChannelPipeline</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tail.writeAndFlush(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现调用Channel.write()方法其实就是调用pipeline中的尾节点的写数据操作.这里的尾节点就是当初创建pipeline的时候向pipeline中添加的结尾哨兵context. 因此这里就能明白了,不管在什么时候,如果调用的是channel.wirte()方法,数据必定是从尾节点开始向前传播的.<br>明白了Channel.write()的写操作原理,现在再来看一下它是怎么沿着pipeline传播出去的.接着看tail.writeAndFlush()方法.上面说过,这个tail节点是AbstractChannelHandlerContext的子类,这里的write方法就是调用的此父类的方法.看实现代码.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannelHandlerContext</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 开头检验部分删掉了</span></span><br><span class="line">        <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(flush ?</span><br><span class="line">                (MASK_WRITE | MASK_FLUSH) : MASK_WRITE);</span><br><span class="line">        <span class="keyword">final</span> Object m = pipeline.touch(msg, next);</span><br><span class="line">        EventExecutor executor = next.executor();</span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">                next.invokeWriteAndFlush(m, promise);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next.invokeWrite(m, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> AbstractWriteTask task;</span><br><span class="line">            <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">                task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">            &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">                task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!safeExecute(executor, task, promise, m)) &#123;</span><br><span class="line">                <span class="comment">// We failed to submit the AbstractWriteTask. We need to cancel it so we decrement the pending bytes</span></span><br><span class="line">                <span class="comment">// and put it back in the Recycler for re-use later.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// See https://github.com/netty/netty/issues/8343.</span></span><br><span class="line">                task.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看下面这个代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(flush ?</span><br><span class="line">                (MASK_WRITE | MASK_FLUSH) : MASK_WRITE);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextOutbound</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ctx = ctx.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((ctx.executionMask &amp; mask) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个寻找写一个处理出站的context好像和上面的寻找入站事件的有点相似.不过这里确实是一样的.也是通过此掩码来找到下一个处理此事件的context.这里是(MASK_WRITE | MASK_FLUSH)事件.上面也说过了,在添加handler的时候,会根据继承的父类,来判断此handler是否能够处理写事件或者是读事件.    </p><p>继续看这个方法内部<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object m = pipeline.touch(msg, next);</span><br><span class="line">EventExecutor executor = next.executor();</span><br><span class="line"><span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">        next.invokeWriteAndFlush(m, promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.invokeWrite(m, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractWriteTask task;</span><br><span class="line">    <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">        task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">    &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">        task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!safeExecute(executor, task, promise, m)) &#123;</span><br><span class="line">        <span class="comment">// We failed to submit the AbstractWriteTask. We need to cancel it so we decrement the pending bytes</span></span><br><span class="line">        <span class="comment">// and put it back in the Recycler for re-use later.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// See https://github.com/netty/netty/issues/8343.</span></span><br><span class="line">        task.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先调用touch方法,这个方法就是去释放掉这个msg的.这也就是为什么调用了write方法就不需要释放msg引用的原因了. 之后在判断当前线程是否是此executor的执行线程.如果是,则直接唤醒write方法(),接着向下传递.<br>如果不是此线程.则需要新建一个WriteTask,让此executor去执行此写操作.其中也是接着将写操作传递下去.不过是一个在本线程中执行.一个不在本线程中执行.在走到pipeline的head节点之后,回到用unsafe类来执行真正的向socket中写数据.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    unsafe.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</span><br><span class="line">    <span class="keyword">if</span> (outboundBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outboundBuffer.addFlush();</span><br><span class="line">    flush0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里之后会调用NioSocketChannel的doWrite()方法,真正的执行写数据.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioSocketChannel</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(ChannelOutboundBuffer in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取jdk的channel</span></span><br><span class="line">        SocketChannel ch = javaChannel();</span><br><span class="line">        <span class="keyword">int</span> writeSpinCount = config().getWriteSpinCount();</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 如果数据为空之后,则清除SelectionKey上的OPWrite()表示,不然可能会一直轮询,因为有写操作.</span></span><br><span class="line">            <span class="keyword">if</span> (in.isEmpty()) &#123;</span><br><span class="line">                clearOpWrite();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> maxBytesPerGatheringWrite = ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();</span><br><span class="line">            ByteBuffer[] nioBuffers = in.nioBuffers(<span class="number">1024</span>, maxBytesPerGatheringWrite);</span><br><span class="line">            <span class="keyword">int</span> nioBufferCnt = in.nioBufferCount();</span><br><span class="line">            <span class="comment">// 这里看buffer的引用数量</span></span><br><span class="line">            <span class="keyword">switch</span> (nioBufferCnt) &#123;</span><br><span class="line">                <span class="comment">// 如果是0的话</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    writeSpinCount -= doWrite0(in);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果引用为1的话</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                    ByteBuffer buffer = nioBuffers[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> attemptedBytes = buffer.remaining();</span><br><span class="line">                    <span class="comment">// 这里调用ch.write方法,向socket中写数据</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> localWrittenBytes = ch.write(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (localWrittenBytes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        incompleteWrite(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    adjustMaxBytesPerGatheringWrite(attemptedBytes, localWrittenBytes, maxBytesPerGatheringWrite);</span><br><span class="line">                    in.removeBytes(localWrittenBytes);</span><br><span class="line">                    --writeSpinCount;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>: &#123;</span><br><span class="line">                    <span class="keyword">long</span> attemptedBytes = in.nioBufferSize();</span><br><span class="line">                    <span class="comment">// 数量比1大,向socket中写n次.</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> localWrittenBytes = ch.write(nioBuffers, <span class="number">0</span>, nioBufferCnt);</span><br><span class="line">                    <span class="keyword">if</span> (localWrittenBytes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        incompleteWrite(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    adjustMaxBytesPerGatheringWrite((<span class="keyword">int</span>) attemptedBytes, (<span class="keyword">int</span>) localWrittenBytes,</span><br><span class="line">                            maxBytesPerGatheringWrite);</span><br><span class="line">                    in.removeBytes(localWrittenBytes);</span><br><span class="line">                    --writeSpinCount;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (writeSpinCount &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        incompleteWrite(writeSpinCount &lt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里就是写数据的实现了.当然了写数据不只这么简单,但是这篇文章是为了明白pipeline中的事件传播机制.主要是为了明白数据怎么传输,从哪里来,到那里去.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里,Netty中的pipeline中的事件传播机制就分析完了.虽然只分析了读写两个事件.但其实所有的事件都一样.和读写事件的传播是一样的.现在来总结一下最重要的几点    </p><ol><li>handler是保存在context中加入pipeline中的,并且用链表来关联起来</li><li>pipeline中有两大哨兵.headContext和tailContext. 当可读事件发生后,会首先调用head的读方法.之后继续向后传播,当使用channel.write()方法的时候,会使用tail节点的写方法写数据,之后向前传播.写到头结点之后调用unsafe.flush()方法将数据写入socket传入远端. </li><li>Netty中使用很多个掩码来区分入站和出站的事件.对于一个handler是处理出站还是入站方法是在context中包含有一个掩码值,来判断是否能够处理此事件.</li><li>入站事件必须显示的调用fireChannel**()方法才会将数据传播下去.而出站事件不需要.</li><li>ctx.channel().writeAndFlush(msg)和ctx.writeAndFlush(msg),前者是从尾节点向前写数据.后者是从当前位置写数据.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Netty </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty服务端启动分析</title>
      <link href="/2019/05/15/Netty%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/"/>
      <url>/2019/05/15/Netty%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Netty服务端"><a href="#Netty服务端" class="headerlink" title="Netty服务端"></a>Netty服务端</h1><p>大家都知道Netty启动服务端只需要配置好参数,然后调用bind()函数就可以启动了.下面这段代码就是普遍的的Netty中服务器的写法.我们从下面这段开始分析.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bootstrapServer.group(bossGroup,workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">for</span> (ChannelHandler handler : channelHandlers)&#123;</span><br><span class="line">                            ch.pipeline().addLast(handler);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .option(ChannelOption.SO_BACKLOG,<span class="number">1024</span>)</span><br><span class="line">                .option(ChannelOption.SO_RCVBUF,<span class="number">1024</span>)</span><br><span class="line">                .option(ChannelOption.SO_SNDBUF,<span class="number">1024</span>)</span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE,<span class="keyword">true</span>);</span><br><span class="line">ChannelFuture cf = bootstrapServer.bind(port).sync();</span><br></pre></td></tr></table></figure></p><p>本文略长,请耐心解读.本文分为四部分,分为NioServerSocketChannel的创建,初始化,注册和端口绑定四部分,也可以按需浏览.</p><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>从启动开始说起,启动之后,Bootstrap配置的参数才会一一设置到Channel中.从bind()方法说起.<br>bind()可以分为一下几个步骤:</p><ol><li>检查参数合法性,检查的是BootStrap中的设置的合法性,比如说是否有childHandler和childGroup</li><li>调用initAndRegister()方法,初始化和注册NioChannel</li><li>调用newChannel()方法创建Channel. 在newChannel()中初始化Channel和配置各种参数.</li><li>真正的绑定端口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture cf = bootstrapServer.bind(port).sync();</span><br></pre></td></tr></table></figure><p>一般我们就是通过bind()一个端口,然后进行启动服务端的.接下来看一看bind()到底做了什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这一句是检验参数的有效性,比如是否有childHandler 和 childGroup</span></span><br><span class="line">    validate();</span><br><span class="line">    <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"localAddress"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 真正执行bind()操作</span></span><br><span class="line">    <span class="keyword">return</span> doBind(localAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在看doBind()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span>, <span class="title">C</span>&gt;, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">        ...  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有一个initAndRegister方法()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span>, <span class="title">C</span>&gt;, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel = channelFactory.newChannel();</span><br><span class="line">            init(channel);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里可以看到是通过channelFactory来获得一个Channel 的,这个Factory又是个什么呢.其实在Netty默认的是ReflectiveChannelFactory.通过newChannel来获得一个Channel.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveChannelFactory</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">implements</span> <span class="title">ChannelFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里就是通过反射获得一个Channel</span></span><br><span class="line">            <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Unable to create Channel from class "</span> + constructor.getDeclaringClass(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是这个Factory是什么时候来的呢? 我们知道在我们配置BootStrap的时候我们会设置一个Channel的参数,如下面这个样子调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.channel(NioServerSocketChannel.class)</span><br></pre></td></tr></table></figure></p><p>这里设置了NioServerSocketChannel. 所以这里constructor其实就是一个NioServerSocketChannel的类型.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span>, <span class="title">C</span>&gt;, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (channelClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"channelClass"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里也就是将 channelFactory设置为ReflectiveChannelFactory.</span></span><br><span class="line">        <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(channelClass));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以也就很清晰明了了.这个channelFactory的由来.是通过上面传入的channel的参数来建立的.</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>上面说到newChannel()来看一下newChannel()是怎么创建一个Channel的<br>如果按照调用顺序最后一直点进去会发现一个语句,也就是newSocket方法.<br>这里创建ServerSocketChannel也有几步要走,总结一下如下:</p><ol><li>首先通过SelectorProvider创建一个ServerSocketChannel</li><li>根据ServerSocketChannel初始化和创建Netty封装的NioServerSocketChannel</li><li>初始化NioServerSocketChannelConfig配置参数.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServerSocketChannel</span></span>&#123;</span><br><span class="line">    <span class="comment">// 这里调用Jdk中的SelectorProvider</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();</span><br><span class="line">    <span class="comment">// 通过调用newSocket来返回一个JDK的ServerSocketChannel.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用SelectorProvider返回一个SocketChannel</span></span><br><span class="line">            <span class="keyword">return</span> provider.openServerSocketChannel();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(</span><br><span class="line">                    <span class="string">"Failed to open a server socket."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面提到factory调用newInstance来初始化NioServerSocket. 调用默认构造方法.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先调用newSocket()创建ServerSocketChannel,接着根据此Channel初始化NioServerSocketChannel.</span></span><br><span class="line">        <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里可以看是有JDK的身影,就是OP_ACCEPT,但是这里的OP_ACCEPT并不是马上就注册到选择器上的.这里只是初始化感兴趣事件而已.具体的注册函数在绑定操作实现的.之后在继续初始化channel,设置为非阻塞</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">// 初始化NioServerSocketChannelConfig</span></span><br><span class="line">        config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>再向深入了解,也就是上面的super()调用的方法就可以看到:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="keyword">this</span>.ch = ch;</span><br><span class="line">    <span class="comment">// 设置感兴趣的事件</span></span><br><span class="line">    <span class="keyword">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ch.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(</span><br><span class="line">                        <span class="string">"Failed to close a partially initialized socket."</span>, e2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Failed to enter non-blocking mode."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先将channel赋值,然后在设置感兴趣的事件.之后再设置为非阻塞.</p><p>之后再看parent方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannel</span> <span class="keyword">extends</span> <span class="title">DefaultAttributeMap</span> <span class="keyword">implements</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        id = newId();</span><br><span class="line">        unsafe = newUnsafe();</span><br><span class="line">        pipeline = newChannelPipeline();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里就是真正的设置Channel的参数.前面说过,每一个Channel都会有一个ChannelPipeline()于之相关联,并且会有一个Id.这里就是创建它们的地方.而这个unsafe 是用来实现I/O传输的.</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>到了这里基本上服务器Channel的创建就有了一个直观的了解.<br>现在再来看一下initAndRegister()方法中init()方法,这就是初始化ServerChannel的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span>, <span class="title">C</span>&gt;, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里刚才讲过了是创建了一个channel. 但是大致参数都没有配置,这里就是配置的过程.</span></span><br><span class="line">            channel = channelFactory.newChannel();</span><br><span class="line">            <span class="comment">// 这里的init()方法就是配置的过程.</span></span><br><span class="line">            init(channel);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                channel.unsafe().closeForcibly();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">        <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel.unsafe().closeForcibly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerBootstrap</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">        <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">            <span class="comment">// 这里是设置Channel的Option参数.</span></span><br><span class="line">            setChannelOptions(channel, options, logger);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">        <span class="comment">// 设置Attr值</span></span><br><span class="line">        <span class="keyword">synchronized</span> (attrs) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class="line">                channel.attr(key).set(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ChannelPipeline p = channel.pipeline();</span><br><span class="line">        <span class="comment">// 接下来就是设置childChannel的参数了.childChannel的参数也就是为新建的SocketChannel设置的参数.</span></span><br><span class="line">        <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">        <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">        <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">        <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class="line">        <span class="comment">// 获得选项参数</span></span><br><span class="line">        <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">            currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取附加的值</span></span><br><span class="line">        <span class="keyword">synchronized</span> (childAttrs) &#123;</span><br><span class="line">            currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对管道进行处理.为管道添加处理器.这里添加的处理器是为父类的.</span></span><br><span class="line">        p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                ChannelHandler handler = config.handler();</span><br><span class="line">                <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pipeline.addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最后进行对管道的处理,向管道中添加config的一些handler.<br>最后再异步想管道中添加一个处理程序也就是ServerBootstrapAcceptor. 将设置好的child的所有参数都传输进去.<br>group,handler,option,attrs等.</p><p>接下来看一下ServerBootstrapAcceptor类,这是ServerBootstrap的内部类.通过上面可以看到.这个Acceptor被添加到管道的最后一个位置.所以消息到这里通过前面一系列的处理,已经是一个Channel.这个时候就需要将Channel注册到childGroup中.<br>可以分为一下几步:    </p><ol><li>复写父类的channelRead()方法,监听连接事件</li><li>当有新连接到来的时候,调用channelRead()方法,获取新建立的channel.</li><li>为这个新建的channel配置参数,包括选项,pipeline中的处理器</li><li>将此Channel注册到childGroup中,监听事件.</li></ol><p>这个类不长,稍微看一看就能理解大概了.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerBootstrapAcceptor</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup childGroup;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler childHandler;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Runnable enableAutoReadTask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化,将child的参数都设置好,并且保存好</span></span><br><span class="line">        ServerBootstrapAcceptor(</span><br><span class="line">                <span class="keyword">final</span> Channel channel, EventLoopGroup childGroup, ChannelHandler childHandler,</span><br><span class="line">                Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions, Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs) &#123;</span><br><span class="line">            <span class="keyword">this</span>.childGroup = childGroup;</span><br><span class="line">            <span class="keyword">this</span>.childHandler = childHandler;</span><br><span class="line">            <span class="keyword">this</span>.childOptions = childOptions;</span><br><span class="line">            <span class="keyword">this</span>.childAttrs = childAttrs;</span><br><span class="line">            enableAutoReadTask = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="comment">// 这里设置自动读取</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    channel.config().setAutoRead(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 覆写Read()事件,在这个方法中,将新建立的连接添加到childGroup中.</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line">            <span class="comment">// 为新建的连接添加childHandler()处理器.</span></span><br><span class="line">            child.pipeline().addLast(childHandler);</span><br><span class="line">            setChannelOptions(child, childOptions, logger);</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class="line">                child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将此Channel注册到childGroup上.</span></span><br><span class="line">                childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="comment">//  添加回调函数,如果失败,则关闭.</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                            forceClose(child, future.cause());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                forceClose(child, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forceClose</span><span class="params">(Channel child, Throwable t)</span> </span>&#123;</span><br><span class="line">            child.unsafe().closeForcibly();</span><br><span class="line">            logger.warn(<span class="string">"Failed to register an accepted channel: &#123;&#125;"</span>, child, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelConfig config = ctx.channel().config();</span><br><span class="line">            <span class="keyword">if</span> (config.isAutoRead()) &#123;</span><br><span class="line">                config.setAutoRead(<span class="keyword">false</span>);</span><br><span class="line">                ctx.channel().eventLoop().schedule(enableAutoReadTask, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            ctx.fireExceptionCaught(cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>到这里初始化就基本完成了.初始化完成就应该到注册了.</p><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>上面初始化完成之后就要调用注册方法,也就是要将此ServerChannel注册到Selector上.在看一下initAndRegister方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span>, <span class="title">C</span>&gt;, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在init()初始化Channel之后有这么一段代码,可以看出来就是将channel注册到Selector上的.继续点进去之后会发现以下代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannel</span> <span class="keyword">extends</span> <span class="title">DefaultAttributeMap</span> <span class="keyword">implements</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (eventLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"eventLoop"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否已经注册过了</span></span><br><span class="line">            <span class="keyword">if</span> (isRegistered()) &#123;</span><br><span class="line">                promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">"registered to an event loop already"</span>));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</span><br><span class="line">                promise.setFailure(</span><br><span class="line">                        <span class="keyword">new</span> IllegalStateException(<span class="string">"incompatible event loop type: "</span> + eventLoop.getClass().getName()));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line">            <span class="comment">// 这里主要是看当前线程是否是EventLoop中Channel绑定的线程.如果是,直接调用,如果不是,则异步调用</span></span><br><span class="line">            <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">                register0(promise);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            register0(promise);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(</span><br><span class="line">                            <span class="string">"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;"</span>,</span><br><span class="line">                            AbstractChannel.<span class="keyword">this</span>, t);</span><br><span class="line">                    closeForcibly();</span><br><span class="line">                    closeFuture.setClosed();</span><br><span class="line">                    safeSetFailure(promise, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里就是真正的注册逻辑.首先判断eventLoop是否为空,在判断是否已经注册过了. 接着看这一句:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br></pre></td></tr></table></figure></p><p>这里就是将此Channel绑定到此EventLoop上.这个EventLoop也就是当初我们调用方法b.group(bossGroup, workerGroup)中的bossGroup中的一个eventLoop.在Netty中,一个EventLoop包含多个Channel.而每个Channel的事件都是由同一个EventLoop来执行的. 这里就是执行真正的绑定操作. 再向下走会执行register0()方法.来看一下register0()方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">                <span class="comment">// 真正的执行注册方法的地方</span></span><br><span class="line">                doRegister();</span><br><span class="line">                neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">                registered = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒并且传播handlerAdd</span></span><br><span class="line">                pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">                safeSetSuccess(promise);</span><br><span class="line">                <span class="comment">// 传播ChannelRegistered()方法</span></span><br><span class="line">                pipeline.fireChannelRegistered();</span><br><span class="line">                <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                        pipeline.fireChannelActive();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                        beginRead();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                closeForcibly();</span><br><span class="line">                closeFuture.setClosed();</span><br><span class="line">                safeSetFailure(promise, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>这里又做了几件事情.</p><ul><li>doRegister()就是调用jdk的register方法进行注册.并且把NioServerSocketChannel自己作为attachment添加进去.</li><li>调用pipeline.invokeHandlerAddedIfNeeded(); 也就是唤醒HandlerAdd()事件.就是普通复写的handlerAdded()事件将会被触发.</li><li>pipeline.fireChannelRegistered();传播事件,这里传播Registered()事件.<br>这里应该就是在刚刚注册好的时候判断一下是否有连接到达.如果有,并且是第一次连接,就传播此事件.</li></ul><p>再来看一下doRegister()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里就是真正执行注册的地方.</span></span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">                eventLoop().selectNow();</span><br><span class="line">                selected = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// We forced a select operation on the selector before but the SelectionKey is still cached</span></span><br><span class="line">                <span class="comment">// for whatever reason. JDK bug ?</span></span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面javaChannel()也就是java中的channel,第一个参数就是此eventLoop中的selector选择器.0代表不监听任何事件.再讲自己作为attachment传进去.当下一次获得事件的时候可以直接把此NioServerSocketChannel拿出来用,然后做一些事件传播.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invokeHandlerAddedIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> channel.eventLoop().inEventLoop();</span><br><span class="line">        <span class="comment">// 如果是第一次调用,肯定为true</span></span><br><span class="line">        <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">            firstRegistration = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// We are now registered to the EventLoop. It's time to call the callbacks for the ChannelHandlers,</span></span><br><span class="line">            <span class="comment">// that were added before the registration was done.</span></span><br><span class="line">            callHandlerAddedForAllHandlers();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看官方的注释,就是说在整个注册过程还没有全部完成之前应该先回调ChannelHandlers中的handlerAdd()方法.所以就是在这里回调我们的复写的handlerAdd()方法的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRegistered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext.invokeChannelRegistered(head);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在这里调用毁掉我们的Register方法.所以handlerAdd事件是发生在register事件之前的.</p><p>到这里整个注册过程应该就明了了. 在总结一下:</p><ol><li>将此ServerSocketChannel绑定到对应的eventLoop上</li><li>执行注册操作</li><li>调用jdk中的注册方法,将javaChannel注册到Selector上,并且将对应的NioServerSocketChannel作为attachment添加上去</li><li>回调handler中handlerAdd()方法和register()方法</li><li>注册完成.返回,继续执行绑定操作</li></ol><p>注意,这里注册完成之后,Channel并没有完成绑定操作,也就是说,注册在Selector上的Channel并没有绑定端口.</p><h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><p>在一系列的准备工作完成之后,就是真正执行绑定操作的时候了.到这里initAndRegister方法算是结束了. 在来看一下doBind()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span>, <span class="title">C</span>&gt;, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">        <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> regFuture;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">            ChannelPromise promise = channel.newPromise();</span><br><span class="line">            doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Registration future is almost always fulfilled already, but just in case it's not.</span></span><br><span class="line">            <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">            regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    Throwable cause = future.cause();</span><br><span class="line">                    <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span></span><br><span class="line">                        <span class="comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span></span><br><span class="line">                        promise.setFailure(cause);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Registration was successful, so set the correct executor to use.</span></span><br><span class="line">                        <span class="comment">// See https://github.com/netty/netty/issues/2586</span></span><br><span class="line">                        promise.registered();</span><br><span class="line"></span><br><span class="line">                        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到,在这里又有一个回调,因为在Netty中都是异步执行的,所以初始化和Register也都是异步执行的.所以这里会先判断是否已经初始化和注册完成.如果完成,直接调用这个doBind0()方法,如果没有完成,添加一个监听事件,在完成之后调用doBind0()方法.<br>在来看一下doBind0()方法都做了什么事情<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span>, <span class="title">C</span>&gt;, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里也是异步执行bind操作,是调用的channel的bind()方法的.这里的channel也就是传入的Channel的类型.</span></span><br><span class="line">        channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                    channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.setFailure(regFuture.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再向调用栈的深处走,这个bind()方法会调用AbstractChannel中的内部类AbstractUnsafe的bind()方法,也就是如下的方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractUnsafe</span> <span class="keyword">implements</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            assertEventLoop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;</span><br><span class="line">                localAddress <span class="keyword">instanceof</span> InetSocketAddress &amp;&amp;</span><br><span class="line">                !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;</span><br><span class="line">                !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123;</span><br><span class="line">                logger.warn(</span><br><span class="line">                        <span class="string">"A non-root user can't receive a broadcast packet if the socket "</span> +</span><br><span class="line">                        <span class="string">"is not bound to a wildcard address; binding to a non-wildcard "</span> +</span><br><span class="line">                        <span class="string">"address ("</span> + localAddress + <span class="string">") anyway as requested."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                doBind(localAddress);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                safeSetFailure(promise, t);</span><br><span class="line">                closeIfClosed();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">                invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        pipeline.fireChannelActive();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            safeSetSuccess(promise);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现这里会调用doBind()方法,这个doBind()方法就是我们bind()方法的真正实现了.也就是在我们为bootstrap配置的Channel的bind()方法.这里调用的是NioServerSocketChannel的doBind()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServerSocketChannel</span> <span class="keyword">extends</span> <span class="title">AbstractNioMessageChannel</span></span></span><br><span class="line"><span class="class">                             <span class="keyword">implements</span> <span class="title">io</span>.<span class="title">netty</span>.<span class="title">channel</span>.<span class="title">socket</span>.<span class="title">ServerSocketChannel</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">            javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到,这里就是将javaChannel()方法绑定到本地的某个端口上.这里就是调用的jdk的bind()方法来绑定端口和地址的.<br>然后再Unsafe的bind()方法的最后,这里是要传播Active()事件. 不知道大家发现没有,在刚才注册的阶段,并没有channel并没有注册感兴趣的事件,而是没有感兴趣的事件.下面在看到底在哪里注册感兴趣的事件.就是在这个fireChannelActive中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannel</span> <span class="keyword">extends</span> <span class="title">DefaultAttributeMap</span> <span class="keyword">implements</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再向下走,会调用pipeline中的头结点的channelActive()方法,关于这个头结点可以理解为pipeline中的出入口.所有从出入管道的数据都要走这里.这里也应该是传播读事件的开端.具体的可以看另一篇文章. 这里要传播active方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelPipeline</span> <span class="keyword">implements</span> <span class="title">ChannelPipeline</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadContext</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerContext</span> </span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span>, <span class="title">ChannelInboundHandler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            ctx.fireChannelActive();</span><br><span class="line"></span><br><span class="line">            readIfIsAutoRead();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里,有两件事情要做.</p><ol><li>传播Active事件</li><li>注册accept事件.</li></ol><p>传播Active事件都不说了,和上面传播handlerAdd事件一样.重点说一下注册accept事件.从readIfAutoRead()方法开始<br>最终会调用到AbstractNioChannel的doBeginRead()方法上.调用堆栈如下:<br><img src="/2019/05/15/Netty服务端启动分析/调用堆栈.png" alt><br>下面看一下doBeginRead()方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractNioChannel</span> <span class="keyword">extends</span> <span class="title">AbstractChannel</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">        <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">        <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        readPending = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">        <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">            selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里调用doBeginRead()方法,我们刚开始的时候说过,将Channel注册到Selector上的时候,并没有感兴趣的时间.因此这里的interestOps应该为0,但是我们在创建NioServerSocketChannel()的时候,Netty中的Channel是有传入过要注册事件的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里想就向这个AbstractNioChannel的readInterestOp赋值,注意,这里的readInterestOp是感兴趣的事件,并不是读事件.也就是感兴趣事件为接受连接.所以上面的代码就容易理解了.就是将新建的NioServerSocketChannel的刚兴趣的事件真正绑定到javaChannel上去.到这里.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>服务端启动其实就类似与平时我们编写NIO的方式,不过就是为我们做好了很多封装.我们只需要配置好参数,并且写好业务逻辑就好了,不需要我们去管理连接的Channel.极大的简化了我们的编程. 这里在做一下启动过程的大致流程的总结.</p><h2 id="配置属性"><a href="#配置属性" class="headerlink" title="配置属性"></a>配置属性</h2><ol><li>首先有两个EventLoopGroup,一个为parent,用来监听连接事件,一个为child,用来监听已经建立好的Channel的事件.   </li><li>设置Channel的类型,是NIO还是OIO或者是AIO</li><li>设置parentChannel的选项参数,</li><li>设置childHandler.为建立好的连接添加处理器</li><li>设置childOption选项</li></ol><h2 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h2><ol><li>调用bind()方法启动服务器.</li><li>新建一个Channel(这个时候也会初始化此Channel的Pipeline)</li><li>初始化Channel</li><li>将Channel注册上去,并且将NioSelectorChannel作为attachment添加上去</li><li>绑定端口,为channel添加感兴趣事件.</li></ol><p>到这里就算完成了.整个Netty服务端的启动过程就大致明了了.</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Netty </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty基本使用</title>
      <link href="/2019/05/15/Netty%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/05/15/Netty%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><p>Netty就是封装了JDK的NIO网络库。用官网的话说是，Netty是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能服务器和客户端。</p><h2 id="为什么使用Netty而不用jdk"><a href="#为什么使用Netty而不用jdk" class="headerlink" title="为什么使用Netty而不用jdk"></a>为什么使用Netty而不用jdk</h2><ol><li>JDK中使用的话需要对NIO编程有足够的了解，编程也比较复杂，不小心就会出现很多bug</li><li>Netty底层的I/O模型可以随意更换，而不需要改变太多的代码，只需要改一些参数就可以了。</li><li>Netty解决了jdk的一些bug，比如select空轮询导致cpu100</li><li>Netty自带拆包解包，异常检测机制，可以让用户只关心业务逻辑</li><li>自带很多协议栈，比如http协议，google的protobuf协议</li></ol><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>首先如果想要使用Netty，建议首先要了解一下NIO网络编程，可以不熟悉，但是一定要了解。对理解起来会有帮助.<br>首先看一下服务端怎么实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先定义两个事件循环组,一个是用来接受新建连接,一个用来处理已经建立好的连接</span></span><br><span class="line"><span class="keyword">int</span> port = <span class="number">9999</span>;</span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 是一个启动 Nio服务器的一个辅助类,可以在这个服务中直接使用Channel</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ServerBootstrap boot = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        <span class="comment">// 将这两个 事件循环组加进去</span></span><br><span class="line">        boot = boot.group(bossGroup,workerGroup)</span><br><span class="line">                <span class="comment">// 设置为NIO模式</span></span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">// 设置事件处理程序</span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 这里添加的类是真正处理业务逻辑的类</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> DiscardServerHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 指定实现的通道实现的配置参数,这里是TCP/IP服务器</span></span><br><span class="line"><span class="comment">                 * 所以允许设置Socket的参数选项比如tcpNodeloy,keepAlive</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * SO_BACKLOG 是一个数量设置</span></span><br><span class="line"><span class="comment">                 * 在linux内核中,有两个队列,一个是正在连接队列,一个是已经连接队列</span></span><br><span class="line"><span class="comment">                 * SO_BACKLOG 是设置这个缓冲区大小的,也就是这两个队列的大小</span></span><br><span class="line"><span class="comment">                 * 设置的值为两个队列最大能接受的值,当两个队列的大小超过这个值,新来的连接将会被抛弃</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>)<span class="comment">// 设置tcp缓冲区大小</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * option()是提供个NioServerSocketChannel用来接受进来的连接</span></span><br><span class="line"><span class="comment">                 * childOption()是提供给由父管道ServerChannel接受到的连接.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE,<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//  调用bind()方法启动服务器,sync()就是异步调用.变为后台线程.</span></span><br><span class="line">        ChannelFuture f = boot.bind(port).sync();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里一直会等待,知道socket关闭</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// Thread.sleep(Integer.MAX_VALUE)</span></span><br><span class="line">        <span class="comment">// 相当于阻塞进程.</span></span><br><span class="line">        f.channel().closeFuture().sync();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 关闭</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只需要这些代码就可以建立好一个服务器,当然了,还需要写一个实现业务逻辑,就是说要写一个Handler,这里我们实现一个最简单的网络程序,也就是接收到数据什么都不做,只是简单的打印出来.下面看Handler的实现.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在有数据可以读取的时候调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteBuf in = (ByteBuf)msg;</span><br><span class="line">            System.out.println(in.toString(CharsetUtil.UTF_8));</span><br><span class="line">           </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发生异常时候调用,关闭连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当出现Throwable对象的时候,当netty抛异常时候调用此方法,可以在其中设置异常逻辑,比如发送错误码</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面可以很清除的看到覆盖了父类的方法.channelRead(). 上面说过Netty是事件驱动的框架.这里就体现出来了.当socket可读的时候就会调用此方法,这里不执行任何逻辑,只是简单的丢弃.所以说它是异步的事件驱动的.</p><p>之后就可以运行服务器.然后用telnet访问本地的9999端口就可以发送消息.</p><p>到这里一个简单的服务器就搭建好了.  接下来再详细讲解一下其中各个组件的功能与作用.</p><h2 id="BootStrap"><a href="#BootStrap" class="headerlink" title="BootStrap"></a>BootStrap</h2><p>这是一个引导类,通过设置BootStrap类的开始,该类提供了一个用于应用程序网络层的配置容器</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>底层网络传输api必须提供给应用I/O操作接口,Netty自己对JDK的channel进行了进一步的封装,使得网络编程有更好的可扩展性. Channel 定义了与 socket 丰富交互的操作集：bind, close, config, connect, isActive, isOpen, isWritable, read, write 等等。</p><h2 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h2><p>ChannelHandler支持很多种协议,并且提供用于进行数据处理的地方.ChannelHandler由特定的一些事件触发,触发之后会调用不同的方法,用户只需要自己实现ChannelHandler的一些方法就好了.当然实际编程中一般应该实现ChannelInboundHandlerAdapter和ChannelOutboundHandlerAdapter类,这两个类已经默认实现了ChannelHandler的方法.用户只需要在复写自己感兴趣的事件,然后进行处理就可以了.</p><h2 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h2><p>ChannelPipeline提供了一个容器ChannelHandler链,并提供了一个API用于管理沿着这条链进行的入站和出站的事件流动.每一个Channel都有自己的ChannelPipeline.是在创建Channel的时候自动创建ChannelPipeline的.  ChannelHandler 是如何安装在 ChannelPipeline？ 主要是实现了ChannelHandler 的抽象 ChannelInitializer。ChannelInitializer子类 通过 ServerBootstrap 进行注册。当它的方法 initChannel() 被调用时，这个对象将安装自定义的 ChannelHandler 集到 pipeline。当这个操作完成时，ChannelInitializer 子类则 从 ChannelPipeline 自动删除自身。</p><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>EventLoop用于处理Channel的I/O操作,一个单一的EventLoop通常会处理多个Channel事件.</p><h2 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h2><p>因为Netty中所有的事件都是异步的,因为一个操作无法立即返回,这个时候就有了ChannelFuture能够在之后确定它的结果.ChannelFuture的addListener()方法可以添加注册事件,当操作完成之后会被通知.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面是对Netty的一个最基本的认识.总之Netty是一个强大的基于事件驱动的一个网络编程框架,使用它能够很好的建立一个稳定的网络应用程序.</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Netty </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-RMI</title>
      <link href="/2019/05/08/java-RMI/"/>
      <url>/2019/05/08/java-RMI/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>RMI:远程方法调用(Remote Method Invocation),是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口.它使得客户机上的运行的程序能够调用远程服务器上的对象的对象.此远程调用特性就是为了能够在网络环境中分布操作.RMI就是简化了远程调用.  </p><p>RPC:远程过程调用,是在分布式中常用到的一个协议,此协议就是能够让调用远程对象如同调用本地对象一样,RMI就是其实现方式的一种,当然了,还有很多中实现方式,比如说rest方式等等.现在主要说一下RMI方式;</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h2><p><img src="/2019/05/08/java-RMI/RMI调用.jpg" alt>  </p><p>RMI主要由三个部分组成:</p><ul><li>registry(JDK提供的一个可独立运行的程序) </li><li>server程序,对外提供远程调用的服务对象</li><li>client 调用server提供的服务</li></ul><p>首先，先启动registry服务，启动时可以指定服务监听的端口，也可以使用默认的端口（1099）</p><p>其次，server端在本地先实例化一个提供服务的实现类，然后通过RMI提供的Naming/Context/Registry（下面实例用的Registry）等类的bind或rebind方法将刚才实例化好的实现类注册到registry上并对外暴露一个名称。</p><p><img src="/2019/05/08/java-RMI/stuc.png" alt></p><p>最后，client端通过本地的接口和一个已知的名称（即registry暴露出的名称）再使用RMI提供的Naming/Context/Registry等类的lookup方法从RMIService那拿到实现类,其实是RMI系统生成的stub存根代理。这样虽然本地没有这个类的实现类，但所有的方法都在接口里了，便可以实现远程调用对象的方法了.</p><p><img src="/2019/05/08/java-RMI/stub.jpg" alt><br>通信过程大致是这样,server端提供服务后会有一个skeleton骨干网,client调用者调用lookup方法会返回一个存根,通过此存根与server通信,调用远程的方法. 方法经过存根(stub),远程调用层,再到传输层,最后在到skeleton,通过skeleton调用实例方法,之后在将结果按照原路返回.<br>而这个stub和skeleton代理都是由RMI系统动态生成的.服务端只需要继承UnicastRemoteObject接口就可以了.这些底层细节是不需要我们去关心的.这就是它的强大之处.</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h2><p>首先必须有一个暴露的接口,这个接口在server和client中都得有,因为需要这个接口去调用方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.spj.rmidemo.bean.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserManage</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getUserName</span><span class="params">()</span><span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">getUser</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其次得server实现这个接口的具体方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里需要继承UnicastRemoteObject类,来允许jvm创建存根和代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserManageImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">UserManage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">UserManageImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"spj"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span><span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"spj"</span>,<span class="string">"123"</span>,<span class="number">21</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里就可以使用一个方法来暴露这个服务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所要暴露的对象</span></span><br><span class="line">        UserManage userManage = <span class="keyword">new</span> UserManageImpl();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个本地的注册中心,绑定端口2002</span></span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">2002</span>);</span><br><span class="line">        <span class="comment">// 这里能够使用Naming.rebind绑定对象或者使用registry.bind()暴露对象</span></span><br><span class="line">        <span class="comment">//Naming.rebind("rmi://127.0.0.1:2002/UserManageService",userManage);</span></span><br><span class="line">        registry.bind(<span class="string">"userManage"</span>,userManage);</span><br><span class="line">        System.out.println(<span class="string">"server is ready!"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>服务端的程序就写好了,而客户端可以没有这个实现类,也就是没有接口的实现类,就可以调用方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(<span class="number">2002</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// lookup方法参数为服务器绑定是设置的访问名称.</span></span><br><span class="line">            UserManage userManage = (UserManage)registry.lookup(<span class="string">"userManage"</span>);</span><br><span class="line">            <span class="comment">// 这里可以向调用本地方法一样调用远程方法.</span></span><br><span class="line">            System.out.println(userManage.getUser());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">User&#123;name=<span class="string">'spj'</span>, psss=<span class="string">'123'</span>, age=<span class="number">21</span>&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><p><a href="https://blog.csdn.net/qq_28081453/article/details/83279066" target="_blank" rel="noopener">https://blog.csdn.net/qq_28081453/article/details/83279066</a><br><a href="https://blog.csdn.net/xinghun_4/article/details/45787549" target="_blank" rel="noopener">https://blog.csdn.net/xinghun_4/article/details/45787549</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo踩坑教训</title>
      <link href="/2019/05/04/dubbo%E8%B8%A9%E5%9D%91%E6%95%99%E8%AE%AD/"/>
      <url>/2019/05/04/dubbo%E8%B8%A9%E5%9D%91%E6%95%99%E8%AE%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章主要总结一下自己踩过的dubbo的坑,因为不管是在配置的时候或者说调用的时候都会出现很多问题,碰到过很多坑,特此总结一下.持续更新.<br>说明一下,这里使用的dubbo是apache旗下的,不是alibaba旗下的.</p><h2 id="dubbo-配置消费方显示端口已经占用"><a href="#dubbo-配置消费方显示端口已经占用" class="headerlink" title="dubbo 配置消费方显示端口已经占用"></a><strong>dubbo 配置消费方显示端口已经占用</strong></h2><p>错误如下 :<br><img src="/2019/05/04/dubbo踩坑教训/2019-05-04&#32;18-55-29屏幕截图.png" alt><br>这个原因是因为在默认配置的情况下使用的qos端口号都是22222.但是在消费方想要用这个端口的时候,服务提供方已经占用了,这个时候就需要去配置一下qos来实现部署的.</p><p>qos就是Dubbo的在线运维命令. 可以对服务进行动态的配置,控制以及查询.</p><p>具体配置如下:     </p><h3 id="使用dubbo-properties文件进行配置"><a href="#使用dubbo-properties文件进行配置" class="headerlink" title="使用dubbo.properties文件进行配置"></a>使用dubbo.properties文件进行配置</h3><p>加上一下属性就好了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dubbo.application.qos.enable=<span class="keyword">true</span></span><br><span class="line">dubbo.application.qos.port=<span class="number">33333</span></span><br><span class="line">dubbo.application.qos.accept.foreign.ip=<span class="keyword">false</span></span><br></pre></td></tr></table></figure></p><h3 id="使用XML进行配置"><a href="#使用XML进行配置" class="headerlink" title="使用XML进行配置"></a>使用XML进行配置</h3><p>将其中一方的qos端口设置为没有被占用的任何一个就可以了.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-provider"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"qos.enable"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"qos.accept.foreign.ip"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"qos.port"</span> <span class="attr">value</span>=<span class="string">"33333"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="使用springboot自动装配方式"><a href="#使用springboot自动装配方式" class="headerlink" title="使用springboot自动装配方式"></a>使用springboot自动装配方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dubbo.application.qosEnable=<span class="keyword">true</span></span><br><span class="line">dubbo.application.qosPort=<span class="number">33333</span></span><br><span class="line">dubbo.application.qosAcceptForeignIp=<span class="keyword">false</span></span><br></pre></td></tr></table></figure><h2 id="com-alibaba-com-caucho-hessian-io-HessianProtocolException-无法反序列化问题"><a href="#com-alibaba-com-caucho-hessian-io-HessianProtocolException-无法反序列化问题" class="headerlink" title="com.alibaba.com.caucho.hessian.io.HessianProtocolException 无法反序列化问题"></a><strong>com.alibaba.com.caucho.hessian.io.HessianProtocolException 无法反序列化问题</strong></h2><p>这个原因也有,这原因主要是因为Hessian的序列化的方式的问题.<br>dubbo是采用Hessian（比jdk自带反序列化高效）进行反序列化的，该反序列化创建对象时，会取参数最少的构造方法来创建对象，构造方法参数设置默认值，基本类型设置为相应基本类型的默认值，不是基本类型设置为null.所以这里就会出现null对象,导致无法被序列化.<br>只要在序列化对象上添加一个无参构造方法就好了.当然如果没有自定义的构造方法,会有默认的构造方法,所以也不会出错.</p><h2 id="dubbo-显示两个重复的配置"><a href="#dubbo-显示两个重复的配置" class="headerlink" title="dubbo 显示两个重复的配置"></a><strong>dubbo 显示两个重复的配置</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Duplicate application configs: &lt;dubbo:application valid=<span class="string">"true"</span> name=<span class="string">"demo-provider"</span> prefix=<span class="string">"dubbo.application"</span> id=<span class="string">"demo-provider"</span> /&gt; and &lt;dubbo:application owner=<span class="string">"debug"</span> valid=<span class="string">"true"</span> organization=<span class="string">"dubbox"</span> name=<span class="string">"dubboOne-consume"</span> prefix=<span class="string">"dubbo.application"</span> id=<span class="string">"dubboOne-consume"</span> /&gt;</span><br></pre></td></tr></table></figure><p>这个是因为一个应用要求只有一个application配置,这个问题我觉得可能是出现在自己不是很了解的情况下,一个应用配置了两个application. 向我刚开始一样:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://dubbo.apache.org/schema/dubbo</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"$&#123;dubbo.registry.address&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"rest"</span> <span class="attr">threads</span>=<span class="string">"500"</span> <span class="attr">contextpath</span>=<span class="string">"v1"</span> <span class="attr">server</span>=<span class="string">"tomcat"</span> <span class="attr">accepts</span>=<span class="string">"500"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--看这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-provider"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"dubboOne-consume"</span> <span class="attr">owner</span>=<span class="string">"debug"</span> <span class="attr">organization</span>=<span class="string">"dubbox"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这里配置了两个application.导致出错了.只需要删掉其中一个就好了.这个时候就又有人问了.这么配置的主要原因就是为了一个应用即充当提供方有当消费方.   这里就需要另外一个配置了.<br>参考官方文档:  提供方提供配置的时候.需要用到 dubbo:service 来进行接口暴露.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>消费方使用服务的时候需要用到reference配置来使用:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.DemoService"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>所以当一个应用即充当消费方又是服务提供方不需要配置两个application.只需要配置好要引用的rpc服务和自己所需要暴露的接口就好了.</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo配置过程</title>
      <link href="/2019/05/03/dubbo%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/05/03/dubbo%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="dubbo"><a href="#dubbo" class="headerlink" title="dubbo"></a>dubbo</h1><h2 id="dubbo背景"><a href="#dubbo背景" class="headerlink" title="dubbo背景"></a>dubbo背景</h2><p>在如今设备配置已经到达极限的时候,则需要进行分布式进行处理,将一些应用功能分开管理,但是又必须得互相有沟通,可以通过简单的接口暴露和RPC引用远程服务,通过配置URL地址进行调用,通过F5等硬件进行负载均衡.但是当应用服务规模再进一步扩大的情况下,如果只是简单的通过RMI等方法暴露接口的话,服务的URL配置和管理将变得特别的困难,这个时候就需要实现一个注册中心,动态地注册和发现服务,使得服务的位置透明,并通过在消费方获取服务提供地址列表,实现软负载均衡<br>但是如果在进一步发展,服务器的依赖关系变得错综复杂,甚至分不清那个服务在那个服务之前启动,这个时候需要自动画出应用间的依赖图,来帮助架构师理清系统关系.<br>但是当应用规模扩大的时候还必须要确定多少台机器合适,也必须要有一个服务来进行调用统计,响应时间计算,通过这些来判断需要多少机器,来进行管理.</p><h2 id="dubbo架构"><a href="#dubbo架构" class="headerlink" title="dubbo架构"></a>dubbo架构</h2><p><img src="/2019/05/03/dubbo配置过程/dubbo-architecture.jpg" alt></p><p>这就是dubbo基本的架构图.<br>大致流程:</p><ol><li>服务提供方应该向注册中心注册自己要发布的服务,</li><li>其次消费方去注册中心订阅自己所需要的服务</li><li>当注册中心发现有服务的话会通知消费方服务提供放暴露的接口地址,如果一个服务有多个提供者,则会返回一个服务接口列表,由消费方调用</li><li>消费方依靠这个地址列表去找到对应的服务提供者.这里如果有多台机器在代码中会可以实现软负载均衡,寻找合适的服务提供者去请求.</li><li>服务方和消费方也都会在内存中存储调用次数和时间,定时向监控中心发送数据.</li></ol><h2 id="API方式"><a href="#API方式" class="headerlink" title="API方式"></a><strong>API方式</strong></h2><p>API方式也是根据上述的流程.<br>首先必须得有一个注册中心: 一般来说注册中心使用zookeeper,zookeeper启动过程可以去网上搜索.挺简单的.<br>接着应该有一个服务提供者提供服务.<br>使用Dubbo的服务必须有几个参数得指明.一个是application,也就是提供服务的应用.一个是注册中心的配置,因为你要向注册中心注册一个服务.这也是必须的.来看一下提供方代码:   </p><p>首先应该有一个接口,也就是提供的服务的接口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorImpl</span> <span class="keyword">implements</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着就可以提供服务了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 这个也就是提供服务的类,当有消费方请求的时候使用这个类来进行计算并且返回.</span></span><br><span class="line">        Calculator  calculator = <span class="keyword">new</span> CalculatorImpl();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要有一个应用来发布这个服务.服务必须得有名字</span></span><br><span class="line">        ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(<span class="string">"add"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接注册服务配置</span></span><br><span class="line">        RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">        <span class="comment">// 配置本地的zookeeper注册中心.还可以使用广播的方式,只需要将zookeeper改为broadcast即可</span></span><br><span class="line">        registryConfig.setAddress(<span class="string">"zookeeper://192.168.1.202:2181"</span>);</span><br><span class="line">        registryConfig.setUsername(<span class="string">"superj88"</span>);</span><br><span class="line">        registryConfig.setPassword(<span class="string">"superj88"</span>);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 服务提供协议配置 为服务提供协议配置.这里设置为dubbo,当然了,也可以是rest也就是http协议.</span></span><br><span class="line">        <span class="comment">// RPC只是一个框架,具体实现怎么都可以,当然了,必须得经过网络传输</span></span><br><span class="line">        ProtocolConfig protocol = <span class="keyword">new</span> ProtocolConfig();</span><br><span class="line">        protocol.setName(<span class="string">"dubbo"</span>);</span><br><span class="line">        <span class="comment">// 设置监听的端口</span></span><br><span class="line">        protocol.setPort(<span class="number">12345</span>);</span><br><span class="line">        protocol.setThreads(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务提供者暴露服务配置</span></span><br><span class="line">        ServiceConfig service = <span class="keyword">new</span> ServiceConfig();</span><br><span class="line">        <span class="comment">// 设置服务暴露的应用</span></span><br><span class="line">        service.setApplication(applicationConfig);</span><br><span class="line">        service.setRegistry(registryConfig);<span class="comment">// 多个注册中心用setRegistries()</span></span><br><span class="line">        <span class="comment">// 设置协议</span></span><br><span class="line">        service.setProtocol(protocol);</span><br><span class="line">        <span class="comment">// 设置接口,通过这个接口调用此服务</span></span><br><span class="line">        service.setInterface(Calculator.class);</span><br><span class="line">        </span><br><span class="line">        service.setRef(calculator);</span><br><span class="line">        service.setVersion(<span class="string">"1.0.0"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里执行暴露服务操作,具体就是向注册中心注册自己的服务</span></span><br><span class="line">        service.export();</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>消费方代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前应用配置</span></span><br><span class="line">        ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(<span class="string">"consumer"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接注册中心配置</span></span><br><span class="line">        RegistryConfig registry = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">        registry.setAddress(<span class="string">"zookeeper://localhost:2181"</span>);</span><br><span class="line">        registry.setUsername(<span class="string">"superj88"</span>);</span><br><span class="line">        registry.setPassword(<span class="string">"superj88"</span>);</span><br><span class="line">        applicationConfig.setRegistry(registry);</span><br><span class="line">        <span class="comment">// 引用远程服务</span></span><br><span class="line">        ReferenceConfig&lt;Calculator&gt; reference = <span class="keyword">new</span> ReferenceConfig&lt;&gt;(); <span class="comment">// 此实例很重，封装了与注册中心的连接以及与提供者的连接，请自行缓存，否则可能造成内存和连接泄漏</span></span><br><span class="line">        reference.setApplication(applicationConfig);</span><br><span class="line">        reference.setRegistry(registry); <span class="comment">// 多个注册中心可以用setRegistries()</span></span><br><span class="line">        reference.setInterface(Calculator.class);</span><br><span class="line">        reference.setVersion(<span class="string">"1.0.0"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里消费方还必须得有要调用服务的接口.</span></span><br><span class="line">        Calculator calculator = reference.get();</span><br><span class="line">        System.out.println(calculator.add(<span class="number">100</span>,<span class="number">2000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Spring集成-xml方式"><a href="#Spring集成-xml方式" class="headerlink" title="Spring集成 xml方式"></a><strong>Spring集成 xml方式</strong></h2><p>provider.xml配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- dubbo 应用名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-provider"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注册中心地址, 发布出来的服务要注册到这个地址上 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用的协议,这里是dubbo,绑定20890端口,  还有rest就是基于http协议的调用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20890"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定发布的哪一个的服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">class</span>=<span class="string">"org.apache.dubbo.samples.basic.impl.DemoServiceImpl"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个是发布服务锁制定的接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.samples.basic.api.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>consumer.xml配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 消费者的应用名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-consumer"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注册中心 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">group</span>=<span class="string">"aaa"</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 表示自己要使用那个服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">check</span>=<span class="string">"false"</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.samples.basic.api.DemoService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>还有很多配置,详情请看dubbo官网<a href="http://dubbo.apache.org/zh-cn/docs/user/configuration/xml.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/configuration/xml.html</a>.   </p><h2 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置:"></a><strong>基于注解的配置:</strong></h2><h3 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h3><p>首先也必须要配置应用共享的一些属性,比如应用名称,注册地址,使用的协议和绑定的端口等.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dubbo.application.name=annotation-provider</span><br><span class="line">dubbo.registry.address=zookeeper:<span class="comment">//127.0.0.1:2181</span></span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">dubbo.protocol.port=<span class="number">20880</span></span><br></pre></td></tr></table></figure></p><p>指定包的扫描路径:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDubbo</span>(scanBasePackages = <span class="string">"org.apache.dubbo.samples.simple.annotation.impl"</span>)</span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/spring/dubbo-provider.properties"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderConfiguration</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用Service注解暴露服务"><a href="#使用Service注解暴露服务" class="headerlink" title="使用Service注解暴露服务"></a>使用Service注解暴露服务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(protocol = &#123;<span class="string">"dubbo"</span>,<span class="string">"rest"</span>&#125;,version = <span class="string">"1.0"</span>, timeout=<span class="number">3000</span>)</span><br><span class="line"><span class="comment">// 这里的@Path路径中,如果上面协议中指定了rest服务,必须要指明路径.不然会报错.</span></span><br><span class="line"><span class="meta">@Path</span>(<span class="string">"moocOne"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboTestService</span> <span class="keyword">implements</span> <span class="title">IDubboTestService</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h3><p>配置应用基本属性:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dubbo.application.name=annotation-consumer</span><br><span class="line">dubbo.registry.address=zookeeper:<span class="comment">//127.0.0.1:2181</span></span><br><span class="line">dubbo.consumer.timeout=<span class="number">3000</span></span><br></pre></td></tr></table></figure></p><p>消费方使用服务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"annotationAction"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过此注解引用服务</span></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> AnnotationService annotationService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> annotationService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>指定spring扫描路径<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableDubbo</span>(scanBasePackages = <span class="string">"org.apache.dubbo.samples.simple.annotation.action"</span>)</span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/spring/dubbo-consumer.properties"</span>)</span><br><span class="line"><span class="meta">@ComponentScan</span>(value = &#123;<span class="string">"org.apache.dubbo.samples.simple.annotation.action"</span>&#125;)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-SPI机制</title>
      <link href="/2019/05/02/Java-SPI%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/05/02/Java-SPI%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="SPI简介"><a href="#SPI简介" class="headerlink" title="SPI简介"></a>SPI简介</h2><p>SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件.<br>SPI其实就是 基于接口的编程 + 策略模式 + 配置文件 组合实现的动态加载机制.<br>Java SPI就是提供一个机制,通过为某个接口寻找服务的一个实现机制.通过读取你在配置文件中配置的参数,来为你提供相应的服务.核心思想就是解耦.将程序的装配权移动到程序之外,也就是配置文件中. </p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>就是调用这可以根据实际需要,启用,扩展和替换一些实现的策略.<br>举个例子: </p><ul><li>数据库驱动加载接口实现类的加载.jdbc通过配置不同,实现不同的数据库驱动的加载</li><li>日志门面接口实现类加载 .SLF4J加载不同提供商的日志实现类</li></ul><h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍:"></a>使用介绍:</h2><p>首先定义一个接口与它的多个实现类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spj.spi;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RobotBoy</span> <span class="keyword">implements</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello,I am a boy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RobotGirl</span> <span class="keyword">implements</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello,I am a girl"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~ </span><br><span class="line">其次在 src/main/resources 目录下建立 META-INF/services 目录.新建一个以此接口命名的文件,我这里是com.spj.spi.Robot,然后在想文件中写入它的两个实现类.实现类必须要写类的全限定名称. 借着来用spi测试一下:</span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaSpiTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServiceLoader&lt;Robot&gt; serviceLoader = ServiceLoader.load(Robot.class);</span><br><span class="line">        Iterator&lt;Robot&gt; matchter = serviceLoader.iterator();</span><br><span class="line">        <span class="keyword">while</span> (matchter.hasNext())&#123;</span><br><span class="line">            Robot robot = matchter.next();</span><br><span class="line">            robot.sayHello();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台输出: </span><br><span class="line">hello,I am a boy</span><br><span class="line">hello,I am a girl</span><br></pre></td></tr></table></figure></p><p>这里会将两个实现类加载进来. 通过ServiceLoader来进行接口服务的发现与加载. </p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现:"></a>具体实现:</h2><p>首先看ServiceLoader的具体属性:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoader</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 看到这个前缀表明了你必须得将配置文件放在这个目录下</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"META-INF/services/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个就是上面要寻找的服务的接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来加载类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问控制器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来缓存加载成功的类</span></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="keyword">private</span> LazyIterator lookupIterator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体加载过程:<br>在查找下一个实现类的时候,首先会看缓存providers中是否有,如果没有,则进行加载配置文件中的类.实现如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    String cn = nextName;</span><br><span class="line">    nextName = <span class="keyword">null</span>;</span><br><span class="line">    Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过名称加载类</span></span><br><span class="line">        c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取到之后,将此类缓存到providers中.</span></span><br><span class="line">        S p = service.cast(c.newInstance());</span><br><span class="line">        providers.put(cn, p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated"</span>,</span><br><span class="line">             x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断还有没有下一个.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String fullName = PREFIX + service.getName();</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                configs = loader.getResources(fullName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            fail(service, <span class="string">"Error locating configuration files"</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pending = parse(service, configs.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">    nextName = pending.next();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java SPI机制主要是为了解耦,通过将具体实现与应用程序分开,方便管理,在需要配置不同的实现的情况下,不需要进行代码改动,而只需要改变配置就可以了.<br>当然,Java SPI机制也有一些缺点,虽然其中确实有延迟加载,但是如果想要获得某个实现类的话就只能遍历获取,将每个实现类多遍历一遍,就造成了浪费.</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-NIO之Buffer</title>
      <link href="/2019/05/01/java-NIO%E4%B9%8BBuffer/"/>
      <url>/2019/05/01/java-NIO%E4%B9%8BBuffer/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Java NIO类在jdk中有了源生支持,实现了一套自己的NIO框架,当然了底层依然是系统调用.但是在NIO中必不可少的就是缓冲区,随后的Channel和Selector随后在介绍.</p><h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><p><img src="/2019/05/01/java-NIO之Buffer/Buffer.png" alt><br>这就是Buffer的大致继承体系,很多都没有罗列出来,因为主要讲解的是ByteBuffer.这里大概说一下,Buffer是一个抽象类,包括一个Buffer的最基本属性,比如,容量,位置,上界,标记.子类通过调用父类构造方法来实例化这几个参数,子类也都有各自的容量实现.比如ByteBuffer类用字节数组当缓冲区.旗下又有两个自己的实现类.<br>在jdk中,buffer有很多中实现,例如intBuffer,LongBuffer,ByteBuffer等,但是在NIO中实现的大多使用的是ByteBuffer,重点来看一下ByteBuffer.</p><h1 id="Buffer属性以及相关操作"><a href="#Buffer属性以及相关操作" class="headerlink" title="Buffer属性以及相关操作."></a>Buffer属性以及相关操作.</h1><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>capacity 容量</td><td>Buffer所能够存放的最大容量</td></tr><tr><td>position 位置</td><td>下一个被读或写的位置</td></tr><tr><td>limit 上界</td><td>可供读写的最大位置,用于限制position position &lt; limit</td></tr><tr><td>mark 标记</td><td>标记位置,用于记录某次读写的位置,可以通过reset()方法回到这里</td></tr></tbody></table><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化:"></a>初始化:</h2><p>ByteBuffer是一个抽象类,它有两个实现类,分别是上面图中显示的HeapByteBuffer和DirectByteBuffer.而且这两个类都不能被外部访问,都是包级的.而是应该通过allocate、allocateDirect 和 wrap 等方法初始化. 先看一下allocate方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity);</span><br><span class="line">&#125;</span><br><span class="line"> HeapByteBuffer(<span class="keyword">int</span> cap, <span class="keyword">int</span> lim) &#123;            <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, lim, cap, <span class="keyword">new</span> <span class="keyword">byte</span>[cap], <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 这里又调用父类构造方法,也就是ByteBuffer的构造方法</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">ByteBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap,  </span><br><span class="line">                 <span class="keyword">byte</span>[] hb, <span class="keyword">int</span> offset)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在调用顶级父类Buffer的构造方法</span></span><br><span class="line">        <span class="keyword">super</span>(mark, pos, lim, cap); </span><br><span class="line">        <span class="keyword">this</span>.hb = hb;</span><br><span class="line">        <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在来看一下Buffer的构造方法</span><br><span class="line">Buffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap) &#123;       <span class="comment">// package-private</span></span><br><span class="line">        <span class="keyword">if</span> (cap &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative capacity: "</span> + cap);</span><br><span class="line">        <span class="keyword">this</span>.capacity = cap;</span><br><span class="line">        limit(lim);</span><br><span class="line">        position(pos);</span><br><span class="line">        <span class="keyword">if</span> (mark &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mark &gt; pos)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"mark &gt; position: ("</span></span><br><span class="line">                                                   + mark + <span class="string">" &gt; "</span> + pos + <span class="string">")"</span>);</span><br><span class="line">            <span class="keyword">this</span>.mark = mark;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>通过创建一个HeapByteBuffer()来构造一个ByteBuffer对象,类如其名,这是一个堆上的缓冲区.而DirectByteBuffer是一个堆外的缓冲区,在堆外分配的.这里就不细说了.当然了,warp()和allocateDirect()也是一样的道理.<br>初始化完成后,mark=1,初始position位置为0,也就是从0开始,limit就等于容量大小</p><h2 id="读写ByteBuffer"><a href="#读写ByteBuffer" class="headerlink" title="读写ByteBuffer"></a>读写ByteBuffer</h2><p>首先看一下HeapByteBuffer()的get()方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读操作就是直接读取下一个index的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hb[ix(nextGetIndex())];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(offset, length, dst.length);</span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    System.arraycopy(hb, ix(position()), dst, offset, length);</span><br><span class="line">    position(position() + length);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">// offset就是偏移量,是一个数字的偏移量,这里字节数组所以偏移量为1,如果为intBuffer当然会是4了.</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后会检查这里的读是否超过了读的界限.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextGetIndex</span><span class="params">()</span> </span>&#123;                       </span><br><span class="line">        <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">        <span class="keyword">return</span> position++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 这个方法直接找到下n个位置</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextGetIndex</span><span class="params">(<span class="keyword">int</span> nb)</span> </span>&#123;                   </span><br><span class="line">    <span class="keyword">if</span> (limit - position &lt; nb)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="keyword">int</span> p = position;</span><br><span class="line">    position += nb;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然了读操作也不能无限制的读啊,当然的是需要有一个界限了,这里就有了下面这个方法,能够检测是否还能继续读取.可以就返回true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> position &lt; limit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在看一下写操作:这里写操作和读操作类似,但是有很多重载,就不一一介绍了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">    hb[ix(nextPutIndex())] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextPutIndex</span><span class="params">()</span> </span>&#123;               </span><br><span class="line">    <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">return</span> position++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到,写操作也是直接向position位置写数据,这里其实会挺迷惑的.如果说写和读都需要让position加1,那么每次读的时候,肯定是读不到写的数据啊.当然了,jdk肯定考虑到了这个. 当我们写完数据需要在读取之前的数据的时候,我们就需要再次将position置位0,然后在开始读取我们的数据.Buffer中提供了修改positon的方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> newPosition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((newPosition &gt; limit) || (newPosition &lt; <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        position = newPosition;</span><br><span class="line">        <span class="keyword">if</span> (mark &gt; position) mark = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然了,如果我们想要正常读取数据的话只修改position是不够的,还应该再次修改limit的值,让它指向刚才写入的最后一个位置,我们才能保证读到的数据都是有效的.这就有了limit这个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((newLimit &gt; capacity) || (newLimit &lt; <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        limit = newLimit;</span><br><span class="line">        <span class="keyword">if</span> (position &gt; limit) position = limit;</span><br><span class="line">        <span class="keyword">if</span> (mark &gt; limit) mark = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>但是每次调用这两个方法都很麻烦啊,这里jdk也帮我们想到了,所以有了flip()方法.很多人都知道写入Buffer数据之后要使用flip()方法然后才能读取到数据,但是不知道为什么,看了下面代码应该就知道了.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        limit = position;</span><br><span class="line">        position = <span class="number">0</span>;</span><br><span class="line">        mark = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里看一个实例来了解一下吧:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>); <span class="comment">// 申请一个1024个字节的Buffer</span></span><br><span class="line">        buffer.put(<span class="string">"1234567"</span>.getBytes()); </span><br><span class="line">        <span class="comment">// 调用flip()函数将position置0,将limit置位当初写到的最后一个位置</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">// 如果还有读取的数据就读取</span></span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)buffer.get());<span class="comment">// 这里会按序输出1234567</span></span><br><span class="line">        &#125;</span><br><span class="line">        buffer.limit(<span class="number">1024</span>); <span class="comment">// 这里在设置limit为1024,因为如果不设置就会写不进去了.然后接下来才可以继续写.</span></span><br><span class="line">        System.out.println(buffer.position()); <span class="comment">// 这里输出position为7,也就是下一个要读或写的位置.</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="reset-方法"><a href="#reset-方法" class="headerlink" title="reset()方法"></a>reset()方法</h2><p>reset()方法主要是为了让我们能够在此回到上一个感兴趣的位置,比如在读取数据的时候发现出错了,我们就要重新读取,从上次对的地方开始读取.这就需要用到reset()方法.<br>当然了,reset()是要用到mark标记字段的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先用mark()方法标记当前位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mark = position;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 之后如果需要回到当前位置,就调用reset()将position置位mark的位置,开始读写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = mark;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">        position = m;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Buffer是NIO中的一个很重要的辅助类,虽然不难,但是很重要,有必要去了解一下它的实现与基本机制,最起码能够在写代码的时候不会因为各种读取不到数据,没有使用flip()方法等导致找很长时间bug.</p><p>参考自博文:<a href="http://www.tianxiaobo.com/2018/03/04/Java-NIO%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA/" target="_blank" rel="noopener">http://www.tianxiaobo.com/2018/03/04/Java-NIO%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA/</a><br>这位大佬写的很不错,浅显易懂.其他文章写的也都挺不错的.</p>]]></content>
      
      
      <categories>
          
          <category> java-NIO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>烦人的配置篇</title>
      <link href="/2019/04/30/%E5%B8%B8%E7%8A%AF%E9%94%99%E8%AF%AF/"/>
      <url>/2019/04/30/%E5%B8%B8%E7%8A%AF%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<p>##<br>鉴于自己在搭建项目的时候经常出现一些很莫名其妙的bug或者说配置问题,这里做一个记录,持续更新,更新自己遇到的BUG.以及如何解决.  </p><h2 id="idea-maven更改pom之后jdk自动变为1-5版本-导致还必须得重新更改设置"><a href="#idea-maven更改pom之后jdk自动变为1-5版本-导致还必须得重新更改设置" class="headerlink" title="idea+maven更改pom之后jdk自动变为1.5版本,导致还必须得重新更改设置."></a>idea+maven更改pom之后jdk自动变为1.5版本,导致还必须得重新更改设置.</h2><p>这里只需要更改maven安装目录下的/conf/setting.xml文件,在其中的加入如下片段:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;profiles&gt;</span><br><span class="line">&lt;profile&gt;  </span><br><span class="line">        &lt;id&gt;jdk-1.8&lt;/id&gt;  </span><br><span class="line">        &lt;activation&gt;  </span><br><span class="line">            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;  </span><br><span class="line">            &lt;jdk&gt;1.8&lt;/jdk&gt;  </span><br><span class="line">        &lt;/activation&gt;  </span><br><span class="line">        &lt;properties&gt;  </span><br><span class="line">            &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;  </span><br><span class="line">            &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;  </span><br><span class="line">            &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;  </span><br><span class="line">        &lt;/properties&gt;  </span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">&lt;/profiles&gt;</span><br></pre></td></tr></table></figure></p><p>这里我用的是JDK1.8,所以我把他们改成了jdk1.8,只要改成对应的版本.<br>之后再在idea中setting中更改maven配置<br><img src="/2019/04/30/常犯错误/maven导入变jdk变1.5解决.png" alt><br>将上面的maven用本地的,然后仓库和设置都是用本地的就可以了,也就是勾选上面两个override选项.<br>然后再在idea中重新导入一下idea就可以了</p><h2 id="java-Web-Servlet-报错"><a href="#java-Web-Servlet-报错" class="headerlink" title="java Web @Servlet 报错"></a>java Web @Servlet 报错</h2><p>java.lang.IllegalStateException: Cannot call sendError() after the response has been committed<br>出现这个错误信息. 这个错误就是在已经返回函数的情况下,又想连接中写入数据了,所以会出现这个情况.这个一般都出现在异步的情况.但是我这里也没有这么做.所以就也不是这个问题.  </p><p>最后找到原因,是因为没有导入tomcat的依赖包,但是能运行,在运行的时候因为没有tomcat的包,导致运行时候出错.导入包之后WebServlet注解也可以用了.也不会出现这个错误.</p>]]></content>
      
      
      <categories>
          
          <category> 项目错误汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> error </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java NIO之Selector</title>
      <link href="/2019/04/29/java-NIO%E4%B9%8Bselector/"/>
      <url>/2019/04/29/java-NIO%E4%B9%8Bselector/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Selector 是一个选择器,主要用法就是,通过将一个通道注册到selector中,然后在通过select方法获取到你监听的事件绑定的键. 相当于是以前需要不断轮询去判断io流是否可读,或者可写,或者新的连接已经到来.现在通过Selector帮你判断,当有可用的连接或者可读可写时,selectKeys()方法会返回一个可用的通道集合.通过调用selector.select()来实现,这个方法是阻塞的,当没有准备就绪的通道会阻塞.当然了,这一切包括通道和注册事件都是由一个SelectionKey保存的.<br>所以在讲解selector之前必须得现有一个SelectionKey和Channel的概念.  </p><h2 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h2><p>讲到Selector必须得将SelectionKey,因为每次向Selector中注册一个事件就会创建一个选择键,可以通过它的cancel方法,close等方法来关闭它或者取消它.</p><p>当把通道注册到Selector中的时候,Selector开始监听,但是Selector的返回就绪事件的时候总是返回一个SelectionKey,在这个key中包含了当初注册的通道,拿到这个通道然后开始做自己的事情,比如说读写,建立连接.<br>SelectionKey有四种事件: </p><ul><li>int OP_ACCEPT = 1 &lt;&lt; 4;   //监听接收连接请求</li><li>int OP_CONNECT = 1 &lt;&lt; 3;// 监听连接完成</li><li>int OP_WRITE = 1 &lt;&lt; 2; // 监听可写</li><li>int OP_READ = 1 &lt;&lt; 0;  // 可读   </li></ul><p>事件之间可以通过或运算进行组合,比如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestOps = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure></p><p>这里这个interestOps就是读和写事件的合集.因为每个事件都是2的整数倍,所以或运算之后判断每一位的状态就可以知道注册的事件合集</p><h3 id="两种事件集合-interestOps-和-readyOps"><a href="#两种事件集合-interestOps-和-readyOps" class="headerlink" title="两种事件集合:interestOps 和 readyOps"></a>两种事件集合:interestOps 和 readyOps</h3><p>interestOps就是感兴趣的事件集合,通过register方法注册时会调用此值,可以通过Selectionkey.interestOps()方法获得<br>readyOps 是就绪事件集合，可通过 SelectionKey readyOps() 获取。<br>下面来看一下SelectionKey中的具体的方法</p><h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法:"></a>具体方法:</h3><table><thead><tr><th style="text-align:center">返回值</th><th style="text-align:center">方法名</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">Object</td><td style="text-align:center">attach（Object obj)</td><td style="text-align:center">将给定的对象附加到此键</td></tr><tr><td style="text-align:center">Object</td><td style="text-align:center">attachment()</td><td style="text-align:center">返回附加给此键的对象</td></tr><tr><td style="text-align:center">abstract void</td><td style="text-align:center">cancel()</td><td style="text-align:center">请求取消此键的通道到其选择键的注册</td></tr><tr><td style="text-align:center">Channel</td><td style="text-align:center">channel()</td><td style="text-align:center">返回为之创建此键的通道</td></tr><tr><td style="text-align:center">SelectionKey</td><td style="text-align:center">interestOps(int ops)</td><td style="text-align:center">将此键的 interest 集合设置为给定值。</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">isAcceptable()</td><td style="text-align:center">测试此键的通道已经准备好接受新的套接字连接</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">isConnectable()</td><td style="text-align:center">测试此键的通道是否已经建立好连接</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">isReadable()</td><td style="text-align:center">测试是否有数据可读</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">isValid()</td><td style="text-align:center">此键是否有效</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">isWriteable()</td><td style="text-align:center">通道是否可写</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">selector()</td><td style="text-align:center">返回为此选择器创建的键。</td></tr></tbody></table><h2 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h2><p>ServerSocketChannel其实就是对ServerSocket的一个封装,使得它能够非阻塞接受请求.将socket变成通道形式的.具体类图看一下<br><img src="/2019/04/29/java-NIO之selector/SocketChannel.png" alt></p><p>上面说到向Selector中注册选择键,但是这个注册选择键又是怎么注册的呢.看下面代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里就是新建一个Selector</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"><span class="comment">// 这里建立一个服务的SocketChannel通道</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">// 设置为非阻塞</span></span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 绑定端口</span></span><br><span class="line">serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line"><span class="comment">// 这里执行注册监听连接事件</span></span><br><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"><span class="comment">// accept 方法接受一个连接,返回一个SocketChannel.</span></span><br><span class="line">SocketChannel socketChannel =serverSocketChannel.accept();</span><br><span class="line"><span class="comment">// socket 返回一个ServerSocket. ServerSocket套接字就是服务端的套接字,用来接受连接请求.</span></span><br><span class="line">ServerSocket socket = serverSocketChannel.socket();</span><br></pre></td></tr></table></figure></p><p>这里调用register()方法就将这个Channel注册到了selector中.之后就会监听此通道的accept请求了.当然这里只是说明了注册方式,具体细节请继续看下去.<br>方法不多,但是很多方法都是继承子父类的,比如上面代码中的bind,register,configureBlocking等方法.</p><h2 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h2><p>SocketChannel,这个通道主要就类似于普通的Socket,但是使用通道来表示Socket的连接,通过通道和Selector和选择键可以实现非阻塞IO.<br>主要方法:  这里用一个例子来演示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也是通过open()打开一个连接</span></span><br><span class="line">SocketChannel socketChannel =  SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">8000</span>));</span><br><span class="line"><span class="comment">// 与ServerSocketChannel一样,也配置是异步</span></span><br><span class="line">socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 这里有一点就是如果要注册到Selector中的话必须首先设置为异步的.</span></span><br><span class="line">socketChannel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure></p><p>套接字通道不是连接网络套接字的完整抽象。必须通过调用 socket 方法所获得的关联 Socket 对象来完成对套接字选项的绑定、关闭和操作。不可能为任意的已有套接字创建通道，也不可能指定与套接字通道关联的套接字所使用的 SocketImpl 对象。</p><p>通过调用此类的某个 open 方法创建套接字通道。新创建的套接字通道已打开，但尚未连接。试图在未连接的通道上调用 I/O 操作将导致抛出 NotYetConnectedException。可通过调用套接字通道的 connect 方法连接该通道；一旦连接后，关闭套接字通道之前它会一直保持已连接状态。可通过调用套接字通道的 isConnected 方法来确定套接字通道是否已连接。</p><p>套接字通道支持非阻塞连接：可创建一个套接字通道，并且通过 connect 方法可以发起到远程套接字的连接，之后通过 finishConnect 方法完成该连接。可通过调用 isConnectionPending 方法来确定是否正在进行连接操作。</p><p>可单独地关闭 套接字通道的输入端和输出端，而无需实际关闭该通道。调用关联套接字对象的 shutdownInput 方法来关闭某个通道的输入端将导致该通道上的后续读取操作返回 -1（指示流的末尾）。调用关联套接字对象的 shutdownOutput 方法来关闭通道的输出端将导致该通道上的后续写入操作抛出 ClosedChannelException。</p><p>套接字通道支持异步关闭，这与 Channel 类中所指定的异步 close 操作类似。如果一个线程关闭了某个套接字的输入端，而同时另一个线程被阻塞在该套接字通道上的读取操作中，那么处于阻塞线程中的读取操作将完成，而不读取任何字节且返回 -1。I如果一个线程关闭了某个套接字的输出端，而同时另一个线程被阻塞在该套接字通道上的写入操作中，那么阻塞线程将收到 AsynchronousCloseException。</p><p>多个并发线程可安全地使用套接字通道。尽管在任意给定时刻最多只能有一个线程进行读取和写入操作，但数据报通道支持并发的读写。connect 和 finishConnect 方法是相互同步的，如果正在调用其中某个方法的同时试图发起读取或写入操作，则在该调用完成之前该操作被阻塞</p><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>Selector其实就是一个I/O多路复用器.通过复用</p><p>接下来主要说一下Selector类,这个类是NIO的核心类,如果没有它,那么可能我们还必须要像以前一样,要么阻塞在读或者写事件,要么轮询是否可读写,浪费cpu资源.Selector中可以是通过将一个通道注册上,当事件发生的时候将此通道所绑定的选择键返回给调用者,让调用这去处理,而不必让每个调用者轮询此连接是否可读可写.  </p><p>这里通过SelectionKey来表示从通道到选择器的注册:<br>在Selector中有三种键的集合:</p><ul><li>已选择集合: 是在前一次选择期间操作期间,检测每个键的通道是否已经至少为该键的相关操作集所标识的一个操作准备就绪,此集合由 selectedKeys 方法返回</li><li>已取消集合: 是被取消但是通道尚未注销的集合.不可直接访问此集合.</li><li>注册集合: 表示所有注册到此选择器上的键.包括以取消但是还未注销的键.通过keys()返回<br>当新创建Selector时,三个集合都是空的,每当有一个通道通过register向Selector注册该通道的时候,也会想选择器的键集添加一个与此通道绑定的键.而且需要在选择期间从键集中移除已经取消的键.<br>不管是通过关闭某个键的通道还是调用该键的 cancel 方法来取消键，该键都被添加到其选择器的已取消键集中。取消某个键会导致在下一次选择操作期间注销该键的通道，而在注销时将从所有选择器的键集中移除该键。</li></ul><p>通过选择操作将键添加到已选择键集中,可以通过调用已选择键集的remove()方法,或者调用该键集的迭代器的remove()方法移除此键.只能通过这两种方式来移除键集中的键.  </p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>Selector不能直接实例化,需要使用Selector.open()来初始化:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure></p><p>这里就打开连接了,当然了,建立一个Selector并不是这么简单,java帮我们封装了很多api,一些底层实现我们是不知道的,既然要理解Selector,这里我们也要看一下到底它都干了什么.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SelectorProvider.provider().openSelector();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>发现open()函数其实是调用了一个SelectorProvider()的函数来进行创建的.在进去调用栈看一看.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">provider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> provider;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;SelectorProvider&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> SelectorProvider <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (loadProviderFromProperty())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                            <span class="keyword">if</span> (loadProviderAsService())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                            <span class="comment">// 创建默认的SelectorProvider</span></span><br><span class="line">                        provider = sun.nio.ch.DefaultSelectorProvider.create();</span><br><span class="line">                        <span class="keyword">return</span> provider;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里调用Provider函数,创建一个SelectorProvider实例,在这个实例又调用这个DefaultSelectorProvider.create()真正创建一个Selecotr实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String var0 = (String)AccessController.doPrivileged(<span class="keyword">new</span> GetPropertyAction(<span class="string">"os.name"</span>));</span><br><span class="line">    <span class="keyword">if</span> (var0.equals(<span class="string">"SunOS"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> createProvider(<span class="string">"sun.nio.ch.DevPollSelectorProvider"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (SelectorProvider)(var0.equals(<span class="string">"Linux"</span>) ? createProvide(<span class="string">"sun.nio.ch.EPollSelectorProvider"</span>) : <span class="keyword">new</span> PollSelectorProvider());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这里应该明白了,其实到这里能看出来,如果是linux系统的话,Selector就是通过使用epoll来实现的.如果是SunOS就用DevPoll实现.到了这一步,大致对创建就有了一个了解.</p><h3 id="通道注册"><a href="#通道注册" class="headerlink" title="通道注册"></a>通道注册</h3><p>上面已经提到,通道注册的话就是需要调用通道的register方法来注册到selector中,不如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure></p><p>既然已经知道了这个Selector是使用epoll来实现的,那么注册应该就是使用的是函数epoll_ctl()函数了.但是java中确不是这么实现的.在register的调用栈中,确实没有出现epoll_ctl()函数的调用.它是通过先把所有的注册事件都放在了一个事件集合中,然后在选择的时候再进行统一注册.<br>接下来看一下register方法的调用过程:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用register方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Object att)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClosedChannelException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (regLock) &#123;</span><br><span class="line">            <span class="comment">// 如果通道没打开,则抛异常</span></span><br><span class="line">            <span class="keyword">if</span> (!isOpen())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">                <span class="comment">// 如果是无效事件,抛异常</span></span><br><span class="line">            <span class="keyword">if</span> ((ops &amp; ~validOps()) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">                <span class="comment">//如果是阻塞模式,抛异常</span></span><br><span class="line">            <span class="keyword">if</span> (blocking)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalBlockingModeException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里findkey方法会首先查看此通道是否已经被注册过</span></span><br><span class="line">            SelectionKey k = findKey(sel);</span><br><span class="line">            <span class="comment">// 如果注册过,将此事件加入到感兴趣事件中</span></span><br><span class="line">            <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">                k.interestOps(ops);</span><br><span class="line">                k.attach(att);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有,则去注册</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// New registration</span></span><br><span class="line">                <span class="keyword">synchronized</span> (keyLock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!isOpen())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">                    k = ((AbstractSelector)sel).register(<span class="keyword">this</span>, ops, att);</span><br><span class="line">                    addKey(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorImpl</span> <span class="keyword">extends</span> <span class="title">AbstractSelector</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(AbstractSelectableChannel var1, <span class="keyword">int</span> var2, Object var3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(var1 <span class="keyword">instanceof</span> SelChImpl)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalSelectorException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 新建一个SelectionKeyImpl</span></span><br><span class="line">            SelectionKeyImpl var4 = <span class="keyword">new</span> SelectionKeyImpl((SelChImpl)var1, <span class="keyword">this</span>);</span><br><span class="line">            var4.attach(var3);</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.publicKeys) &#123;</span><br><span class="line">                <span class="comment">// 调用注册函数</span></span><br><span class="line">                <span class="keyword">this</span>.implRegister(var4);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将此次注册事件添加到感兴趣事件集合中</span></span><br><span class="line">            var4.interestOps(var2);</span><br><span class="line">            <span class="keyword">return</span> var4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EPollSelectorImpl</span> <span class="keyword">extends</span> <span class="title">SelectorImpl</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这是上面的实现了的注册函数</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implRegister</span><span class="params">(SelectionKeyImpl var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.closed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 首先获得一个channel</span></span><br><span class="line">            SelChImpl var2 = var1.channel;</span><br><span class="line">            <span class="comment">// 获取到channel 的文件描述符</span></span><br><span class="line">            <span class="keyword">int</span> var3 = Integer.valueOf(var2.getFDVal());</span><br><span class="line">            <span class="comment">// 存储 文件描述符 和 SelectionKeyImpl 的映射关系</span></span><br><span class="line">            <span class="keyword">this</span>.fdToKey.put(var3, var1);</span><br><span class="line">            <span class="comment">// 将这个事件加入到pollWrapper中    </span></span><br><span class="line">            <span class="keyword">this</span>.pollWrapper.add(var3);</span><br><span class="line">            <span class="comment">// 将这个SelectionKey加入到键集合中</span></span><br><span class="line">            <span class="keyword">this</span>.keys.add(var1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionKeyImpl</span> <span class="keyword">extends</span> <span class="title">AbstractSelectionKey</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SelectionKey <span class="title">interestOps</span><span class="params">(<span class="keyword">int</span> ops)</span> </span>&#123;</span><br><span class="line">        ensureValid();</span><br><span class="line">        <span class="keyword">return</span> nioInterestOps(ops);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> SelectionKey <span class="title">nioInterestOps</span><span class="params">(<span class="keyword">int</span> ops)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((ops &amp; ~channel().validOps()) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="comment">// 转换并设置感兴趣的事件</span></span><br><span class="line">        channel.translateAndSetInterestOps(ops, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 设置 interestOps 变量</span></span><br><span class="line">        interestOps = ops;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class</span> <span class="title">EPollSelectorImpl</span> <span class="keyword">extends</span> <span class="title">SelectorImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putEventOps</span><span class="params">(SelectionKeyImpl ski, <span class="keyword">int</span> ops)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closed)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</span><br><span class="line">        SelChImpl ch = ski.channel;</span><br><span class="line">        <span class="comment">// 设置感兴趣的事件</span></span><br><span class="line">        pollWrapper.setInterest(ch.getFDVal(), ops);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EPollArrayWrapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setInterest</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (updateLock) &#123;</span><br><span class="line">            <span class="comment">// 扩容 updateDescriptors 数组，并存储文件描述符 fd</span></span><br><span class="line">            <span class="keyword">int</span> oldCapacity = updateDescriptors.length;</span><br><span class="line">            <span class="keyword">if</span> (updateCount == oldCapacity) &#123;</span><br><span class="line">                <span class="keyword">int</span> newCapacity = oldCapacity + INITIAL_PENDING_UPDATE_SIZE;</span><br><span class="line">                <span class="keyword">int</span>[] newDescriptors = <span class="keyword">new</span> <span class="keyword">int</span>[newCapacity];</span><br><span class="line">                System.arraycopy(updateDescriptors, <span class="number">0</span>, newDescriptors, <span class="number">0</span>, oldCapacity);</span><br><span class="line">                updateDescriptors = newDescriptors;</span><br><span class="line">            &#125;</span><br><span class="line">            updateDescriptors[updateCount++] = fd;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// events are stored as bytes for efficiency reasons</span></span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)mask;</span><br><span class="line">            <span class="keyword">assert</span> (b == mask) &amp;&amp; (b != KILLED);</span><br><span class="line">            <span class="comment">// 存储事件</span></span><br><span class="line">            setUpdateEvents(fd, b, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUpdateEvents</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">byte</span> events, <span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; MAX_UPDATE_ARRAY_SIZE) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((eventsLow[fd] != KILLED) || force) &#123;</span><br><span class="line">                eventsLow[fd] = events;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Integer key = Integer.valueOf(fd);</span><br><span class="line">            <span class="keyword">if</span> (!isEventsHighKilled(key) || force) &#123;</span><br><span class="line">                eventsHigh.put(key, Byte.valueOf(events));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到了implRegister()函数的时候基本就算完事了,所以说在注册的过程中,就只是将event添加到eventsLow数组中,至于epoll_ctl的调用,则是在选择期间调用.</p><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>在每次选择期间都可以将其从已选择键集或者键集中移除.移除完之后就会在下次选择期间看看是否事件发生,如果发生就继续将其添加到已选择键集中.主要有三个方法:</p><ul><li>select()      返回已经准备好I/O的通道数量</li><li>select(long)  返回已经准备好I/O的通道数量</li><li>selectNow()   返回已经准备好I/O的通道数量</li><li>selectKeys()  返回此选择器的已选择键集</li><li>keys()        返回此选择器键集<br>每次做选择都会有一下四步走.</li></ul><ol><li>将已取消键集中的键从选择器中注销.就是清空取消键集.也就是说调用了cancel()的键将在这个时候被真正的取消</li><li>在这之后会调用操作系统的epoll_ctl函数将通道感兴趣的事件注册到epoll实例中.然后开始wait事件发生.</li><li>如果说准备就绪的键已经在已选择键集中,就会更新此键的就绪操作集.如果此键不在已选择键集中,就将此键添加到已选择操作集中.更新就绪操作集</li><li>如果此过程中有过将任意键添加到取消键集中,就继续执行步骤1</li></ol><p>在这里要说明一下,select和selectKeys()是不一样的,select方法返回的是准备好I/O的通道的数量.而selectKeys返回的是选择器的已选择键集.如果编过程的人可能都碰到过这样的一种情况,就是在select()返回是0的情况,但是selectKeys()确返回了好几个键,这里就着重说一下,这个已选择键集和取消键集.这里的已选择键集就是如果你不去手动删除你已经处理完的已选择键集,那么选择器中的已选择键集还是不会变的.也就是说当你处理完一个已选择键集,如果没有通过remove()方法删除掉其中的键的话,这些键将依然存在与已选择键集中.这也就是为什么会出现上面说的那种情况.在编程 的时候需要注意这一点.    </p><p>当移除了已选择键集中的键并不会取消注册,取消有对应的cancel方法,移除已选择键集只是在调用selectKeys的时候不会在此返回上次已经处理过的准备好的通道.</p><h3 id="取消"><a href="#取消" class="headerlink" title="取消:"></a>取消:</h3><p>这里在说一下取消操作,取消操作需要调用SelectionKey.cancel()方法,但是这个方法映射到epoll中并不会立即取消epoll中实例的注册,而是先将此键放入取消键集中,然后等到下一次select()操作时,将此取消键集中的键注销掉.</p>]]></content>
      
      
      <categories>
          
          <category> NIO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java正则表达式</title>
      <link href="/2019/04/23/java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/04/23/java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是处理字符串的强大工具,它并不是java的特性.但是java有一套工具类提供了正则表达式的匹配功能. </p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ol><li>字符串匹配</li><li>字符串查找</li><li>字符串替换</li></ol><h2 id="Java类"><a href="#Java类" class="headerlink" title="Java类"></a>Java类</h2><p>java中正则表达式主要包括两个类:</p><ul><li>Pattern:  此对象是一个正则表达式的编译表示.此类没有共有的构造方法,只能通过静态编译方法来获得一个Pattern对象.比如<strong>Pattern.compile(“\d”);</strong> 这个样子.参数就是要编译的正则表达式.</li><li>Matcher: 是对输入字符串进行解释和匹配的引擎,它也没有公共的构造方法,只能通过Pattern对象的match方法来获得一个Matcher对象</li></ul><h2 id="Java中的正则表达式语法"><a href="#Java中的正则表达式语法" class="headerlink" title="Java中的正则表达式语法"></a>Java中的正则表达式语法</h2><p>首先说明java 中的正则表达式与普通的不一样,java中 ‘\‘ 表示的是要插入一个正则表达式的反斜杠,所以之后的字符具有特殊意义.所以在java中一个’\‘代表着其他语言中的一个’\’.为什么这么做呢,是因为java中字符串是不能有’\’的,如果有的话就必须得插入’\‘表示转义.所以在java字符串中就有了’\‘表示正则中的一个’\’了.这是java语言要求的.<br>下面来看一下具体用法</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">说明</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center">\</td><td style="text-align:center">将下一个字符标记为特殊字符,就是转义字符.</td><td style="text-align:center">例如 ‘\n’ 匹配 换行, ‘\\‘匹配’\‘.</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">匹配字符流的第一个字符</td><td style="text-align:center">例如”^d.*” 匹配 以d开头的字符串</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">匹配字符流的最后一个字符</td><td style="text-align:center">　如上　</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">零次或多次匹配前一个字符</td><td style="text-align:center">例如 “zo*” 匹配 “zoo” 和 “z” “zo”</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">一次或多次匹配前一个字符</td><td style="text-align:center">例如 “zo+” 匹配 “zoo” 和 “zo” 但是不匹配 “z”</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">匹配零次或一次之前的字符</td><td style="text-align:center">例如 “1?” 匹配”1” 和 “” 空</td></tr><tr><td style="text-align:center">{n}</td><td style="text-align:center">n为非负数,正好匹配前一个字符n次</td><td style="text-align:center">例如 “o{2}” 匹配 “oo”</td></tr><tr><td style="text-align:center">{n,}</td><td style="text-align:center">n为非负数,匹配至少n此</td><td style="text-align:center">如上</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:center">匹配n到m次之前的字符</td><td style="text-align:center">如上</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">匹配任意字符</td><td style="text-align:center">例如 “a.” 匹配 “ab” “ac” “ad”等</td></tr><tr><td style="text-align:center">(pattern)</td><td style="text-align:center">匹配 pattern 并捕获该匹配的子表达式.</td><td style="text-align:center">例如 “(ab?)” 匹配 “a” “ab”</td></tr><tr><td style="text-align:center">x&#124;y</td><td style="text-align:center">匹配x或者y字符</td><td style="text-align:center">“a&#124;b” 匹配 “a” 或 “b”</td></tr><tr><td style="text-align:center">[^abc]</td><td style="text-align:center">反向字符集 匹配非括号内的字符</td><td style="text-align:center">“[^123]” 匹配不是字符1 2 3 的所有字符</td></tr><tr><td style="text-align:center">[a-z]</td><td style="text-align:center">匹配a到z之间的所有字符</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">　边界字符　</td><td style="text-align:center">例如 “er\b” 匹配 “never”中的er,但是不匹配”verb”中的er</td></tr><tr><td style="text-align:center">\B</td><td style="text-align:center">非边界字符</td><td style="text-align:center">和上面反过来</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">匹配数字字符</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">\D</td><td style="text-align:center">匹配非数字字符</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">\n</td><td style="text-align:center">换行符</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">\s</td><td style="text-align:center">匹配任意空白字符</td><td style="text-align:center">包括空格符,制表符,换页符</td></tr><tr><td style="text-align:center">\S</td><td style="text-align:center">匹配任意非空白字符</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">\w</td><td style="text-align:center">匹配任意字类字符　</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">\W</td><td style="text-align:center">匹配任意非字类字符</td></tr></tbody></table><h2 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h2><p>具体看看Pattern的用法,对象如其名,是一个匹配模式的编译表示.在java中不能直接构造出来,只能通过静态方法complie()来获取Pattern实例.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pattern pattern =  Pattern.compile(<span class="string">"\\d+"</span>);</span><br><span class="line">System.out.println(pattern.pattern()); <span class="comment">// 输出 \d+</span></span><br></pre></td></tr></table></figure></p><p>此语句就返回一个匹配模式,此模式匹配全部的数字.</p><h3 id="Pattern-split-CharSequence-input"><a href="#Pattern-split-CharSequence-input" class="headerlink" title="Pattern.split(CharSequence input)"></a>Pattern.split(CharSequence input)</h3><p>Pattern 有一个split方法,这个方法与String.split()方法是一样的.返回用指定字符分割的字符数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern pattern =  Pattern.compile(<span class="string">"\\d+"</span>);</span><br><span class="line">String[] strs =  pattern.split(<span class="string">"nihao123hello123word"</span>);</span><br><span class="line">[nihao, hello, word]  <span class="comment">// 输出</span></span><br></pre></td></tr></table></figure></p><h3 id="matches-String-regex-CharSequence-input"><a href="#matches-String-regex-CharSequence-input" class="headerlink" title="matches(String regex, CharSequence input)"></a>matches(String regex, CharSequence input)</h3><p>这个方法是返回一个boolean值,判断输入是否与指定模式匹配.这里匹配是要全部匹配<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern.matches(<span class="string">"\\d+"</span>,<span class="string">"12312312"</span>);  <span class="comment">//true</span></span><br><span class="line">Pattern.matches(<span class="string">"\\d+"</span>,<span class="string">"123a12312"</span>); <span class="comment">//false  a不匹配</span></span><br><span class="line">System.out.println(Pattern.matches(<span class="string">"\\d+"</span>,<span class="string">""</span>)); <span class="comment">// false ,+ 说明一个或多个,空不匹配</span></span><br></pre></td></tr></table></figure></p><h3 id="matcher-CharSequence-input"><a href="#matcher-CharSequence-input" class="headerlink" title="matcher(CharSequence input)"></a>matcher(CharSequence input)</h3><p>返回一个Matcher类,Matcher类提供了比Pattern更为多的功能,它能够匹配多次,并且有分组支持.</p><h2 id="Matcher类方法"><a href="#Matcher类方法" class="headerlink" title="Matcher类方法"></a>Matcher类方法</h2><h3 id="matchers-lookingAt-find"><a href="#matchers-lookingAt-find" class="headerlink" title="matchers() / lookingAt() / find()"></a>matchers() / lookingAt() / find()</h3><p>Matcher类提供了三个匹配操作方法,三个方法都返回boolean值,匹配到时返回true,匹配不到返回false .<br>matchers()方法是对整个字符串进行匹配,只有整个字符串都匹配了才返回true<br>lookingAt() 只是对开头的字符进行匹配,只要开头有符合的,就返回true<br>find()对字符串匹配,匹配到的字符串可以在任意位置.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Pattern pattern =  Pattern.compile(<span class="string">"\\d+"</span>);</span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="string">"223322"</span>);</span><br><span class="line">        matcher.matches();  <span class="comment">// true</span></span><br><span class="line">        matcher.lookingAt(); <span class="comment">// true</span></span><br><span class="line">        matcher.find(); <span class="comment">// true </span></span><br><span class="line">        Matcher m2 = pattern.matcher(<span class="string">"2233dd"</span>);</span><br><span class="line">        m2.matches(); <span class="comment">// false  全部匹配才可以</span></span><br><span class="line">        m2.lookingAt(); <span class="comment">// true  开头有匹配的可以</span></span><br><span class="line">        m2.find(); <span class="comment">// true 任意地方匹配</span></span><br><span class="line">        Matcher m3 = pattern.matcher(<span class="string">"dd2233"</span>);</span><br><span class="line">        m3.matches(); <span class="comment">// false</span></span><br><span class="line">        m3.lookingAt(); <span class="comment">// false 开头没有匹配</span></span><br><span class="line">        m3.find(); <span class="comment">// true 任意有匹配可以</span></span><br></pre></td></tr></table></figure></p><h3 id="start-end-group"><a href="#start-end-group" class="headerlink" title="start() / end() / group()"></a>start() / end() / group()</h3><p>使用matchers(),lookingAt(),find()方法后就可以使用这三个方法得到更加详细的信息<br>start() 返回匹配的子字符串在索引中的位置<br>end() 返回匹配的子字符串的最后一个字符在索引的位置<br>group() 返回匹配到的子字符串. 分组是在自己定义的匹配模式中定义的.用()包起来的.<br>这里分组有一个规定 :<br>捕获组是通过从左至右计算其开括号来编号,第一个括号编号从1开始.例如表达式中((A)(B(C))).编号从从1开始是如下的:</p><ol><li>((A)(B(C)))</li><li>(A)</li><li>(B(C))</li><li>(C)</li></ol><p>代码实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里只介绍group操作,可以把group操作想成是m.group()操作看成是s.substring(m.start(),m.end());</span></span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"(\\d+)((abc)+)"</span>);</span><br><span class="line">Matcher matcher1 = p.matcher(<span class="string">"900abcabc"</span>);</span><br><span class="line">System.out.println(matcher1.matches()); <span class="comment">// true 匹配到了整个字符串</span></span><br><span class="line">System.out.println(matcher1.group()); <span class="comment">// 返回整个字符串</span></span><br><span class="line">System.out.println(matcher1.group(<span class="number">1</span>)); <span class="comment">// 第一个匹配的 全部的数字 所以是 900</span></span><br><span class="line">System.out.println(matcher1.group(<span class="number">2</span>)); <span class="comment">// 第二个匹配的 abcabc</span></span><br><span class="line">System.out.println(matcher1.group(<span class="number">3</span>)); <span class="comment">// 第三个括号 一个abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面看lookingAt()方法</span></span><br><span class="line">Pattern p1 = Pattern.compile(<span class="string">"(\\d+)(abc)"</span>);</span><br><span class="line">Matcher matcher2 = p1.matcher(<span class="string">"900abcbbd"</span>);</span><br><span class="line">matcher2.lookingAt(); <span class="comment">// true  looking只需要匹配开头就可以了.所以这里是true,如果用matches则返回false</span></span><br><span class="line">System.out.println(matcher2.group(<span class="number">1</span>)); <span class="comment">// 900 匹配第一个括号中的内容</span></span><br><span class="line">System.out.println(matcher2.group(<span class="number">2</span>)); <span class="comment">// abc 后面的则不匹配</span></span><br></pre></td></tr></table></figure></p><p>find方法,find方法比较不一样,所以需要单独来讲<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        Pattern p2 = Pattern.compile(<span class="string">"(\\d+)(a+)"</span>);</span><br><span class="line">        Matcher matcher3 = p2.matcher(<span class="string">"900aa bcbb900aa bcbb900aa bcbbabc"</span>);</span><br><span class="line">        <span class="keyword">while</span> (matcher3.find())&#123;</span><br><span class="line">            System.out.println(matcher3.group());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">输出</span><br><span class="line"><span class="number">900</span>aa   </span><br><span class="line"><span class="number">900</span>aa</span><br><span class="line"><span class="number">900</span>aa</span><br></pre></td></tr></table></figure></p><p>find方法将会找到整个串中所有符合的子串.当然也可以使用group(1)匹配第一个分组,从而找到所有的字符串.在这里有一个点就是因为find()方法会匹配整个字符串符合模式的子串.所以每次调用find()方法,就会找到下一个匹配此模式的子串.所以在调用了一次find()方法就需要在调用一次group()方法来获得所匹配的子串.这是因为在matcher中记录了一个当前匹配的位置,下一次在匹配的时候会从当前位置开始进行匹配.</p><h3 id="appendReplacement-StringBuffer-sb-String-replacement-和-appendTail-StringBuffer-sb"><a href="#appendReplacement-StringBuffer-sb-String-replacement-和-appendTail-StringBuffer-sb" class="headerlink" title="appendReplacement(StringBuffer sb, String replacement) 和 appendTail(StringBuffer sb)"></a>appendReplacement(StringBuffer sb, String replacement) 和 appendTail(StringBuffer sb)</h3><p>appendReplacement这个方法主要是为了用来为字符串做替换的.通过将匹配到的字符串替换成指定的字符串到字符串缓冲区.appendTail从添加位置开始从字符序列读取字符然后加入到缓冲区.一般是用来给appendReplacement方法替换过之后调用它来复制剩余的序列.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Pattern p3 = Pattern.compile(<span class="string">"cat"</span>);</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        Matcher matcher4 = p3.matcher(<span class="string">"one cat and two cats in the word"</span>);</span><br><span class="line">        <span class="keyword">while</span> (matcher4.find())&#123;</span><br><span class="line">            matcher4.appendReplacement(sb,<span class="string">"dog"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在这里输出的结果是最后一次匹配替换过后的字符串  one dog and two dog</span></span><br><span class="line">        matcher4.appendTail(sb); <span class="comment">// 这里通过appendTail()进行收尾工作,将结尾的字符添加到缓冲区中.</span></span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">输出</span><br><span class="line">one dog and two dogs in the word</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 正则表达式 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java编译优化</title>
      <link href="/2019/04/21/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/"/>
      <url>/2019/04/21/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="java编译"><a href="#java编译" class="headerlink" title="java编译"></a>java编译</h2><p>java编译器为我们做了很多优化,比如在java中泛型并不是真正的泛型,在编译的时候会进行泛型擦除,使用的时候再进行类型转换.或者Integer自动装箱和拆箱.foreach循环遍历等等.</p><h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p>在java中泛型并不是真正的泛型,因为有一个java早期没有泛型的时候都是通过Object来代替泛型的,因为java中每个对象都是继承自Object的.在通过类型转换来实现泛型.现在有了泛型.通过泛型来指定类型.但是这个泛型也不是真正的泛型.在编译期间都会进行泛型擦除.使其变为普通的类型.下面来看个例子<br>源代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; ls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ls.add(<span class="number">1</span>);</span><br><span class="line">ls.add(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> a = ls.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure></p><p>编译之后的字节码反编译过来的文件.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList var1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        var1.add(<span class="number">1</span>);</span><br><span class="line">        var1.add(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> var2 = (Integer)var1.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(var2);</span><br></pre></td></tr></table></figure></p><p>这里可以看到这个时候哦ArrayList已经没有泛型了,只是他原来的类型.在获取字段的时候会有一个类型转换的操作.所以有一点就是在进行方法重载的时候ArrayList<integer> 和 ArrayList<double> 类型是一样的,编译会出现错误.<br>也正是有了泛型擦除,就有了一个问题,你可以向一个定义了类型的容器中添加其他类型的变量.看下面代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Class&lt;? extends ArrayList&gt; cls = (Class&lt;? extends ArrayList&gt;) ls.getClass();</span><br><span class="line">Method method = cls.getDeclaredMethod(<span class="string">"add"</span>,Object.class);</span><br><span class="line">method.invoke(ls,<span class="number">10</span>);</span><br></pre></td></tr></table></figure></double></integer></p><p>这里通过反射向list中添加Integer变量,并没有报错,但是,这个时候如果在运行时候调用get()方法,那么如上所说,会在get方法前加入强制类型转换,所以会在运行时期报错.</p><h2 id="Integer-Double-自动装箱与拆箱"><a href="#Integer-Double-自动装箱与拆箱" class="headerlink" title="Integer. Double 自动装箱与拆箱"></a>Integer. Double 自动装箱与拆箱</h2><p>在java中提供了自动装箱与拆箱的功能,就是把int变成Integer对象或者反过来.因为在泛型中只能存储对象而不能是普通值.而且在Integer或者Long中都有自己的数字缓存.都缓存了从-128~127之间的数字.意思就是在这些数字范围内的Integer对象都引用的是同一个对象.在看一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="number">128</span>;</span><br><span class="line">    Integer b = <span class="number">128</span>;</span><br><span class="line">    Integer c = <span class="number">1</span>;</span><br><span class="line">    Integer d = <span class="number">2</span>;</span><br><span class="line">    Integer e = <span class="number">3</span>;</span><br><span class="line">    Integer f = <span class="number">3</span>;</span><br><span class="line">    System.out.println(f == e);</span><br><span class="line">    System.out.println(c+d == e );</span><br><span class="line">    System.out.println(a==b);</span><br><span class="line">&#125;</span><br><span class="line">输出:</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure></p><p>这里可以看到从128开始就不缓存了.但是在128之前的数字都是缓存的.都引用的是同一个缓存的对象.但是在代码中最后还是使用equals来比较对象.这是最稳妥的.</p><h2 id="foreach循环遍历"><a href="#foreach循环遍历" class="headerlink" title="foreach循环遍历"></a>foreach循环遍历</h2><p>foreach循环遍历是代码中很常见的一个用法,但是他底层是怎么实现的呢,很多人不知道.其实也是很简单的,下面看实例;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 普通容器变为迭代器遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: ls)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// foreach循环在数组中变为普通的for遍历循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: arr)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码编译过后就能看到<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">        ArrayList var1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        Iterator var2 = var1.iterator();</span><br><span class="line">        <span class="comment">//这里能看到 循环遍历变成了通过迭代器遍历</span></span><br><span class="line">        <span class="keyword">int</span> var3;</span><br><span class="line">        <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">            var3 = (Integer)var2.next();</span><br><span class="line">            System.out.println(var3);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] var7 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span>[] var3 = var7;</span><br><span class="line">        <span class="keyword">int</span> var4 = var7.length;</span><br><span class="line">        <span class="comment">// 数组的变成了普通的遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">            <span class="keyword">int</span> var6 = var3[var5];</span><br><span class="line">            System.out.println(var6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>循环遍历在普通容器中变成了迭代器遍历,在数组中变成了普通的for遍历.这也是为什么循环遍历的容器必须实现iterator接口的原因.</p><h2 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h2><p>变长参数其实就是一个数组,取决于你传入了几个参数.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable... objs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Closeable obj: objs)&#123;</span><br><span class="line">            obj.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>字节码反编译过后的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable... var0)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Closeable[] var1 = var0;</span><br><span class="line">        <span class="keyword">int</span> var2 = var0.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">            Closeable var4 = var1[var3];</span><br><span class="line">            var4.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>能够看到实际上objs就是一个数组,应该就是通过得到一个数组,然后在循环遍历.所以说尽量少用变长参数,因为变长参数会有一个内部的数组建立的过程,所以速度肯定会降低.</p><h2 id="int-short-优化"><a href="#int-short-优化" class="headerlink" title="int short 优化"></a>int short 优化</h2><p>平时编写代码的时候可能不注意,但是看的话会发现编译器做了很多优化,比如就是int优化,这也是不小心发现的.例如下面的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">128</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">255</span>;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">1000000</span>;</span><br><span class="line">        b+=<span class="number">10000000</span>;</span><br><span class="line">        <span class="keyword">char</span> g = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">double</span> e = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">double</span> f = <span class="number">1000000</span>;</span><br><span class="line">        System.out.println(a+b+c+d);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>编译过后<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> var1 = <span class="number">10</span>;    <span class="comment">//int a = 10;</span></span><br><span class="line">    <span class="keyword">short</span> var2 = <span class="number">128</span>;   <span class="comment">// int b = 128;</span></span><br><span class="line">    <span class="keyword">short</span> var3 = <span class="number">255</span>;  <span class="comment">// int c = 255;</span></span><br><span class="line">    <span class="keyword">int</span> var4 = <span class="number">1000000</span>;  <span class="comment">// int d = 1000000;</span></span><br><span class="line">    <span class="keyword">int</span> var10 = var2 + <span class="number">10000000</span>;  <span class="comment">// b+=10000000;  这里就是当数值变大了之后就会发现新申请了一个数值，之后变量var2的使用都变成了var10.</span></span><br><span class="line">    <span class="keyword">boolean</span> var5 = <span class="keyword">true</span>;  <span class="comment">//char g = 100;</span></span><br><span class="line">    <span class="keyword">double</span> var6 = <span class="number">20.0</span>D;  <span class="comment">//double e = 20;</span></span><br><span class="line">    <span class="keyword">double</span> var8 = <span class="number">1000000.0</span>D;  <span class="comment">//double f = 1000000;</span></span><br><span class="line">    System.out.println(var1 + var10 + var3 + var4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>可以看到当int的值比较小的时候可能会用byte或者short来代替int.<br>当此值变成比这个值更大的值的时候就能发现这个变量变了.var2变成var10,在之后用到var2的地方也都变成了var10.<br>但是细看这里的编译过后的代码就会发现一个问题,就是在char变量g变成了boolean类型.这里也就是编译器的第二个优化了.这里它会看此变量是否用过,如果在只有的程序中没有用过,那么就会赋值一个boolean类型.因为boolean类型可能是占用内存最小的了.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal概览</title>
      <link href="/2019/04/15/ThreadLocal%E6%A6%82%E8%A7%88/"/>
      <url>/2019/04/15/ThreadLocal%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h2 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h2><p>ThreadLocal是java中将非线程安全变为线程安全的一个神器.通过为每一个线程保存一个线程本地变量来保证数据的安全性,通过set()和get()方法来使用. 因为每个线程都拥有变量的副本.不和其他线程变量交互,所以不会出现线程安全问题.所以这里有一个点就是ThreadLocal应用的场景应该是变量的访问是没有依赖关系的,每个线程只和自己的数据副本打交道.    </p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//每个线程有自己的HashCode,并不是根据线程计算的,而是Local分配的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来计算下一个线程的hash值,threadLocalHashCode就是根据这个Integer计算出来的,每次增加一个一个HASH_INCREMENT的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">        <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">//hash增量,hash值的增量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看代码可以知道首先获取当前线程,然后通过getMap获取到一个ThreadLocalMap.如果当前线程存在map的话,就从map中取出当前线程所需要的值.注意这里getEntry中传入的是<strong>this</strong>,不是当前线程t.因为map中存储的是键值对是ThreadLocal变量与ThreadLocal变量存储的值的对应.<br>接下来看getMap方法</p><h3 id="getMap"><a href="#getMap" class="headerlink" title="getMap()"></a>getMap()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里就是获得线程自己的ThreadLocalMap.每个线程都有一个ThreadLocal变量.在初始的时候是空的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是线程中的ThreadLocalMap变量</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p><p>然后上面获取到的.如果获取到的map不是空的,说明已经设置过本地变量.因此就直接获取到此map的键值对.然后返回所要的值.<br>如果map为空,就通过setInitialValue()方法设置初始值.</p><h3 id="setInitialValue"><a href="#setInitialValue" class="headerlink" title="setInitialValue()"></a>setInitialValue()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T value = initialValue();</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是用来给子类继承的.在ThreadLoacl中SuppliedThreadLocal内部类继承了此类,用来实现这个方法.设置初始值</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个代码也很清晰明了了,如果当前线程有本地map,就直接添加默认值,如果没有,就使用createMap()创建一个</p><h3 id="createMap"><a href="#createMap" class="headerlink" title="createMap()"></a>createMap()</h3><p>创建Map其实就是给当前线程的ThreadLocal赋值.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>接下来细看一下ThreadLocalMap类的内部实现</p><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>在这里map中的Entry存储的key是一个ThreadLocal变量,值就是设置的值.这里有一点要搞明白.每个线程都有一个ThreadLocalMap的变量.通过这个变量能够找到当前线程存储的每个的ThreadLocal所对应的值.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里在说一下,这里使用的是弱引用.是为了让在线程将此值释放掉后能够让虚拟机进行回收,当线程本地释放变量的时候,不需要在对map进行主动移除,虚拟机就会自动回收掉无用变量.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            Object value;</span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//省略一些基本的map的操作与字段,里面也是使用数组来存储数据.使用线性探测来解决hash冲突.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>重点看一下getEntry,通过得到当前线程保存的ThreadLocal变量.然后在通过这个值找到对应表中的位置,在这里有一点可能会出现为空或者这个key值不是当前线程保存的本地ThreadLocal的变量的情况.通过在线性探测法遍历整个数组. 这里就有个问题了,在线性探测法中,如果自己原本的位置有数据,然后自己向推了一格.但是之后前面的节点又被删除了,这个时候就会出现找到的位置节点是空的情况.</p><p>在说线性探测法的缺陷改进之前,先看一下ThreadLocal的删除操作.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// 调用map的remove操作</span></span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// for循环.向后遍历找到,如果碰见空,则直接返回.如果遇见自己,则执行删除操作.</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">            e != <span class="keyword">null</span>;</span><br><span class="line">            e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面看到删除节点时候会调yoga此方法.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 先将数组中的两个值键值对设置为空,</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 设置size--</span></span><br><span class="line">    size--;</span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">            (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">            i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 如果此ThreadLocal为空,则删掉此项值</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这个方法大概意思就是在删除某个节点的时候,会判断在他后面的节点有多少个可以向前移动,如果可以向前移动,就向前移动(<strong>那些经过二次探测或者三次探测的节点才有可能向前移动</strong>).  直到碰见一个空节点位置.</p><p>删除讲完了,对于线性探测法的缺点的改进也就很容易明白了,不会出现那种情况.因为每一次删除一个节点.都会将之后的连续的不为空的节点向前移(<strong>这里向前移动最多移动到自己节点的hash值与上len值的位置</strong>).也就是把删除掉的那些空位给补上.</p><h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里set方法首先就获取当前线程,在获取一个ThreadLocalMap(),然后设置值</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里可能会有一些人对这个ThreadLocal还有点懵逼,通过一个完整的例子来看一下.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal1 = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure></p><p>比如说这里面有两个ThreadLocal,上面讲过,线程中存储的是一个ThreadLocalMap,map中存储的是ThreadLocal变量与值的映射.比如这里,线程中的threadLocalMap中会有两对键值对,一个是threadLocal的,另一个是threadLocal1的.当然,拥有这两个键值对的前提是调用了threadLocal.set()方法或者是get方法.如果调用了threadLocal.set(str)方法,那么就会在此线程的map中添加一个映射,就是threadLocal-&gt;str的映射.如果在获取的时候,通过获取线程的threadLocalMap,找到此threadLocal对应的值,就是此线程保存的这个threadLocal的值了.</p><p>ThreadLocal的实现原理主要就是通过每个线程保存一个ThreadLocalMap的变量,在ThreadLocal中保存的ThreadLoca =&gt; value 的键值对映射的一个map,通过找到线程对应的threadlocalmap,然后在从threadlocalmap中找到对应的threadlocal对应的值,就能够获取到对应的变量副本.</p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰器模式</title>
      <link href="/2019/04/15/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/15/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式就是动态地给一个对象添加一些额外的职责,扩展对象的功能.对于增加功能来说,装饰器模式比生成子类更为灵活.  </p><h2 id="装饰器模式的结构"><a href="#装饰器模式的结构" class="headerlink" title="装饰器模式的结构"></a>装饰器模式的结构</h2><p>通常来说,给一个对象添加一些额外的功能,可以通过继承来实现,但是这并不能动态地给对象添加职责,如果要添加一些职责,只能改变原有对象. 这时候就需要有装饰器模式出现了. 装饰器模式并不是利用继承和多态来扩展和复用功能,是基于对象组合的方式 .  </p><p>装饰器模式的角色有:</p><ol><li>抽象的对象角色    给出一个抽象接口,以规范准备接受附加功能的对象</li><li>具体的被装饰者    一个将要接受附加功能的具体实现,就是被装饰者,需要实现抽象的对象接口</li><li>装饰抽象类　　持有一个被装饰者的实例,并实现抽象对象接口,为具体的装饰功能提供一个统一的接口</li><li>具体装饰角色 就是具体的装饰对象,继承子装饰抽象类,是用来给被装饰者添加附加功能的.</li></ol><p>看类图:</p><p><img src="/2019/04/15/装饰器模式/Decorator.png" alt></p><p>装饰对象和被装饰对象实现的都是同一个接口,装饰对象也可以是一个接口,下面还可以有更多的具体的装饰对象.通过调用一个方法来装饰被装饰对象,以此来添加新的功能附件.</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>比如我们现在要实现一个给人动态添加服装的功能.<br><strong>首先定义一个接口,就是被装饰者实现的接口</strong> 里面有一个方法就是为人动态添加衣服<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>接着实现具体要穿衣服的人</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">(String name, String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setName(name);</span><br><span class="line">        <span class="keyword">super</span>.setSex(sex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"装扮"</span>+getName()+getSex());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>在实现装饰抽象类</strong> 定义一个统一的装饰接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decorator</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(person != <span class="keyword">null</span>)&#123;</span><br><span class="line">            person.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>具体装饰实现类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TShirts</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"穿T恤"</span>);</span><br><span class="line">        <span class="keyword">super</span>.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shorts</span> <span class="keyword">extends</span> <span class="title">Decorator</span>  </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"穿短裤"</span>);</span><br><span class="line">        <span class="keyword">super</span>.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person man = <span class="keyword">new</span> Man(<span class="string">"spj"</span>,<span class="string">"男"</span>);</span><br><span class="line">        TShirts shirts = <span class="keyword">new</span> TShirts();</span><br><span class="line">        Shorts shorts = <span class="keyword">new</span> Shorts();</span><br><span class="line">        shirts.decorator(man);</span><br><span class="line">        shorts.decorator(shirts);</span><br><span class="line">        shirts.show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出:</span><br><span class="line">穿短裤</span><br><span class="line">穿T恤</span><br><span class="line">装扮spj男</span><br></pre></td></tr></table></figure><p>这个例子中每一个装饰对象都会调用自己装饰的那个对象,这个样子其实有点像责任链模式,不过责任链是将消息传递出去,而装饰模式是修饰已经已有的对象,一层一层的装饰.为对象动态的添加功能,最后形成一个完整的有用的对象.  </p><p>在java中 输出输入流就是使用到了装饰器模式,在java中我们经常能见到这种写法.比如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"文件1"</span>);</span><br><span class="line">BufferedInputStream bfi = <span class="keyword">new</span> BufferedInputStream(in);</span><br><span class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(bfi);</span><br></pre></td></tr></table></figure></p><p>在这中写法中应该能够看出来这就是应用了装饰器模式,所有的这些输入流都继承InputStream类,通过一层一层的包装,来为输入流添加不同的功能.而他们每个类都有着上一层的一个实例对象,通过对此实例对象进行包装,就能够添加想要的功能.</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码阅读</title>
      <link href="/2019/04/14/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2019/04/14/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>java.util包下面的工具类,键值对存储数据.通过对键值计算hash值,来存储到对应的位置.<br>jdk1.8中底层使用数组加链表实现.键值对通过一个内部类的Node节点来表示.采用链地址法解决hash冲突,如果一条链上的节点超过给定阈值会变为红黑树.默认为8.<br>在hashmap中是可以存储空key和value的.如果为空,则位置为0.</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>hashmap继承了AbstractMap类,实现Map接口和克隆接口.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></p><h2 id="主要内部类"><a href="#主要内部类" class="headerlink" title="主要内部类"></a>主要内部类</h2><h3 id="Node-继承Map-Entry"><a href="#Node-继承Map-Entry" class="headerlink" title="Node  继承Map.Entry"></a>Node  继承Map.Entry</h3><ul><li>final int hash; 此节点保存的键值的hash值</li><li>final K key; 此节点的键</li><li>V value; 值</li><li>Node&lt;K,V&gt; next; 下一个节点,主要在有hash冲突的地方指向下一个几点<blockquote><p>Node(int hash, K key, V value, Node&lt;K,V&gt; next)  初始化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>这里计算hashCode是用key和value的hash值异或得到.<br>剩下的是获取键,获取值,设置值,equals等方法,比较简单</p><h3 id="KeySet"><a href="#KeySet" class="headerlink" title="KeySet"></a>KeySet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">//容量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="comment">//调用父类的clear函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="comment">//返回key的iterator</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> KeySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mc = modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="HashIterator"><a href="#HashIterator" class="headerlink" title="HashIterator"></a>HashIterator</h3><p>遍历map的迭代器,定义了遍历的基本操作.KeyIterator,ValueIterator和EntryIterator都继承自此类,在实现了一个返回Node的不同值.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">    <span class="comment">//期望的modcount,在遍历期间不希望有别的线程更改过此map,如果改过,则抛出异常</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">    <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化,找到第一个不为空的节点</span></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="keyword">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回下一个节点,</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        <span class="comment">//首先返回值应该是下一个要返回的节点</span></span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="comment">//这里在继续寻找下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移除节点使用外部类的方法移除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        K key = p.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul><li>DEFAULT_INITIAL_CAPACITY,    默认为16,初始化默认容量大小</li><li>MAXIMUM_CAPACITY,   最大容量大小 ,为 1&lt;&lt;30</li><li>DEFAULT_LOAD_FACTOR,   加载因子. 默认0.75</li><li>TREEIFY_THRESHOLD,      链表树化的阈值,超过这个值,链表转为红黑树.默认为8</li><li>UNTREEIFY_THRESHOLD,      红黑树转为链表的阈值,当红黑树的节点个数小于此值会变为链表.默认为6</li><li>MIN_TREEIFY_CAPACITY,      这个值就是最小的树化table数组的长度,如果数组长度小于这个值,则先不进行树化,先扩容来减少冲突.<h3 id="具体属性"><a href="#具体属性" class="headerlink" title="具体属性"></a>具体属性</h3></li><li>Node&lt;K,V&gt;[] table. 用来存放键值对的数组.</li><li>int size; 返回table存放了多少键值对,并不是table的长度</li><li>int modCount. 这个是在迭代的时候才会用到,因为hashMap的迭代器是fast-fail的.用这个值表示在此过程中是否有过改变,有过改变就抛出异常.</li><li>int threshold;  下一个数组长度</li><li>final float loadFactor; 加载因子</li></ul><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><p>这里一些简单的get(),set()就不说了,因为很简单.</p><h3 id="HashMap-int-initialCapacity-float-loadFactor"><a href="#HashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="HashMap(int initialCapacity, float loadFactor)"></a>HashMap(int initialCapacity, float loadFactor)</h3><p>初始化方法,这里只看这一个.其他的都是通过调用这个方法的.所以能看出来在初始化的时候真正的存数据的表并没有初始化.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化容量小于0,直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">//如果大于默认的最大容量,则为最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//这里就是计算出下一次的table的长度.</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="tableSizeFor-int-cap-方法"><a href="#tableSizeFor-int-cap-方法" class="headerlink" title="tableSizeFor(int cap) 方法"></a>tableSizeFor(int cap) 方法</h3><p>这个方法设计的很巧妙,通过5次移位运算可以返回一个大于等于cap的最小的2的n次方的数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  减一是为了防止cap本身就为2的n次方</span></span><br><span class="line">    <span class="comment">// 这里一个数字首先无符号右移1位,然后在或运算,会将他最高位为1的右边一位也变为1.</span></span><br><span class="line">    <span class="comment">// 比如随便来一个数字  为010010111000000...</span></span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//经过第一次运算后,很明显为1的最高位和下一位都为1.数字为 01101....</span></span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//第二次运算之后,这两位1在向右移动两位,现在最高位最少有4个1.为011110....</span></span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="comment">//以此类推,在最后右移16位的时候,最后会导致cap的最高位为1的位置之后的全部为1.很容易就找见了大于等于cap的最小的2的n次方的数</span></span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="hash-Object-key"><a href="#hash-Object-key" class="headerlink" title="hash(Object key)"></a>hash(Object key)</h3><p>计算key的hash值,通过高16位与上低16为保证每一位都能够参与运算.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict-方法"><a href="#putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict-方法" class="headerlink" title="putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)方法"></a>putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">//首先判断table是否为空,如果为空,则先resize扩容.</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">            <span class="comment">//判断key要存储的位置是否有Node.如果没有则直接插入.有的话向下走</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//这里表示每个table对应的位置有节点,发生冲突,向链表或者红黑树插入节点.</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//如果链首节点的hash值和key值都与要插入的值相等,则把将e指向该节点..</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">                <span class="comment">//如果这条链已经转化成了红黑树,则通过红黑树的插入方式插入</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//这里找到链表的最后一个节点,如果在找的过程中,遇到了和自己key一样的节点将e指向此节点.在插入后如果长度大于等于8则把链表转化为树</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里e指的是key与要插入的key相等的节点.所以这个时候会判断上面是否要求存在并替换,如果为false,则不替换</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                <span class="comment">//这个方法是给linkedHashMap用的,这里用不到</span></span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//modCount加1,表示这个时候被改过了.</span></span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">//这个方法也是个linkedHashMap用的,这里用不到,没有实现.</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h3><p>接着看resize()方法,在这里,resize总是将容量大小扩容到2的n次方大小,因为这个样子有利于rehash.还有利于找key在数组中的位置.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        <span class="comment">//保存下来旧的table.</span></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果旧的容量大于0,并且大于默认最大值也就是1&lt;&lt;30,threshold也就是下一次的要扩容到threshold大小.直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//新的容量变为原来的2被,新的threshold也变为原来的2倍,因为有一个tablesizefor()方法,导致hashMap的容量只能是2的n次方</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里是table还没有初始化的时候,等于之前的要扩容大小</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;           </span><br><span class="line">            <span class="comment">//如果oldThr也没有制定,则就是默认大小.</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//对于表中的没一个位置,复制到新表中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                        <span class="comment">//如果这个表中的节点是树的话,就用树的方式来写.</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; </span><br><span class="line">                        <span class="comment">//如果是链表的话,这里有一个小知识点,因为table的大小只能是2的n次方,所以在rehash的时候在一条链上的节点在rehash后,只能有两个位置,一个是本身i,另一个是i+oldTab.length;</span></span><br><span class="line">                        <span class="comment">//这里使用两个链表直接遍历所有的在链表上的节点,然后分为两个链表,最后给i和i+oldTab.length位置赋值</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">//如果hash与上旧的长度为0的话,说明这个节点的位置还在原处</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>扩容这里,旧的链表上的节点的位置只可能是i或者i+oldTab.length.为什么呢.举个例子.假如之前的链表长度为16,二进制为10000,现在变为32,就是100000;这个时候如果一个hash值为10的节点分别与16-1(1111)和32-1(11111)进行与运算,那么他们两个就只有可能有一位不一样,就是第5位.所以如果第5为是0,说明和以前的坐标一样,还在原位置,如果为1,则说明坐标位置应该在i+oldTabl.length的位置.</p><h3 id="removeNode-int-hash-Object-key-Object-value-boolean-matchValue-boolean-movable"><a href="#removeNode-int-hash-Object-key-Object-value-boolean-matchValue-boolean-movable" class="headerlink" title="removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable)"></a>removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable)</h3><p>移除一个节点.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//先找到key所在数组中的位置为(n-1)&amp;hash</span></span><br><span class="line">                <span class="comment">//保存一个node节点,节点表示的是要删除的节点,p表示要删除的前一个节点.</span></span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="comment">//具体删除操作,都能看懂</span></span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="public-boolean-containsValue-Object-value"><a href="#public-boolean-containsValue-Object-value" class="headerlink" title="public boolean containsValue(Object value)"></a>public boolean containsValue(Object value)</h3><p>containsValue主要就是遍历表中的节点,如果找到就返回true.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear()方法"></a>clear()方法</h3><p>简单,就是将table中的元素附空值.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java注解</title>
      <link href="/2019/04/13/java%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/04/13/java%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这两天在自己学习着写一个小型的web框架,有点像spring,但是有是轻量级的.里面用到的注解功能.但是对于自定义注解这块又不熟悉,所以专门学习了一波,做点笔记记下来.  </p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>注解是自带的.jdk中本身就有很多内置注解,比如override等等.注解的功能其实就是为一些加了注解的类,方法等赋予一些特别的含义.java中有4中元注解<br>@Target中的参数表示注解应该用在什么地方,参数类型有</p><ul><li>TYPE 类,接口(包括注解类型)或enum类型</li><li>FIELD 声明在字段上(包括enum实例)</li><li>METHOD,声明在方法上</li><li>PARAMETER,声明参数</li><li>CONSTRUCTOR,构造器的声明</li><li>LOCAL_VARIABLE,局部变量声明</li><li>ANNOTATION_TYPE,注解累心声明</li><li>PACKAGE,声明在包上</li></ul><p>@Rentention注解 表示需要在什么级别保存该注解信息,就是注解的生命周期.参数RetentionPolicy</p><ul><li>SOURCE 只保留在源文件中,被编译器丢弃</li><li>CLASS 注解在class文件中可用,但会被VM丢弃</li><li>RUNTIME 运行时保存,可以通过反射获得信息</li></ul><p>@Document 将注解包含在Javadoc中<br>@Inherited 允许子类继承父类中的注解  </p><p>举个例子,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">    <span class="meta">@interface</span> UseCases&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> "no description"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这是个声明在方法级别上的注解,使用了这个注解的方法,可以通过反射来获得注解中的内容.如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">beanUtil</span></span>&#123;</span><br><span class="line">    <span class="comment">//在这里使用了注解</span></span><br><span class="line">    <span class="meta">@UseCases</span>(id = <span class="string">"123"</span>,description = <span class="string">"123的description"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valipassword</span><span class="params">(String password)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (password.matches(<span class="string">"\\w*\\d\\w*"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UseCases</span>(id =<span class="string">"48"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encryptPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(password).reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面看测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; useCases = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Collections.addAll(useCases, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>);</span><br><span class="line">        trackUseCases(useCases, beanUtil.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trackUseCases</span><span class="params">(List&lt;Integer&gt; useCases, Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里通过反射获取到此对象的所有方法,并且在其中找到所有的使用此注解的方法.</span></span><br><span class="line">        <span class="keyword">for</span> (Method m : cl.getDeclaredMethods()) &#123;</span><br><span class="line">            <span class="comment">//获得注解的对象</span></span><br><span class="line">            UseCases uc = m.getAnnotation(UseCases.class);</span><br><span class="line">            <span class="keyword">if</span> (uc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Found Use Case:"</span> + uc.id() + <span class="string">" "</span></span><br><span class="line">                        + uc.description());</span><br><span class="line">                useCases.remove(<span class="keyword">new</span> Integer(uc.id()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">Found Use Case:<span class="number">123</span> <span class="number">123</span>的description</span><br><span class="line">Found Use Case:<span class="number">48</span> no description</span><br></pre></td></tr></table></figure></p><p>这里就完成了一个自定义注解的实现了.<br>在这里主要用到的就是两个  一个是@Target注解,里面指明了此注解要修饰的内容,例如构造器,方法,类等.还有一个是Retention注解,表明了此注解保存在哪里,有只在源码中存在,在class文件中存在,在运行时可以出现.如果要使用反射需要使用RUNTIME类型,在运行中通过反射来获得注解.<br><strong>注意</strong>:注解定义上的内容值允许有String ,基本类型,枚举类型,Annotation类型和Class类型</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>责任链模式</title>
      <link href="/2019/04/10/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/10/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>有多个对象, 每个对象都持有下一个对象的引用,这样就会形成一条责任链,请求在这条链上进行传递,知道某一对象决定处理该请求.但是发出者并不知道那个对象处理的请求.责任链模式的好处就是在隐瞒客户端的情况下,对系统进行动态的调整.<br>类结构图<br>三个继承了Handle的类组成了一个责任链,每个对象获取请求后都会看自己是否能处理,不能处理则放在最顶端.<br><img src="/2019/04/10/责任链模式/Client.png" alt></p><p><strong>handle抽象类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Handle successor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetSuccessor</span><span class="params">(Handle successor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor=successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">HandleRequest</span><span class="params">(<span class="keyword">int</span> request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>三个责任链上的对象</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandle1</span> <span class="keyword">extends</span> <span class="title">Handle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HandleRequest</span><span class="params">(<span class="keyword">int</span> request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(request&lt;<span class="number">10</span> &amp;&amp; request&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"concreteHandler1 处理请求"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            successor.HandleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandle2</span> <span class="keyword">extends</span> <span class="title">Handle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HandleRequest</span><span class="params">(<span class="keyword">int</span> request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(request&lt;<span class="number">20</span> &amp;&amp; request&gt;<span class="number">10</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"concreteHandler2 处理请求"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            successor.HandleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandle3</span> <span class="keyword">extends</span> <span class="title">Handle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HandleRequest</span><span class="params">(<span class="keyword">int</span> request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(request&lt;<span class="number">30</span> &amp;&amp; request&gt;<span class="number">20</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"concreteHandler3 处理请求"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            successor.HandleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里链上的对象分别处理不同的请求.</p><p><strong>客户端代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Handle h1 = <span class="keyword">new</span> ConcreteHandle1();</span><br><span class="line">        Handle h2 = <span class="keyword">new</span> ConcreteHandle2();</span><br><span class="line">        Handle h3 = <span class="keyword">new</span> ConcreteHandle3();</span><br><span class="line">        h1.SetSuccessor(h2);</span><br><span class="line">        h2.SetSuccessor(h3);</span><br><span class="line"></span><br><span class="line">        h1.HandleRequest(<span class="number">15</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里如果要改变处理流程,客户端代码完全可以不用改变,改变责任链上的某些对象就可以更改执行逻辑,这就是责任链模式.</p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式是用来降低类类之间的耦合的.就是将一个系统分割成许多对象,对象间的通信不彼此直接通讯,而是通过一个中介者来进行通信,进行协调对象之间的关系.如果使用直接依赖对象来进行通讯的话,如果要更改一个对象,那么和他有关联的对象都会更改.但是使用中介者模式的话,更改对象只需要改变他和中介的关系就可以了.具体的调度类或者通信通过中介来实现.     </p><p><img src="/2019/04/10/责任链模式/Colleague.png" alt>  </p><p>从类图中能够看出来两个colleague两个类之间没有关系,都是通过一个mediator类在中间协调,当这样子的类多了之后,更改起来就只需要更改mediator类就可以了,方便维护.  </p><p><strong>同事接口</strong><br>确保每一个类关联着mediator<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator mediator)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>具体同事类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealColleague1</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealColleague1</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        mediator.send(message,<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Notify</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"同事1获得消息"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealColleague2</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealColleague2</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        mediator.send(message,<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Notify</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"同事2获得消息"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>mediator类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message,Colleague colleague)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RealColleague1 colleague1;</span><br><span class="line">    <span class="keyword">private</span> RealColleague2 colleague2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColleague1</span><span class="params">(RealColleague1 colleague1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.colleague1 = colleague1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColleague2</span><span class="params">(RealColleague2 colleague2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.colleague2 = colleague2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message, Colleague colleague)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(colleague == colleague1)&#123;</span><br><span class="line">            colleague2.Notify(message);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            colleague1.Notify(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实中介模式就是实现了迪米特法则,也就是最小知道原则,对于自己依赖的类知道的越少越好,在中介这模式中,每个同事只需要知道一个中介就可以,干什么都和中介说,然后中介帮他去做事.降低耦合性. 但是中介这也有一个坏处,就是中介者的需要干的事情比较多,也就比较复杂,维护也是个不小的成本.</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8元空间</title>
      <link href="/2019/04/09/java8%E7%9A%84%E5%86%85%E5%AD%98%E6%94%B9%E5%8F%98/"/>
      <url>/2019/04/09/java8%E7%9A%84%E5%86%85%E5%AD%98%E6%94%B9%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-8元空间"><a href="#Java-8元空间" class="headerlink" title="Java 8元空间"></a>Java 8元空间</h2><p>今天想要测试方法区空间溢出会怎么样,然后调试了半天.使用String,静态变量,发现最后都是heap space OOM,经过一番学习,发现一些Java 8 中的一些改变.记录一下.<br>在java 8中方法区也就是永久代已经是不存在了,出现了一个替代者:元空间.</p><h2 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h2><p>Java　8Hotpot JVM开始使用本地化的内存存放类的元数据,这个空间也叫作元空间(Metaspace).它存储在native heap中,不受jvm内存限制,仅仅只受本地内存的限制.<br>Java Hotpot明确了元数据空间从操作系统请求空间,然后将其分成块.每个类加载器有一个块.类加载器从其块中为元数据分配空间.当类加载器卸载掉类的时候,它的块会被循环使用,或者会被操作系统回收.元数据一般使用一种内存映射文件的方法分配的空间,而不是malloc申请的空间.</p><p>这个样子的话就是表示着一个让人烦恼的问题也就是java.lang.OutOfMemoryError: PermGen的问题将不会存在.并且不需要在调整和监控这个内存空间.但是这个改变并不会消除类和类加载器的内存泄露,而是需要以一些不同的方式和学习新名词来追查这些问题.  </p><ul><li>-XX:MetaspaceSize 初始元空间大小,达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整,如果释放了大量空间,就适当减少,如果释放了很少的空间,在不超过MaxMetaspaceSize时可以增加.</li><li>-XX:MaxMetaspaceSize 最大的元空间大小,元空间大小不得超过这个值,如果超过会抛出OOM异常</li><li>-XX:MinMetaspaceFreeRatio 在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</li><li>-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</li></ul><p><strong>永久区的情况</strong></p><ul><li>永久代被完全移除</li><li>JVM参数PermSize和MaxPermSize也会被忽略.</li></ul><p><strong>元空间内存分配模型</strong></p><ul><li>绝大多数的类元数据的空间都从本地内存分配.</li><li>每个类加载器分配一个内存块的列表.</li><li>这个内存块是连续分配的.</li><li>元空间主要存储类信息,常量池,方法数据以及方法代码<!--  -->从JDK7开始就进行移除永久代的准备 比如进行如下改变</li><li>符号引用转换到了native heap中</li><li>字面量常量(String)分配到java heap中</li><li>类的静态变量转移到了java heap中</li></ul><p>在JDK8中则是完全移除了永久代 连带着设置永久代大小的参数也被移除,取而代之的是一个Metaspace,这些空间直接在堆上进行分配.<br>为什么这么更改呢: 总结一下: </p><ul><li>首先是为了融合Hotpot JVM和JRockit VM而做出的努力,因为JRockit没有永久代</li><li>字符串存放在永久代,很容易出现性能问题和内存溢出.</li><li>类即方法信息难以确定大小,尤其是现在大多数的动态代理.而永久代的大小指定比较困难,大小容易出现永久代溢出,太大会导致老年代溢出</li><li>永久代对于GC不方便,而且效率比较低</li></ul><p><strong>元空间的优势</strong></p><ul><li>以前的jar包以及自己项目的class放在永久代中,但是永久代大小固定,所以经常可能出现永久代溢出.</li><li>永久代溢出将会不存在,元空间直接与放在本地堆中,大小可以动态增长</li><li>使用元空间后,每个项目都会共享可用的class内存空间,元空间中的class可以被多个项目使用,以前的永久代则是每个项目都有自己的永久代,并且用独立的class对象</li></ul><p><strong>元空间的容量</strong></p><ul><li>默认情况下，类元数据分配受到可用的本机内存容量的限制（容量依然取决于你使用32位JVM还是64位操作系统的虚拟内存的可用性</li><li>新参数 MaxMetaspaceSize被使用,允许限制类元数据的最大本地内存,如果没有指定,会根据程序运行情况动态设置<br><strong>元空间垃圾回收</strong></li><li>如果元空间的中的元数据达到参数”MaxMetaspaceSize”设置的值,才会触发对死亡对象和类加载器的垃圾回收</li><li>元空间中的对象的位置是固定的</li><li>元空间不会单独回收某个类</li><li>元空间提高了GC的性能,省掉了GC扫描的时间.</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/2019/04/09/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/09/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式主要是用来将某个类的接口转换成客户端期望的另一个接口的形式.目的用于消除接口的不兼容问题,主要分为三类,接口的适配器模式,类的适配器模式,对象的适配器模式.  </p><h3 id="类的适配器模式"><a href="#类的适配器模式" class="headerlink" title="类的适配器模式"></a>类的适配器模式</h3><p><img src="/2019/04/09/适配器模式/Adapter.png" alt></p><p>源类 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"source的方法1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>目标类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;<span class="comment">//与source一样</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>适配器: 继承自源类,并实现目标接口,就完成了适配功能.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Source</span> <span class="keyword">implements</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"targetable的method2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样实现了target的类就有了source的类的功能.</p><h3 id="对象的适配器模式"><a href="#对象的适配器模式" class="headerlink" title="对象的适配器模式;"></a>对象的适配器模式;</h3><p>与类的适配器模式差不多,只是在将继承原有类变成了持有原有类.也可以实现相同的功能. 前两个类就不在写了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Source source ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Source source)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"targetable的method2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        source.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="接口的适配器模式"><a href="#接口的适配器模式" class="headerlink" title="接口的适配器模式"></a>接口的适配器模式</h3><p>对于接口的适配器模式主要有一种情况就是在接口的方法有很多,但是我们可能只需要几个方法,这个时候就需要一个接口的适配器出现了.写一个接口的适配器抽象类,实现接口的所有方法,当然方法也是空方法,这时候具体类就可以继承此抽象类.实现自己想要实现的方法.</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/2019/04/09/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/09/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>就是讲一个复杂对象的构建与它的表示分离,是的同样的构建过程可以创建不同的表示.<br>如果我们使用了建造者模式,用户只需要指定需要构造的类型就可以得到它们,而具体建造的过程和细节就不需要知道.<br>在这里建造者类是为了表示要建造的对象的不同种类.通过多个建造类可以实现建造一个种类的不同对象.<br>指挥者主要是为了防止在建造的时候出错,因为建造的时候可能会有很多步骤或者顺序,防止步骤缺失或者顺序相反.起到一个管理的作用  </p><p>举例:</p><h3 id="要建造的对象"><a href="#要建造的对象" class="headerlink" title="要建造的对象:"></a>要建造的对象:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String head;</span><br><span class="line">    <span class="keyword">private</span> String body;</span><br><span class="line">    <span class="keyword">private</span> String arm;</span><br><span class="line">    <span class="keyword">private</span> String leg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略get和set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="建造对象抽象类"><a href="#建造对象抽象类" class="headerlink" title="建造对象抽象类"></a>建造对象抽象类</h3><p>定义了建造对象的主要方法,方便子类继承.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Person person;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonBuilder</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildHead</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBody</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildArm</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildLeg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="具体建造实现类"><a href="#具体建造实现类" class="headerlink" title="具体建造实现类"></a>具体建造实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//瘦子类,定义瘦人的属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThinPersonBuilder</span> <span class="keyword">extends</span> <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThinPersonBuilder</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.setHead(<span class="string">"头"</span>);</span><br><span class="line">        System.out.println(<span class="string">"建造瘦子的头"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.setBody(<span class="string">"身体"</span>);</span><br><span class="line">        System.out.println(<span class="string">"建造瘦子的身体"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildArm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.setArm(<span class="string">"胳膊"</span>);</span><br><span class="line">        System.out.println(<span class="string">"建造瘦子的胳膊"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildLeg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.setLeg(<span class="string">"腿"</span>);</span><br><span class="line">        System.out.println(<span class="string">"建造瘦子的腿"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//高个类,定义高个子的属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighPersonBuilder</span> <span class="keyword">extends</span> <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HighPersonBuilder</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"建造高个的头"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"建造高个的身体"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildArm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"建造高个的胳膊"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildLeg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"建造高个的腿"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们已经把建造类写完了,但是当我们想要建造一个类的时候会在逻辑代码中写大量的如此类的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">        personBuilder.buildArm();</span><br><span class="line">        personBuilder.buildHead();</span><br><span class="line">        personBuilder.buildBody();</span><br><span class="line">        personBuilder.buildLeg();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个样子更改起来特别繁琐,这个时候就有了我们的指挥者出场了.只会这封装了建造的过程与逻辑.接下里看指挥者:</p><h3 id="指挥者"><a href="#指挥者" class="headerlink" title="指挥者"></a>指挥者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDirector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PersonBuilder personBuilder ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonDirector</span><span class="params">(PersonBuilder  pb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personBuilder = pb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">        personBuilder.buildArm();</span><br><span class="line">        personBuilder.buildHead();</span><br><span class="line">        personBuilder.buildBody();</span><br><span class="line">        personBuilder.buildLeg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过指挥者封装的建造代码,我们完全不必要知道建造的具体细节,只需要把产品的属性就是建造类给它就可以创建出一个完好的对象.    </p><p><strong>如果没有指挥者类,直接在建造者类中添加逻辑可以吗</strong><br>这里简单说一下我自己的理解吧,如果没有指挥者类,那么如果在有一个新的需求的话,比如说我要建造一个穿有衣服的人,那么这个时候就必须去更改Build()的源代码,违反了开闭原则.如果有一个指挥者类,要在创建一种结构的话,只需要在加一个新的指挥者类,指挥不同的创建方式就可以了.</p><h3 id="好处与使用场景"><a href="#好处与使用场景" class="headerlink" title="好处与使用场景"></a>好处与使用场景</h3><p>建造这模式主要用在创建一些复杂的对象,并且这些对象内部构建间的建造顺序通常是稳定的,但对象内部的构建通常面临这复杂的变化.它是的建造代码与表示代码分离,由于建造者隐藏了该产品是如何组装的,所以若需要改变一个产品的内部表示,只需要再定义一个具体的建造者就可以了.</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/2019/04/08/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/08/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式就是定义一系列的算法,并且将算法封装起来,使他们可以相互替换,并且算法的替换不会使用客户端,需要设计一个接口,为一系列实现提供一个统一的方法,多个实现类实现该j接口,设计一个抽象类,提供辅助函数.<br>从概念来看,所有的算法完成的都是相同的工作,只是实现不同.在一个上下文中完成对算法的改变,每次要新增一个算法只需要在新增一个实现类就可以<br><img src="/2019/04/08/策略模式/类图.png" alt></p><p>具体例子:</p><h2 id="抽象接口"><a href="#抽象接口" class="headerlink" title="抽象接口:"></a>抽象接口:</h2><p>封装了算法对外的同意接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sort</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="具体实现类"><a href="#具体实现类" class="headerlink" title="具体实现类:"></a>具体实现类:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        quicksort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">        <span class="comment">//具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h2><p>使用算法全都这里使用,如果想要调用不同的算法,只需要传入相应的对象即可改变算法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    Sort sort;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Sort sort)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sort = sort;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ContextInterface</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        sort.sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结 :<br>策略模式主要是封装了变化,当不同的行为对其在一个类中时,就可能会有很多的条件语句,可读性不高.所以可以将这些行为封装在独立的类中,在使用行为的类来增强代码可读性.</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2019/04/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式在很多应用程序中有很多应用.比如说一个全局的工厂,一个threadlocal等等.要实现一个好的单利对象有很多种方法,可以挑选自己最喜欢的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉式 在不要求一些性能方面可以这个样子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Simple instance = <span class="keyword">new</span> Simple();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Simple</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Simple <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进阶 懒汉式 此方法可能导致并发的时候出现故障,比如很多线程在同事使用Two</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Two instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Two</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Two <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Two();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进阶 懒汉式 线程同步 这个线程同步没问题,但是会导致争用过大</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Three</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Three instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Three</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Three <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Three();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进阶 良好的线程同步 双重检查</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Four</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Four instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Four</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Four <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (instance)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance=<span class="keyword">new</span> Four();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内部类,懒汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Five</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Five</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleFactory</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Five instance = <span class="keyword">new</span> Five();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Five <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingleFactory.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举的单例模式 jdk1.5以后推荐</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂方法模式</title>
      <link href="/2019/04/08/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/08/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>在简单工厂模式中有个坏处就是,类的创建需要依赖工厂,也就是说如果要扩展类的功能需要对工厂类进行修改,这违背了开闭原则,所以从设计考虑,有一定问题.所以有了工厂方法模式,创建一个工厂接口和多个工厂实现类,这样一旦需要增加新的功能,直接增加工厂类就可以了,不需要修改以前的代码,只需要在添加一个工厂类.符合开闭原则.<br><img src="/2019/04/08/工厂方法模式/类图.jpg" alt><br>举例:</p><h2 id="类接口"><a href="#类接口" class="headerlink" title="类接口:"></a>类接口:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类:"></a>实现类:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"mailsender"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SmsSender"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂接口"><a href="#工厂接口" class="headerlink" title="工厂接口:"></a>工厂接口:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">getSender</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂实现类"><a href="#工厂实现类" class="headerlink" title="工厂实现类:"></a>工厂实现类:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSendFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">getSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSendFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">getSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~ </span><br><span class="line"></span><br><span class="line">## 测试</span><br><span class="line">~~~java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Provider provider = <span class="keyword">new</span> MailSendFactory();</span><br><span class="line">        Sender sender = provider.getSender();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这样做的好处就是完全解耦合,当需要不同的产品是只需要改变一下工厂类即可,其余的都可以不需要改.</span></span><br></pre></td></tr></table></figure><p>这个样子就可以在扩展的时候不需要修改之前的程序就可以添加扩展功能了.这样做的好处就是扩展性好,在添加新功能的时候只需要实现一个类,实现Sender接口,然后在做一个实现工厂,实现Provider接口,就可以了.<br>借鉴与<a href="https://www.cnblogs.com/geek6/p/3951677.html" target="_blank" rel="noopener">https://www.cnblogs.com/geek6/p/3951677.html</a></p><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式与工厂模式的区别不好区分.<br>抽象工厂模式是提供一个创建一系列相关或相互依赖对象的接口,而无需制定他们具体的类.<br>抽象工厂模式的好处就是易于交换产品系列,由于具体工厂类在一个应用中一般只需要出现一次(就像Provider = new MailSendFactory()). 这就使得改变一个应用的具体工厂编的非常容易,只需要改变具体工厂即可使用不用的产品配置.<br>抽象工厂模式与工厂方法模式的不同:　　　<br>工厂方法模式:  </p><ul><li>一个抽象产品类可以派生出多个具体产品类</li><li>一个抽象工厂类可以派生出多个具体工厂类</li><li>每个具体工厂类也只能派生出一个具体产品类<br>抽象工厂模式:　　　</li><li>多个抽象产品类，每个抽象产品类可以派生出多个具体产品类</li><li>一个抽象工厂类．可以派生出多个具体工厂类</li><li>每个具体工厂类可以创建多个具体的产品类的实例.  </li></ul><p><img src="/2019/04/08/工厂方法模式/抽象工厂模式.png" alt><br>举个例子: </p><h2 id="多个抽象产品类"><a href="#多个抽象产品类" class="headerlink" title="多个抽象产品类"></a>多个抽象产品类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Recived</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recived</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂抽象类"><a href="#工厂抽象类" class="headerlink" title="工厂抽象类"></a>工厂抽象类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">getSender</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Reviced 与这个一样,就不写了.</span></span><br></pre></td></tr></table></figure><h2 id="工厂实现类-1"><a href="#工厂实现类-1" class="headerlink" title="工厂实现类:"></a>工厂实现类:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSendFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">getSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSendFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">getSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 多个实现类</span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"mailsender"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailRecived</span> <span class="keyword">implements</span> <span class="title">Recived</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recived</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"mailRecived"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsRecived</span> <span class="keyword">implements</span> <span class="title">Recived</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recived</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"smsRecived"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SmsSender"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##　测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Provider provider = <span class="keyword">new</span> MailSendFactory();</span><br><span class="line">        Recived recived = provider.getRecived();</span><br><span class="line">        Sender sender = provider.getSender();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里如果想要使用mailSend邮件协议只需要改变上面那个工厂就可以在下面整体替换邮件系统.这样子给程序的扩展性与改变性提供了更好的方法.</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单工厂模式</title>
      <link href="/2019/04/07/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/07/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>在说简单工厂模式之前首先说一下设计模式的分类以及基本原则.</p><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p>总体来说设计模式总共分为三大类:<br>创建型模式:共5种,工厂方法模式,抽象工厂模式,单例模式,建造者模式,原型模式<br>结构性模式:共7种,适配器模式,装饰器模式,代理模式,外观模式,桥接模式,组合模式,享元模式<br>行为型模式:共11中,策略模式,模板方法模式,观察者模式,迭代子模式,责任链模式,命令模式,备忘录模式,状态模式,访问这模式,中介模式,解释器模式.</p><h2 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h2><h3 id="总原则-开闭原则"><a href="#总原则-开闭原则" class="headerlink" title="总原则:开闭原则"></a><strong>总原则:开闭原则</strong></h3><p>开闭原则就是说对扩展开放,对更改关闭.在程序需要扩展的时候不去更改原有的代码,而是增加新的代码,实现一个热插拔的效果.所以一句话就是为了是程序的扩展性好,易于维护和升级.  </p><ol><li>单一职责原则<br>不要存在多余一个导致类变更的原因,也就是说一个类应该只实现一个功能,如果不然,应该把类拆开.</li><li>里氏替换原则(LSP) 是面向对象的基本原则之一,此原则是说任何基类可以出现的地方其子类一定也可以出现.LSP是继承复用的基石,只有当衍生类能够替换掉基类,并且软件功能不受影响时,基类才能真正的被复用,而衍生类也能在基类的基础上增加一些新的功能.里氏替换原则是对开闭原则的补充.实现开闭原则的的关键步骤就是抽象画,而基类与子类的继承关系就是抽象的具体实现.<br>在里氏替换原则中,子类对父类的的方法尽量不要重写与重载.因为父类定义了一个良好的对外的接口,通过这个接口可以与外界更好的交互.子类不应该随便破坏它.</li><li>依赖倒转原则: 这是开闭原则的基础.主要是面向接口编程,依赖抽象而不依赖具体,写代码用到具体类时,不与具体类交互,而与上层接口交互.</li><li>接口隔离原则: 每个接口中不存在子类用不到的方法,如果有,则应该将接口分开为两个.</li><li>最少知道原则: 一个类对自己依赖的对象知道的越少越好,也就是说无论依赖的对象有多复杂,都应该将实现封装在方法的内部,通过public提供给外界,这样当被依赖的对象变化时候,才能最少的影响该类.</li><li>合成复用原则: 首先使用组合/聚合的方式,而不是使用继承.</li></ol><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式:"></a>简单工厂模式:</h2><p>简单工厂模式按理来说不属于23中设计模式,但是使用的却挺多的.<br>简单工厂模式主要有三种实现.</p><h3 id="第一种-最普通"><a href="#第一种-最普通" class="headerlink" title="第一种 最普通:"></a>第一种 最普通:</h3><p>创建共同的接口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后有两个类实现这个接口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send1</span> <span class="keyword">implements</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是send1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">send2</span> <span class="keyword">implements</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是send2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在创建工厂类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Send <span class="title">getProduce</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"send1"</span>.equals(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Send1();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"send2"</span>.equals(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> send2();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"输入正确类型"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个是测试</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SendFactory sendFactory = <span class="keyword">new</span> SendFactory();</span><br><span class="line">        Send send = sendFactory.getProduce(<span class="string">"send1"</span>);</span><br><span class="line">        send.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里只需要传入相对应的参数就可以返回相应的类. 但是这样子有点不好就是如果类的种类变多将会使得代码变得难以维护与扩展.</p><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>将创建每个类变成多个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactoryTwo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Send <span class="title">getSend1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Send1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Send <span class="title">getSend2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> send2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此种方法比第一种方法要更好一些,因为这里通过方法名来返回实例,比普通的要更好一点.</p><p>###　第三种<br>将方法变为静态的．这样不需要建立工厂类就可以调用返回响应的方法．<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactoryTwo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Send <span class="title">getSend1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Send1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Send <span class="title">getSend2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> send2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建.</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized详解</title>
      <link href="/2019/04/06/synchronized%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/04/06/synchronized%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h3><ul><li>修饰普通方法,锁的是当前的实例对象</li><li>静态同步方法,锁的是当前类的class对象</li><li>修饰代码块,锁的是括号中的实例对象</li></ul><h4 id="java对象头-monitor"><a href="#java对象头-monitor" class="headerlink" title="java对象头 monitor"></a>java对象头 monitor</h4><h5 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h5><p>synchronized 用的锁都是java对象头中的.hotpot虚拟机中对象头主要包括两部分数据:mark word(标记字段)和klass Point(类型指针).类型指针是指向它类元数据的指针,虚拟机通过这个指针来确定对象属于那个类的实例.标记字段用来存储对象自身的运行时数据,是实现偏向锁和轻量级锁的关键.<br>标记字段:<br>用于存储对象自身的运行时数据,如哈希码(HashCode) GC分代年龄 锁状态标志 线程持有的锁 偏向线程ID 偏向时间戳等.<br>考虑到虚拟机的空间效率问题,标记字段被设计成一个非固定的数据结构以便在极小的空间存储更多的数据.会根据对象的状态复用自己的存储空间.<br><img src="/2019/04/06/synchronized详解/对象头.jpeg" alt></p><h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><p>monitor可以理解为一个同步工具,或者说是一种同步机制,被描述为一个对象.<br>所有的java对象是天生的Monitor,每个对象都有成为Monitor的潜力,在java设计中,每个java对象天生有一把看不见的锁,叫内部锁或Monitor锁.<br>Monitor锁是线程私有的数据结构,每个线程有一个monitor record列表,还有一个可用的全局列表每个被锁住的对象都会和一个monitor关联.同时monitor中有一个Owner字段 存放拥有该锁的线程的唯一标识,标识该锁被这个线程占用. </p><ul><li>每个对象都有一个monitor(监视器锁).当monitor被占用时就会处于被锁定状态,在线程进入被同步的代码块时,会首先请求获取monitor的所有权,获取不到则会阻塞.<br><img src="/2019/04/06/synchronized详解/monitor数据结构.png" alt><br>owner 初始为NULL,标识没有任何线程拥有该monitor,线程成功拥有该锁保后存该线程唯一标识,释放之后会有设置为NULL<br>EntryQ: 关联一个系统互斥锁,阻塞所有试图获得monitor失败的线程<br>RcThis 表示阻塞或waiting在该monitor上的线程个数<br>Nest 用来实现可重入锁的计数<br>HashCode 保存从对象头上copy过来的哈希码(可能还有GC age)<br>Candidate 用来避免不必要的阻塞或等待线程唤醒,每次只能有一个线程能成功用有锁,如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程,会引起不必要的上下文切换,浪费系统开销,.Candidate只有两种值,0表示没有需要唤醒的线程,1 表示要唤醒一个继任线程来竞争锁.</li></ul><h3 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h3><ol><li>轻量级加锁<br>(1). 在代码进入同步块时候,如果对象锁状态为无所状态,,虚拟机在栈中建立一个名为锁记录(Lock record)的空间,用于存储对象当前mark word字段,<br>(2). 拷贝成功后,会通过CAS操作尝试将对象的mark word 更新为指向(lock record)的指针,并且将lock record的owner指针指向Object mark word,<br>(3).如果更新成功,说明这个线程拥有了该对象的锁,并且将mark word的标志位设置为00,表示此对象处于轻量级锁定状态<br>(4). 如果更新不成功,首先会检查mark word是否指向的是当前线程的栈帧,如果是说明线程拥有锁,如果不是,说明多个线程竞争锁,会膨胀为重量级锁,设置锁标志位为10,mark word存储指向重量级锁的指针,后面获取锁的都会进入阻塞状态   </li><li>轻量级解锁:<br> (1). 通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word。<br> (2). 如果替换成功,同步完成<br> (3). 如果不成功变为重量级锁,在释放锁的时候唤醒被挂起的线程</li><li>偏向锁加锁<ol><li>访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态</li><li>如果为可偏向状态，则测试线程ID是否指向当前线程.如果是,进入(5),不是进入(3)</li><li>如果线程ID并未指向当前线程，则通过CAS操作竞争锁。(这里CAS替换是换mark 替word中的线程ID,如果没有竞争,则会成功,如果有竞争,肯定有一个线程失败,这个失败的线程则会将锁升级为轻量级锁).如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）,如果竞争失败，执行（4）。  </li><li>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码  </li><li>执行同步代码</li></ol></li><li>偏向锁解锁<br>解锁主要就是到达一个全局安全点,首先暂停拥有偏向锁的线程,然后检查拥有偏向锁的线程是否或者,如果不活着,则设置为无锁状态,如果活着,拥有偏向锁的栈会被执行,遍历偏向对象的锁记录,占中的锁记录和对象头的mark word要么重新偏向于其他线程,要么恢复到无锁活着标记对象不合适作为偏向锁,最后唤醒暂停的线程.<br><img src="/2019/04/06/synchronized详解/java加锁解锁.png" alt></li></ol>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile详解</title>
      <link href="/2019/04/06/volatile%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/04/06/volatile%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="volatile的定义与实现原理"><a href="#volatile的定义与实现原理" class="headerlink" title="volatile的定义与实现原理"></a>volatile的定义与实现原理</h3><p>在java语言规范第三版中对volatile的定义如下:Java编程语言允许线程访问共享变量,为了保存共享变量能够被准确和一致的更新,线程应该确保通过排它锁单独获得这个变量.<br>java线程内存模型确保所有线程看到这个变量的值是一致的.<br>在了解volatile实现原理之前,要先看cpu术语与说明  : </p><ul><li>内存屏障(memory barriers) 一组处理器指令,用于实现对内存操作的顺序限制</li><li>缓冲行( cache line) cpu告诉缓存中可以分配的最小存储单位.处理器填写缓存行时会加载整个缓存行  </li><li>原子操作: 不可中断的一个或一系列操作</li><li>缓存行填充: 当处理器识别到从内存中读取操作数是可以缓存的,处理器就读取整个高速缓存行到适当的缓存  </li></ul><p>在java中,在对volatile变量进行写操作时候,会有lock指令,此lock指令会使得处理器发生两件事情</p><ul><li>将当前处理器缓存行的数据写会到系统内存</li><li>这个写回内存的操作会使其他cpu里缓存了该内存地址的数据无效<br>在这里为了提高处理速度,处理器不直接与内存直接通信,会首先将系统内存的数据读取到内部缓存后在进行操作.如果是普通变量,操作完不知道什么时候会写会内存,但是如果声明了volatile变量,则会立刻把缓存行的数据写会到系统内存.并且在多处理器下,为了保证各个处理器的缓存是一致的,会实现缓存一致性协议,每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是否过期,当处理器发现自己缓存行对应的内存地址被修改,就会将当前处理器的缓存行置为无效.  </li></ul><p><strong>volatile还有一个功能是禁止指令的重排序.</strong><br>在程序执行过程中存在三种重排序</p><ol><li>编译器优化的重排序,编译器在不改变单线程程序语义下,可以重新安排语句的执行顺序</li><li>指令级并行的重排序,现代处理器采用指令级并行技术将多条执行重叠执行,如果没有数据依赖性,可以改变语句对应执行的执行顺序</li><li>内存系统的重排序,由于处理器使用缓存和读/写缓冲区,是的加载和存储操作可能是在乱序执行<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>; <span class="number">1</span></span><br><span class="line"><span class="keyword">int</span> a = c; <span class="number">2</span></span><br><span class="line"> <span class="comment">//这里在其他线程看来可能2发生在1的前面,以为这里有缓存一说,所以就有了给b赋值,但是还没有被刷新回主存,但是a=c已经从内存中读取了,在这种情况下,可能会出现内存系统的重排序</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="volatile对于重排序的规定"><a href="#volatile对于重排序的规定" class="headerlink" title="volatile对于重排序的规定"></a>volatile对于重排序的规定</h3><p>当写一个volatile变量的时候,JMM会把该线程对应的本地内存中的共享变量值刷新会主存.当读一个volatile变量时,JMM会把该线程对应的本地内存置为无效,线程接下来将从主内存中读取共享变量</p><ul><li>对于volatile写之前的操作不允许放在volatile之后</li><li>对于valatile读之后的所有操作不允许放在volatile之前</li><li>一个普通变量的写可以被重排序到volatile变量的写之前</li></ul><p>在对一个普通变量的单个读/写操作,与一个普通变量的读/写操作都是使用同一个锁同步来说执行效果相同. 这是在jdk1.5之后增强了volatile关键字的语义,这个语义保证了对单个volatile变量的读/写具有原子性.<br>volatile变量自身拥有如下特性:</p><ul><li>可见性: 对一个volatile变量的读,总是能看到对这个变量的最后写入</li><li>原子性: 对任意单个变量的读/写具有原子性,但是类似于volatile这种复合操作不具有原子性;</li></ul><p>###　内存屏障</p><ul><li>StoreStore 确保之前的写操作先行与之后的写操作</li><li>LoadLoad 确保之前的读操作先于之后所有的读操作</li><li>LoadStore 确保之前的读操作先行与之后所有的写操作</li><li>StoreLoad 确保之前的写操作先行与之后所有的读操作</li></ul><p>JMM在会在使用了volatile的变量使用之前之后加入不同的内存屏障来禁止指令的重排序.保证了单个变量的原子性与可见性.</p><ul><li>在每个volatile写操作之前插入一个storeStore屏障</li><li>在每个volatile写操作之后插入一个StoreLoad屏障</li><li>在每个volatile读操作之前插入一个LoadLoad屏障</li><li>在每个volatile读操作之后插入一个LoadStore屏障</li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReentrantLock源码解读</title>
      <link href="/2019/04/06/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/04/06/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="RentrantLock总览"><a href="#RentrantLock总览" class="headerlink" title="RentrantLock总览"></a>RentrantLock总览</h2><p>ReentrantLock是一个独占式的锁,支持重入.里面实现了公平锁与非公平锁;<br><img src="/2019/04/06/ReentrantLock源码解读/ReentrantLock.png" alt><br>其中ReentrantLock支持可公平锁与非公平锁,最顶层的父类是AQS.获取锁阻塞释放全部都是通过AQS来实现.接下来详细说明这些是怎么实现的. </p><h2 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h2><p>继承自AQS  </p><h3 id="abstract-void-lock"><a href="#abstract-void-lock" class="headerlink" title="abstract void lock();"></a>abstract void lock();</h3><p>抽象方法,让子类也就是两个公平和非公平类来实现.</p><h3 id="boolean-nonfairTryAcquire-int-acquires"><a href="#boolean-nonfairTryAcquire-int-acquires" class="headerlink" title="boolean nonfairTryAcquire(int acquires) ;"></a>boolean nonfairTryAcquire(int acquires) ;</h3><p>此为尝试获取非公平锁,非公平锁的实现就是首先CAS替换看自己是否能够获得锁,如果能够获得,则设置为拥有锁,如果不行,返回false;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">               <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">               <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="boolean-tryRelease-int-releases"><a href="#boolean-tryRelease-int-releases" class="headerlink" title="boolean tryRelease(int releases)"></a>boolean tryRelease(int releases)</h3><p>释放掉指定的资源.如果当前线程没有拥有锁,则抛出异常.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">           <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">           <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               free = <span class="keyword">true</span>;</span><br><span class="line">               <span class="comment">//用来设置获得锁的线程的方法</span></span><br><span class="line">               setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           setState(c);<span class="comment">//设置状态,状态为0,表示没有线程获得锁</span></span><br><span class="line">           <span class="keyword">return</span> free;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="boolean-isHeldExclusively"><a href="#boolean-isHeldExclusively" class="headerlink" title="boolean isHeldExclusively()"></a>boolean isHeldExclusively()</h3><p>表明当前线程是否是独占锁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// While we must in general read state before owner,</span></span><br><span class="line">    <span class="comment">// we don't need to do so to check if current thread is owner</span></span><br><span class="line">    <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p>ReentrantLock实现了两种锁,一种是非公平的,一种是公平的.两个的区别在于公平锁总是按照先来就先获得锁,非公平锁是谁抢到就算谁的.接下来看公平锁的实现:  </p><h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><p>锁主要是通过acquire()实现锁住,acquire(1)方法是AQS中定义好的方法,acquire首先会调用自己所实现的tryacquire()方法,如果不成功则加入队列中,成功就直接获取到锁.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法如果有不了解,可以先去看我另一篇文章<a href="https://1fishman.github.io/2019/04/06/synchronized%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">AQS详解</a></p><h3 id="boolean-tryAcquire-int-acquires"><a href="#boolean-tryAcquire-int-acquires" class="headerlink" title="boolean tryAcquire(int acquires)"></a>boolean tryAcquire(int acquires)</h3><p>首先判断锁状态是否为0,如果为0,在判断阻塞队列中是否有前驱,如果没有前驱则设置此线程为拥有锁的线程.如果状态不为0,查看是否是自己拥有锁,如果不是返回false;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><p>非公平锁与公平所实现基本一样,但是是首先直接去获取锁,如果获取不到则加入队列,获取到就已经用有锁.<br>非公平锁有一点就是能够极大的提高系统吞吐量,公平所因为是先来先获得锁,所以在切换锁的时候会有很大的系统调度开销,而非公平锁是直接抢占,所以不会有很大的系统开销.但是可能会造成线程饥饿</p><h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><p>主要的一些方法都是通过调用内部类Sync的方法实现的.其实也就是用AQS定义好的框架来进行实现.这里就不一一说明了.有兴趣可以自己去看看源码</p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS源码解读</title>
      <link href="/2019/04/06/AQS%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/04/06/AQS%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="AbstractQueueSynchronizer"><a href="#AbstractQueueSynchronizer" class="headerlink" title="AbstractQueueSynchronizer"></a>AbstractQueueSynchronizer</h1><p>定义了一套多线程访问共享资源的同步框架<br>首先维护了一个volatile state状态量 和 一个阻塞队列,是FIFO队列,队列使用链表实现.state的访问方式有三种</p><ul><li>getstate()</li><li>setState()</li><li>compareAndSetState()<br>AQS 定义了两种资源共享状态,一种是独占(Exclusive 如ReentrantLock),一种是共享(Share可以同时多个线程执行).<br>不同的自定义同步实现器在实现时只需要实现共享资源state的获取和释放.至于具体的等待队列的维护与修改,顶层已了.自定义经实现好同步器主要实现一下几个方法.  </li><li>isHeldExclusive():表示该线程是否独占资源,只有用到condition才需要实现</li><li>tryAcquire():独占方式,尝试去获取资源,成功返回true,失败放回false</li><li>tryRelease():独占方式:尝试去释放资源</li><li>tryAcquireShared(int): 共享方式,尝试获取资源,负数表示失败,0表示成功,但没有剩余资源,正数表示成功并且有资源</li><li>tryReleaseShared(int): 共享方式:尝试释放资源,如果释放后允许释放后续等待资源返回true,否则放回false</li></ul><p>以ReentrantLock为例,首先初始化state为0,表示未锁定状态.一旦调用lock.lock(),会尝试调用tryAcquire()并且将state+1,此时其他线程会获取锁失败,知道unlock()讲state置为0,在获取到此锁的时候,可以继续获取,但是每次都会是state+1.<br>CountDownLatch 中,任务分为N个子线程执行,state初始化为N,这个N个子线程是并行执行的,每个子线程执行完之后会countDown()一次,state会通过CAS减一,等待所有的线程都执行完之后,在unpark()会调用主线程继续执行自己的工作.</p><h2 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h2><p>队列是通过Node来保持一个队列的,就相当于链表中的普通节点,保存了同步的线程以及线程的状态,上一个节点,下一个节点.: </p><ul><li>int waitStatus 共有四种状态:<ul><li>CANCELLED: 值为1,在等待过程中被中断,需要从队列中取消该节点.</li><li>SIGNAL :值为-1,后继节点的线程处于等待状态,当前节点的线程如果释放了同步状态或取消,将会通知后集节点,使后继节点的线程得意运行.</li><li>CONDITION :值为-2,表示该节点处于等待队列中，节点的线程等待在condition上,当其他线程调用Condition.signal()方法会唤醒此线程,进入到同步队列中</li><li>PROPAGATE：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。</li></ul></li><li>Node prev,前驱节点,当节点加入同步队列时被设置   </li><li>Node next,后继节点,  </li><li>Node nextWaiter 等待队列中的后继节点.如果当前节点是共享的,那么这个字段是一个SHARED常量,也就是说节点类型(独占和共享)和等待队列中的后继节点共用同一个字段  </li><li>Thread thread 获取同步状态的线程.<h3 id="方法一览"><a href="#方法一览" class="headerlink" title="方法一览"></a>方法一览</h3>isShared() 判断是否是共享模式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>predecessor() 返回前驱节点,如果前驱为空,抛出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h2 id="AQS内部属性"><a href="#AQS内部属性" class="headerlink" title="AQS内部属性"></a>AQS内部属性</h2><ul><li>Node head: 队列的头结点</li><li>Node tail: 队列的尾节点</li><li>int state: 锁的状态,独占模式下为0或1,0为空闲,1为已经有线程获取到锁.共享模式下为还剩余多少资源</li><li>long spinForTimeoutThreshold = 1000L: 最小的等待时间 在下面讲到</li></ul><h2 id="方法-独占模式方法"><a href="#方法-独占模式方法" class="headerlink" title="方法 独占模式方法"></a>方法 独占模式方法</h2><h3 id="acquire-获取锁"><a href="#acquire-获取锁" class="headerlink" title="acquire() 获取锁"></a>acquire() 获取锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line"><span class="number">3</span>         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line"><span class="number">4</span>         selfInterrupt();</span><br><span class="line"><span class="number">5</span> &#125;</span><br></pre></td></tr></table></figure><p>TryAcquire(arg)如果成功获取锁,则直接返回.而tryAcquire方法需要具体实现<br>addWaiter() 方法则将线程加入到队列的尾部,并标记为独占模式<br>acquireQueued() 使线程在等待队列中获取资源,知道获取资源后返回,如果被中断过,则返回true.</p><h3 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter()"></a>addWaiter()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="comment">//以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）</span></span><br><span class="line"> <span class="number">3</span>     Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line"> <span class="number">4</span>     </span><br><span class="line"> <span class="number">5</span>     <span class="comment">//尝试快速方式直接放到队尾。</span></span><br><span class="line"> <span class="number">6</span>     Node pred = tail;</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">8</span>         node.prev = pred;</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;<span class="comment">//利用CAS进行替换</span></span><br><span class="line"><span class="number">10</span>             pred.next = node;</span><br><span class="line"><span class="number">11</span>             <span class="keyword">return</span> node;</span><br><span class="line"><span class="number">12</span>         &#125;</span><br><span class="line"><span class="number">13</span>     &#125;</span><br><span class="line"><span class="number">14</span>     </span><br><span class="line"><span class="number">15</span>     <span class="comment">//上一步失败则通过enq入队。</span></span><br><span class="line"><span class="number">16</span>     enq(node);</span><br><span class="line"><span class="number">17</span>     <span class="keyword">return</span> node;</span><br><span class="line"><span class="number">18</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="enq-Node"><a href="#enq-Node" class="headerlink" title="enq(Node)"></a>enq(Node)</h3><p>如果直接添加到队尾失败则使用enq方法加入队尾<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="comment">//CAS"自旋"，直到成功加入队尾</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"> <span class="number">4</span>         Node t = tail;</span><br><span class="line"> <span class="number">5</span>         <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 队列为，空创建一个空的标志结点作为head结点，并将tail也指向它。</span></span><br><span class="line"> <span class="number">6</span>             <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line"> <span class="number">7</span>                 tail = head;</span><br><span class="line"> <span class="number">8</span>         &#125; <span class="keyword">else</span> &#123;<span class="comment">//正常流程，放入队尾</span></span><br><span class="line"> <span class="number">9</span>             node.prev = t;</span><br><span class="line"><span class="number">10</span>             <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line"><span class="number">11</span>                 t.next = node;</span><br><span class="line"><span class="number">12</span>                 <span class="keyword">return</span> t;</span><br><span class="line"><span class="number">13</span>             &#125;</span><br><span class="line"><span class="number">14</span>         &#125;</span><br><span class="line"><span class="number">15</span>     &#125;</span><br><span class="line"><span class="number">16</span> &#125;</span><br></pre></td></tr></table></figure></p><p>使用CAS自旋,直到成功加入队尾</p><h2 id="acquireQueued-Node-int"><a href="#acquireQueued-Node-int" class="headerlink" title="acquireQueued(Node int)"></a>acquireQueued(Node int)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//标记是否成功拿到资源</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="number">4</span>         <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//标记等待过程中是否被中断过</span></span><br><span class="line"> <span class="number">5</span>         </span><br><span class="line"> <span class="number">6</span>         <span class="comment">//又是一个“自旋”！</span></span><br><span class="line"> <span class="number">7</span>         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"> <span class="number">8</span>             <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//拿到前驱</span></span><br><span class="line"> <span class="number">9</span>             <span class="comment">//如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。</span></span><br><span class="line"><span class="number">10</span>             <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line"><span class="number">11</span>                 setHead(node);<span class="comment">//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。</span></span><br><span class="line"><span class="number">12</span>                 p.next = <span class="keyword">null</span>; <span class="comment">// setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！</span></span><br><span class="line"><span class="number">13</span>                 failed = <span class="keyword">false</span>;</span><br><span class="line"><span class="number">14</span>                 <span class="keyword">return</span> interrupted;<span class="comment">//返回等待过程中是否被中断过</span></span><br><span class="line"><span class="number">15</span>             &#125;</span><br><span class="line"><span class="number">16</span>             </span><br><span class="line"><span class="number">17</span>             <span class="comment">//如果自己可以休息了，就进入waiting状态，直到被unpark()</span></span><br><span class="line"><span class="number">18</span>             <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line"><span class="number">19</span>                 parkAndCheckInterrupt()) <span class="comment">//parkAndCheckiInterrupt方法会进行检查是否被中断过,并且阻塞线程,此处用自旋是为了保证唤醒的节点能够同步的获取到锁.</span></span><br><span class="line"><span class="number">20</span>                 interrupted = <span class="keyword">true</span>;<span class="comment">//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true</span></span><br><span class="line"><span class="number">21</span>         &#125;</span><br><span class="line"><span class="number">22</span>     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="number">23</span>         <span class="keyword">if</span> (failed)</span><br><span class="line"><span class="number">24</span>             cancelAcquire(node);</span><br><span class="line"><span class="number">25</span>     &#125;</span><br><span class="line"><span class="number">26</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h3><p>用于检查状态,看看自己是否可以去休息,也就是阻塞<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="keyword">int</span> ws = pred.waitStatus;<span class="comment">//拿到前驱的状态</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line"> <span class="number">4</span>         <span class="comment">//如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了</span></span><br><span class="line"> <span class="number">5</span>         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> <span class="number">6</span>     <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="number">7</span>         <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 8          * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。</span></span><br><span class="line"><span class="comment"> 9          * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！</span></span><br><span class="line"><span class="comment">10          */</span></span><br><span class="line"><span class="number">11</span>         <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="number">12</span>             node.prev = pred = pred.prev;</span><br><span class="line"><span class="number">13</span>         &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line"><span class="number">14</span>         pred.next = node;</span><br><span class="line"><span class="number">15</span>     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">16</span>          <span class="comment">//如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！</span></span><br><span class="line"><span class="number">17</span>         compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line"><span class="number">18</span>     &#125;</span><br><span class="line"><span class="number">19</span>     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">20</span> &#125;</span><br></pre></td></tr></table></figure></p><p>###　parkAndCheckInterrupt()　<br>将进程阻塞，并且返回中断状态.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="doAcquireInterruptibly-int-arg"><a href="#doAcquireInterruptibly-int-arg" class="headerlink" title="doAcquireInterruptibly(int arg)"></a>doAcquireInterruptibly(int arg)</h3><p>此方法为支持中断的获取资源,如果在过程中发生了中断,则方法会抛出中断并且返回<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">//首先看是否能够获取资源,获取不到则不会取消</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)<span class="comment">//如果failed=true,说明没有获取到资源,并且有过中断,因为中断后会返回并且抛出异常.则取消该节点.</span></span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="doAcquireNanos-int-arg-long-nanosTimeout"><a href="#doAcquireNanos-int-arg-long-nanosTimeout" class="headerlink" title="doAcquireNanos(int arg, long nanosTimeout)"></a>doAcquireNanos(int arg, long nanosTimeout)</h3><p>是支持超时的获取同步状态,在时间限制到的情况下会直接返回false,否则获取到同步状态则返回true<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;<span class="comment">//计算出deadline时间</span></span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);<span class="comment">//将此节点加入队列</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//自旋</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//获取前驱,与普通获取一样</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime(); <span class="comment">//再次判断是否超时</span></span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<span class="comment">//判断是否可以阻塞</span></span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)<span class="comment">//必须得经过一次spinForTimeoutThreshold</span></span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                    <span class="comment">//如果nanosTimeout小于spinForTimeoutThreshold,将不会是线程进入超时等待,则会进入一个自旋的过程.原因在于非常短的超时无法做到十分精确,如果这个时候在进行超时等待,会让nanoTimeout的超时从整体上变现的不精确.</span></span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();<span class="comment">//如果线程被中断过,则会抛出一个异常并且放回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)<span class="comment">//如果没有获得资源或则被中断或者超时都会取消此节点.</span></span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>realease</strong><br>会释放指定量的资源,首先执行tryrelease()方法,此方法为继承者实现.如果彻底释放,会唤醒队列中的其他线程来获取资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line"><span class="number">3</span>         Node h = head;    <span class="comment">//找到头结点</span></span><br><span class="line"><span class="number">4</span>         <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)<span class="comment">//在头结点不为空的情况下并且waitStatus不为0也就是不是刚初始化的情况</span></span><br><span class="line"><span class="number">5</span>             unparkSuccessor(h);    <span class="comment">//唤醒等待队列里的下一个线程</span></span><br><span class="line"><span class="number">6</span>         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="number">7</span>     &#125;</span><br><span class="line"><span class="number">8</span>     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">9</span> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor()"></a><strong>unparkSuccessor()</strong></h3><p>用来唤醒等待对垒中的下一个线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="comment">//这里，node一般为当前线程所在的结点。</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line"> <span class="number">4</span>     <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)<span class="comment">//置零当前线程所在的结点状态，允许失败。</span></span><br><span class="line"> <span class="number">5</span>         compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"> <span class="number">6</span> </span><br><span class="line"> <span class="number">7</span>     Node s = node.next;<span class="comment">//找到下一个需要唤醒的结点s</span></span><br><span class="line"> <span class="number">8</span>     <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;<span class="comment">//如果为空或已取消,则从尾节点开始找,知道找到第一个有效的节点</span></span><br><span class="line"> <span class="number">9</span>         s = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">10</span>         <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line"><span class="number">11</span>             <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)<span class="comment">//从这里可以看出，&lt;=0的结点，都是还有效的结点。</span></span><br><span class="line"><span class="number">12</span>                 s = t;</span><br><span class="line"><span class="number">13</span>     &#125;</span><br><span class="line"><span class="number">14</span>     <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line"><span class="number">15</span>         LockSupport.unpark(s.thread);<span class="comment">//唤醒</span></span><br><span class="line"><span class="number">16</span> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h2><p>和独占模式差不多,但是在共享模式只有当前线程是头结点的下一个节点的时候,才可以去获取资源,有剩余的话会唤醒后续的节点,不会隔着来.</p><h3 id="acquireShared-int-arg"><a href="#acquireShared-int-arg" class="headerlink" title="acquireShared(int arg)"></a>acquireShared(int arg)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)<span class="comment">//尝试直接获取,小于0说明没有资源</span></span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="doAcquireShared-int-arg"><a href="#doAcquireShared-int-arg" class="headerlink" title="doAcquireShared(int arg)"></a>doAcquireShared(int arg)</h3><p>与独占模式相同,只不过在加入队列的节点模式改变成了共享模式,还有一点就是在共享模式下如果还有剩余资源则会继续唤醒之后的节点.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先以共享方式加入队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//标志位检查是否呗中断过</span></span><br><span class="line">        <span class="comment">// 与独占模式相同,自旋保证获取资源,</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//加入阻塞队列之后进行中断检查,如果中断过则取消节点.</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="doAcquireSharedInterruptibly-int-arg"><a href="#doAcquireSharedInterruptibly-int-arg" class="headerlink" title="doAcquireSharedInterruptibly(int arg)"></a>doAcquireSharedInterruptibly(int arg)</h3><p>这里与独占模式不同,独占模式首先获取资源,将头结点设置为当前节点,获取不到则阻塞,并且被中断过就抛出异常,在这里首先会获取资源,设置头结点之后多了一条propagate操作.在这个会在判断后继节点是否为shared的,如果是,则会唤醒.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;<span class="comment">//如果还有资源,进入下一个方法</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="setHeadAndPropagate-node-r"><a href="#setHeadAndPropagate-node-r" class="headerlink" title="setHeadAndPropagate(node, r)"></a>setHeadAndPropagate(node, r)</h3><p>在这里会先看后继节点,如果后继节点是shared状态则会继续唤醒后集节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">        setHead(node);</span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">~~~ </span><br><span class="line"></span><br><span class="line">### doReleaseShared()</span><br><span class="line">首先先看头结点,如果头结点为signal状态,则会唤醒头结点的下一个节点.如果状态为<span class="number">0</span>,则讲状态转换为propagate状态,继续向下传播.</span><br><span class="line">~~~java</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);<span class="comment">//在这里会唤醒h节点之后的一个等待节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="unparkSuccessor-Node-node"><a href="#unparkSuccessor-Node-node" class="headerlink" title="unparkSuccessor(Node node)"></a>unparkSuccessor(Node node)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)<span class="comment">//这里从后向前遍历主要是保证了在共享模式下可能要唤醒多个,保证了每次唤醒的节点都是最开始的那个节点,如果从前向后遍历的话,可能会被已经唤醒的节点所打断,导致再次唤醒已经唤醒的节点. </span></span><br><span class="line">        <span class="comment">// 还有一点就是从后向前便利保证了能够将失效的节点能更快的被回收.</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cancelAcquire-Node-node"><a href="#cancelAcquire-Node-node" class="headerlink" title="cancelAcquire(Node node)"></a>cancelAcquire(Node node)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">//节点为空则直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    node.thread = <span class="keyword">null</span>; <span class="comment">//将节点的线程置位空,方便GC</span></span><br><span class="line">    Node pred = node.prev;<span class="comment">// 找到前驱节点</span></span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)<span class="comment">//这里找到第一个有效的前驱节点</span></span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    node.waitStatus = Node.CANCELLED; <span class="comment">// 将此节点状态设置为取消状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果节点为尾节点,并且设置尾节点为最后一个有效节点,则把尾节点的next设置为null//有助于GC</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则将前驱节点替换为node的后继节点</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;<span class="comment">//如果前驱节点不为为头结点并且前驱节点的状态为signal而且线程不为空.</span></span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);<span class="comment">//将前驱有效节点的下一个节点设置为node的下一个节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);<span class="comment">//如果前驱节点是头结点,就唤醒node之前的前驱节点.</span></span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类ConditionObject"><a href="#内部类ConditionObject" class="headerlink" title="内部类ConditionObject"></a>内部类ConditionObject</h1><p>实现 Condition接口和serializable接口<br>condition的实现主要包括等待队列,等待和通知.等待队列是一个FIFO的队列,如果线程调用了Condition.await()方法,则会释放锁,构造成节点加入等待队列并进入等待状态.这里节点复用了同步器的节点定义.</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性:"></a>属性:</h2><ul><li>Node firstWaiter: 第一个等待节点</li><li>Node lastWaiter: 最后一个等待节点</li></ul><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法:"></a>主要方法:</h2><h3 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h3><p>调用await()方法回事当前线程进入等待队列并且释放锁,同事状态变为等待状态.在返回时,当前线程一定获取了Condition相关联的锁.<br>从队列的角度看await()方法,调用await()方法,相当于同步队列的首节点移动到了Condition的等待队列中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为此时节点还获取有锁,所以不会产生竞争,直接赋值就可以</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//当前线程加入等待队列中</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">//释放同步状态</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123; <span class="comment">//这里判断是否应该等待,看节点状态是否为Condition状态</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);<span class="comment">//阻塞</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<span class="comment">//加入竞争中</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###　addConditionWaiter()<br>将节点加入到condition等带队列中.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();<span class="comment">//断开已经取消的节点链</span></span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);<span class="comment">//创建一个新的节点.</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="unlinkCancelledWaiters"><a href="#unlinkCancelledWaiters" class="headerlink" title="unlinkCancelledWaiters()"></a>unlinkCancelledWaiters()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    Node trail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h3><p>唤醒第一个节点,如果当前线程没有获取锁,则抛出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="doSignal"><a href="#doSignal" class="headerlink" title="doSignal()"></a>doSignal()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;<span class="comment">//循环唤醒下一个线程</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transferForSignal-Node-first"><a href="#transferForSignal-Node-first" class="headerlink" title="transferForSignal(Node first)"></a>transferForSignal(Node first)</h3><p>将节点设置状态为0,然后在加入队尾,在唤醒线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);<span class="comment">//这里唤醒线程后,线程会从await()方法的while循环中退出(isOnSyncQueue(Node node)方法返回ture,节点已经在同步队列中)借着在调用同步器的acquireQueued()方法加入竞争</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法:"></a>其他方法:</h2><ul><li>hasQueuedThreads() 返回是否有阻塞线程</li><li>hasContended 返回是否有线程在执行</li><li>isQueued(Thread thread) 返回当前线程是否在阻塞中</li><li>getQueueLength() 返回队列的长度</li><li>Collection<thread> getQueuedThreads 返回正在阻塞的线程</thread></li><li>getExclusiveQueuedThreads() 返回独占状态的阻塞线程,返回一个线程集合Collection<thread></thread></li><li>getSharedQueuedThreads() 返回共享状态下的线程集合</li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>timSort源码剖析</title>
      <link href="/2019/04/05/timSort%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2019/04/05/timSort%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="TimSort"><a href="#TimSort" class="headerlink" title="TimSort"></a>TimSort</h1><p>timsort是jdk自带的一种特别高效的排序算法,大致思想使用的是归并排序,但是内部细节做了许多的优化.<br>在timsort中,主要是为待排序数组分为很多个run块,通过讲这些run块进行归并排序.最后实现总体排序.每个run块的大小为16-32大小.<br>优化地方: </p><ul><li>当待排序数组长度小于32就使用二分排序算法</li><li>分为多个run块,在通过把run块的起始位置和长度压入栈中,在进行合并.</li><li>在找到一个run块的时候会首先判断数组中有序元素的个数.通过二分排序从第一个无序的元素开始排序,加快排序速度</li><li>在进行合并的时候会进行”去头”,”去尾”操作,是的归并操作加快速度.</li></ul><h2 id="sort-T-a-int-lo-int-hi-Comparator-lt-super-T-gt-c-T-work-int-workBase-int-workLen"><a href="#sort-T-a-int-lo-int-hi-Comparator-lt-super-T-gt-c-T-work-int-workBase-int-workLen" class="headerlink" title="sort(T[] a, int lo, int hi, Comparator&lt;? super T&gt; c, T[] work, int workBase, int workLen)"></a>sort(T[] a, int lo, int hi, Comparator&lt;? super T&gt; c, T[] work, int workBase, int workLen)</h2><p>timsort对外的唯一接口.并且只能本包内访问<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Comparator&lt;? <span class="keyword">super</span> T&gt; c,</span></span></span><br><span class="line"><span class="function"><span class="params">                         T[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> c != <span class="keyword">null</span> &amp;&amp; a != <span class="keyword">null</span> &amp;&amp; lo &gt;= <span class="number">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nRemaining  = hi - lo;</span><br><span class="line">        <span class="comment">//小于2不用排序,直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (nRemaining &lt; <span class="number">2</span>) </span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        <span class="comment">// 看是否小于min_merge,如果小于就直接二分排序,没必要进行复杂的timsort.</span></span><br><span class="line">        <span class="keyword">if</span> (nRemaining &lt; MIN_MERGE) &#123;</span><br><span class="line">            <span class="comment">//下面有详细说明.返回的是从lo开始已经有序的个数,对二分排序用</span></span><br><span class="line">            <span class="keyword">int</span> initRunLen = countRunAndMakeAscending(a, lo, hi, c);</span><br><span class="line">            <span class="comment">// 从第一没有排好序位置开始进行二分排序</span></span><br><span class="line">            binarySort(a, lo, hi, lo + initRunLen, c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个时候开始真正的timsort</span></span><br><span class="line">        TimSort&lt;T&gt; ts = <span class="keyword">new</span> TimSort&lt;&gt;(a, c, work, workBase, workLen);</span><br><span class="line">        <span class="comment">//主要将数组分为一个个的minRun,最后在进行合并,如果长度为2的n次幂,minRun为32,否则为16-32之间的数.</span></span><br><span class="line">        <span class="keyword">int</span> minRun = minRunLength(nRemaining);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//再次找到a中已经有序的元素个数</span></span><br><span class="line">            <span class="keyword">int</span> runLen = countRunAndMakeAscending(a, lo, hi, c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果有序个数小于上面的最小minRun的话,就找到</span></span><br><span class="line">            <span class="keyword">if</span> (runLen &lt; minRun) &#123;</span><br><span class="line">                <span class="keyword">int</span> force = nRemaining &lt;= minRun ? nRemaining : minRun;</span><br><span class="line">                binarySort(a, lo, lo + force, lo + runLen, c);</span><br><span class="line">                runLen = force;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将此run块放入run数组中.</span></span><br><span class="line">            ts.pushRun(lo, runLen);</span><br><span class="line">            <span class="comment">//这里之心合并操作.</span></span><br><span class="line">            ts.mergeCollapse();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Advance to find next run</span></span><br><span class="line">            lo += runLen;</span><br><span class="line">            nRemaining -= runLen;</span><br><span class="line">        &#125; <span class="keyword">while</span> (nRemaining != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Merge all remaining runs to complete sort</span></span><br><span class="line">        <span class="keyword">assert</span> lo == hi;</span><br><span class="line">        ts.mergeForceCollapse();</span><br><span class="line">        <span class="keyword">assert</span> ts.stackSize == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="minRunLength"><a href="#minRunLength" class="headerlink" title="minRunLength"></a>minRunLength</h2><p>就是获得一个最小的Run块的大小,大小在16-32之间.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minRunLength</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> n &gt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;      <span class="comment">// Becomes 1 if any 1 bits are shifted off</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt;= MIN_MERGE) &#123;</span><br><span class="line">        r |= (n &amp; <span class="number">1</span>);</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n + r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="countRunAndMakeAscending-a-lo-hi-c"><a href="#countRunAndMakeAscending-a-lo-hi-c" class="headerlink" title="countRunAndMakeAscending(a, lo, hi, c)"></a>countRunAndMakeAscending(a, lo, hi, c)</h2><p>找到a数组中从lo开始并且已经有序的元素个数,返回已经有序的元素个数.在这里如果逆序在翻转一下,变为有序.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">countRunAndMakeAscending</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> lo &lt; hi;</span><br><span class="line">        <span class="keyword">int</span> runHi = lo + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (runHi == hi)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找见a从lo开始已经有序的元素个数</span></span><br><span class="line">        <span class="keyword">if</span> (c.compare(a[runHi++], a[lo]) &lt; <span class="number">0</span>) &#123; <span class="comment">// Descending</span></span><br><span class="line">            <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="number">1</span>]) &lt; <span class="number">0</span>)</span><br><span class="line">                runHi++;</span><br><span class="line">            reverseRange(a, lo, runHi);<span class="comment">//如果是逆序则翻转</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                              <span class="comment">// Ascending</span></span><br><span class="line">            <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="number">1</span>]) &gt;= <span class="number">0</span>)</span><br><span class="line">                runHi++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> runHi - lo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="binarySort-T-a-int-lo-int-hi-int-start-Comparator-lt-super-T-gt-c"><a href="#binarySort-T-a-int-lo-int-hi-int-start-Comparator-lt-super-T-gt-c" class="headerlink" title="binarySort(T[] a, int lo, int hi, int start,Comparator&lt;? super T&gt; c)"></a>binarySort(T[] a, int lo, int hi, int start,Comparator&lt;? super T&gt; c)</h2><p>此方法就是二分排序,二分排序就是插入排序,但是在寻找向前面插入的位置是通过二分法来查找,然后在插入的.<br>此方法是在a数组中排序从lo到hi的元素,从start开始.</p><h2 id="private-void-mergeCollapse"><a href="#private-void-mergeCollapse" class="headerlink" title="private void mergeCollapse()"></a>private void mergeCollapse()</h2><p>这个方法主要是用来合并已经分好的几个Run块的.但是是有条件的;</p><ol><li>runLen[i - 3] &gt; runLen[i - 2] + runLen[i - 1]</li><li>runLen[i - 2] &gt; runLen[i - 1]<br>满足这两个条件才合并,否则什么都不做.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeCollapse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最少都得有两个块,如果没有,则退出.</span></span><br><span class="line">        <span class="keyword">while</span> (stackSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = stackSize - <span class="number">2</span>;<span class="comment">// stackSize为块的数量,-2相当与倒数第二个块</span></span><br><span class="line">            <span class="comment">//如果块的数量大于三个并且倒数第三个Run块大小小于后面两个块的大小和进入</span></span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; runLen[n-<span class="number">1</span>] &lt;= runLen[n] + runLen[n+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//如果倒数第三个块比倒一块的大小小,就从倒数第三个块进行合并</span></span><br><span class="line">                <span class="keyword">if</span> (runLen[n - <span class="number">1</span>] &lt; runLen[n + <span class="number">1</span>])</span><br><span class="line">                    n--;</span><br><span class="line">                mergeAt(n);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (runLen[n] &lt;= runLen[n + <span class="number">1</span>]) &#123;<span class="comment">//第一个块大小小于第二个块大小,就合并这两个</span></span><br><span class="line">                mergeAt(n);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则什么都不做    </span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// Invariant is established</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="private-void-mergeAt-int-i"><a href="#private-void-mergeAt-int-i" class="headerlink" title="private void mergeAt(int i)"></a>private void mergeAt(int i)</h2><p>再来看mergeAt(i)方法,这个方法主要就是合并在run块数组中从i开始的两个块.run[i]和run[i+1]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> base1 = runBase[i];</span><br><span class="line"><span class="keyword">int</span> len1 = runLen[i];</span><br><span class="line"><span class="keyword">int</span> base2 = runBase[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> len2 = runLen[i + <span class="number">1</span>];</span><br><span class="line">runLen[i] = len1 + len2;</span><br><span class="line"><span class="comment">//观察如果是倒数第三个块,就倒数第一个块赋值给倒数第二个块</span></span><br><span class="line"><span class="keyword">if</span> (i == stackSize - <span class="number">3</span>) &#123;</span><br><span class="line">    runBase[i + <span class="number">1</span>] = runBase[i + <span class="number">2</span>];</span><br><span class="line">    runLen[i + <span class="number">1</span>] = runLen[i + <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">stackSize--;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算run2的第一个元素能插入到run1的位置</span></span><br><span class="line"><span class="comment">//如果属于run1的最后一个位置,就不需要排序,因为run1中的所有元素都比run2中的小,直接返回,</span></span><br><span class="line"><span class="comment">//这样可以忽略掉run1中之前的位置</span></span><br><span class="line"><span class="keyword">int</span> k = gallopRight(a[base2], a, base1, len1, <span class="number">0</span>, c);</span><br><span class="line"><span class="keyword">assert</span> k &gt;= <span class="number">0</span>;</span><br><span class="line">base1 += k;</span><br><span class="line">len1 -= k;</span><br><span class="line"><span class="keyword">if</span> (len1 == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算run1的最后一个元素在run2中插入的位置,进行去尾.</span></span><br><span class="line">len2 = gallopLeft(a[base1 + len1 - <span class="number">1</span>], a, base2, len2, len2 - <span class="number">1</span>, c);</span><br><span class="line"><span class="keyword">assert</span> len2 &gt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (len2 == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经过上面的“去头”和“去尾”之后，保证run1的开始元素一定大</span></span><br><span class="line"><span class="comment">// 于run2的开始元素，并且run1的最后一个数据一定大于run2的最后一个数据  </span></span><br><span class="line"><span class="comment">// 然后进行合并,通过两个len的大小找到最好的合并方式</span></span><br><span class="line"><span class="keyword">if</span> (len1 &lt;= len2)</span><br><span class="line">    mergeLo(base1, len1, base2, len2);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    mergeHi(base1, len1, base2, len2);</span><br></pre></td></tr></table></figure></p><h2 id="private-void-mergeLo-int-base1-int-len1-int-base2-int-len2"><a href="#private-void-mergeLo-int-base1-int-len1-int-base2-int-len2" class="headerlink" title="private void mergeLo(int base1, int len1, int base2, int len2)"></a>private void mergeLo(int base1, int len1, int base2, int len2)</h2><p>mergeLo方法 合并两个run块<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">    T[] a = <span class="keyword">this</span>.a; <span class="comment">//首先赋值到一个临时数组中</span></span><br><span class="line">    T[] tmp = ensureCapacity(len1);</span><br><span class="line">    <span class="keyword">int</span> cursor1 = tmpBase;</span><br><span class="line">    <span class="keyword">int</span> cursor2 = base2;   <span class="comment">// Indexes int a</span></span><br><span class="line">    <span class="keyword">int</span> dest = base1;      <span class="comment">// Indexes int a</span></span><br><span class="line">    <span class="comment">//先吧a从base1开始的元素赋值到tmp从tmpbase开始的元素,赋值len1个元素,因为len1肯定是最小的元素</span></span><br><span class="line">    System.arraycopy(a, base1, tmp, cursor1, len1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先肯定run2的第一个元素小于run1的第一个元素,因为上面都已经去头了</span></span><br><span class="line">    a[dest++] = a[cursor2++];</span><br><span class="line">    <span class="keyword">if</span> (--len2 == <span class="number">0</span>) &#123;<span class="comment">//如果run2长度为0,则赋值tmp过去,</span></span><br><span class="line">        System.arraycopy(tmp, cursor1, a, dest, len1);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len1 == <span class="number">1</span>) &#123;<span class="comment">//如果run1只剩下一个元素,所以只需要先把run2复制过去,再讲Run1的唯一元素赋值过去</span></span><br><span class="line">        System.arraycopy(a, cursor2, a, dest, len2);</span><br><span class="line">        a[dest + len2] = tmp[cursor1]; <span class="comment">// Last elt of run 1 to end of merge</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> T&gt; c = <span class="keyword">this</span>.c;  <span class="comment">// Use local variable for performance</span></span><br><span class="line">    <span class="keyword">int</span> minGallop = <span class="keyword">this</span>.minGallop;    <span class="comment">// 定义一个最小Gallop</span></span><br><span class="line">outer: <span class="comment">//定义跳出什么循环</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在这里有一个思路就是合并两个run,但是会记录两个块中连续个数的数量,如果连续个数的数量大于minGallop也就是7,那就会进入Gallop模式.此模式就是通过"去头","去尾"来减少比较次数</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> count1 = <span class="number">0</span>; <span class="comment">// Number of times in a row that first run won</span></span><br><span class="line">        <span class="keyword">int</span> count2 = <span class="number">0</span>; <span class="comment">// Number of times in a row that second run won</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Do the straightforward thing until (if ever) one run starts</span></span><br><span class="line"><span class="comment">         * winning consistently.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> len1 &gt; <span class="number">1</span> &amp;&amp; len2 &gt; <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//开始比较</span></span><br><span class="line">            <span class="keyword">if</span> (c.compare(a[cursor2], tmp[cursor1]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                a[dest++] = a[cursor2++];</span><br><span class="line">                count2++;</span><br><span class="line">                count1 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (--len2 == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a[dest++] = tmp[cursor1++];</span><br><span class="line">                count1++;</span><br><span class="line">                count2 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (--len1 == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当有一个块有连续大于另一个块的次数超过minGallop的时候,进入gallop模式</span></span><br><span class="line">        &#125; <span class="keyword">while</span> ((count1 | count2) &lt; minGallop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * One run is winning so consistently that galloping may be a</span></span><br><span class="line"><span class="comment">         * huge win. So try that, and continue galloping until (if ever)</span></span><br><span class="line"><span class="comment">         * neither run appears to be winning consistently anymore.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> len1 &gt; <span class="number">1</span> &amp;&amp; len2 &gt; <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//如上,去掉run1的头部</span></span><br><span class="line">            count1 = gallopRight(a[cursor2], tmp, cursor1, len1, <span class="number">0</span>, c);</span><br><span class="line">            <span class="keyword">if</span> (count1 != <span class="number">0</span>) &#123;</span><br><span class="line">                System.arraycopy(tmp, cursor1, a, dest, count1);</span><br><span class="line">                dest += count1;</span><br><span class="line">                cursor1 += count1;</span><br><span class="line">                len1 -= count1;</span><br><span class="line">                <span class="keyword">if</span> (len1 &lt;= <span class="number">1</span>) <span class="comment">// len1 == 1 || len1 == 0</span></span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">            &#125;</span><br><span class="line">            a[dest++] = a[cursor2++];</span><br><span class="line">            <span class="keyword">if</span> (--len2 == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="comment">// 去掉run2的尾部</span></span><br><span class="line">            count2 = gallopLeft(tmp[cursor1], a, cursor2, len2, <span class="number">0</span>, c);</span><br><span class="line">            <span class="keyword">if</span> (count2 != <span class="number">0</span>) &#123;</span><br><span class="line">                System.arraycopy(a, cursor2, a, dest, count2);</span><br><span class="line">                dest += count2;</span><br><span class="line">                cursor2 += count2;</span><br><span class="line">                len2 -= count2;</span><br><span class="line">                <span class="keyword">if</span> (len2 == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">            &#125;</span><br><span class="line">            a[dest++] = tmp[cursor1++];</span><br><span class="line">            <span class="keyword">if</span> (--len1 == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            minGallop--;</span><br><span class="line">            <span class="comment">//在此模式每多循环一次minGallop减少1</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (count1 &gt;= MIN_GALLOP | count2 &gt;= MIN_GALLOP);</span><br><span class="line">        <span class="keyword">if</span> (minGallop &lt; <span class="number">0</span>)</span><br><span class="line">            minGallop = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//在离开这个gallop模式后值增加2</span></span><br><span class="line">        minGallop += <span class="number">2</span>;  <span class="comment">// Penalize for leaving gallop mode</span></span><br><span class="line">    &#125;  <span class="comment">// End of "outer" loop</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.minGallop = minGallop &lt; <span class="number">1</span> ? <span class="number">1</span> : minGallop;  <span class="comment">// Write back to field</span></span><br><span class="line">    <span class="keyword">if</span> (len1 == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">assert</span> len2 &gt; <span class="number">0</span>;</span><br><span class="line">        System.arraycopy(a, cursor2, a, dest, len2);</span><br><span class="line">        a[dest + len2] = tmp[cursor1]; <span class="comment">//  Last elt of run 1 to end of merge</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len1 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">            <span class="string">"Comparison method violates its general contract!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> len2 == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">assert</span> len1 &gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//最后将tmp的值赋值到a中</span></span><br><span class="line">        System.arraycopy(tmp, cursor1, a, dest, len1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql查询优化</title>
      <link href="/2019/04/03/mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
      <url>/2019/04/03/mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h2><h3 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h3><ul><li>查询不需要的记录</li><li>多表关联是返回全部列</li><li>总是取出全部列 ,尽量不要使用select *,去除全部列,可能会使优化器无法完成索引覆盖扫描这种优化.还会为服务器带来额外的IO,内存和cpu开销.</li><li>重复查询相同的数据.可以将经常用到的数据放在缓存里,避免重复查询数据库<h3 id="是否在扫描额外的数据"><a href="#是否在扫描额外的数据" class="headerlink" title="是否在扫描额外的数据"></a>是否在扫描额外的数据</h3>确定了查询的数据列后,还应该看看查询是否为了返回结果是否扫描了过多的数据.对于mysql,最简单的衡量开销指标有三个:<ul><li>响应时间 包括服务时间(就是查询时间)和排队时间(也就是等待锁或者等待其他I/O完成的时间)</li><li>扫描行数 </li><li>返回行数<br>对于查询最好的就是扫描行数/返回行数在1:1到10:1之间<br>可以尝试使用索引覆盖扫描,把所有需要的列放入索引中,这样存储引擎就可以不需要回表就可以返回列,或者重写查询.以更优的方式查询结果</li></ul></li></ul><h2 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h2><ul><li>考虑是用一个大的查询还是用很多个小的查询.因为在实际应用中,如果一个查询很大的话可能会导致锁住整个表,耗尽系统资源,阻塞后面的查询.因此有时候可以使用多个小的查询来返回结果,最后在把小的查询组合起来.</li><li>分解关联查询,因为每个数据库都有自己的缓存,如果分解大的查询可以更好的应用自己的缓存</li></ul><h2 id="mysql查询执行过程"><a href="#mysql查询执行过程" class="headerlink" title="mysql查询执行过程"></a>mysql查询执行过程</h2><ol><li>客户端向服务器发送一条消息(这是半双工的,意思是同一时间只有一方能够发送数据)</li><li>服务器先查询缓存,如果缓存命中,直接返回给客服,否则进入下一阶段</li><li>服务端进行sql解析,预处理,在根据优化器生成对应的查询计划</li><li>调用存储引擎API查询数据,</li><li>将结果返回给客户端.</li></ol><h2 id="mysql能处理的优化类型"><a href="#mysql能处理的优化类型" class="headerlink" title="mysql能处理的优化类型"></a>mysql能处理的优化类型</h2><ul><li>重新定义关联表的顺序</li><li>将外部连接转化程内部连接  </li><li>使用等价变换规则, 比如 5=5 and a&gt;5 换成 a&gt;5</li><li>优化count(),min(),max(),如果在索引列找最小值,直接搜索最左边的值</li><li>覆盖索引查询,如果索引的列包含所有要查询的列的时候就无须在回表查询</li><li>子查询优化   </li><li>提前终止查询: 比如使用limit语句的时候,发现语句够了,就会直接终止  </li><li>列表in的比较,在mysql中,会把在in中的数据进行排序,然后在根据二分查找来查询,明显提高了查找速度.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中断与中断处理</title>
      <link href="/2019/04/01/%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/"/>
      <url>/2019/04/01/%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断就是使硬件发出通知给处理器,比如在敲击键盘的时候,键盘控制器会发送一个中断,通知操作系统有键按下,让操作系统尽快处理<br>不同的设备对应的中断不同,每个中断都通过一个唯一的数字标志,使得操作系统能够对中断进行区分,继而提供不同的处理程序.这些中断值通常被成为中断请求(IRQ)线.每个IRQ先都会被关联一个数值量;例如在经典的PC机上,IRQ 0 是时钟中断.1是键盘中断.但是对于连接在PCi总线上的设备而言,中断是动态分配的.</p><h2 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h2><p>在操作系统中,在响应一个特定中断的时候,内核会执行一个函数,该函数叫做中断处理程序,产生中断的每个设备都有一个特定的中断处理程序.<br>对于操作系统而言,中断处理程序在尽可能短的时间内完成很重要;但是对于硬件而言,操作系统能迅速对其中断进行服务也非常重要.<br>所以中断程序首先要通知硬件设备中断已接受.还要运行中断函数处理.例如要把硬件网络接收到的数据拷贝到内存,但是现在网速特别块,所以之后的工作量会很大.因此将响应中断分为两部分.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在操作系统中一般中断分为两部分.中断处理程序是上半部---接收到一个中断,它就立即开始执行,但是只做有严格实现的工作.例如对接收的中断进行应答或复位硬件.能够允许稍后完后才能的工作会推迟到下半部.</span><br></pre></td></tr></table></figure></p><p>linux的中断处理程序是无须重入的,但一个给定的中断处理程序正在执行,相应的中断线上的所有处理器上的都会被屏蔽掉.</p><h2 id="注册中断处理程序"><a href="#注册中断处理程序" class="headerlink" title="注册中断处理程序"></a>注册中断处理程序</h2><p>每个设备都有相关的驱动程序,如果硬件使用中断,应该注册一个中断处理程序.通过reques_irq()函数注册,并且激活给定的中断线,以处理中断.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">request_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq,  表示要分配的中断号</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="comment">//handler是一个指针,指向处理这个中断的实际中断处理程序</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">irq_handler_t</span> handler, </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="comment">//标志位: IRQF_FISABLED 表示不响应其他中断;IRQF_TIMER为系统定时器的中断处理而准备的;IRQF_SHARED:表明在多个中断处理程序之间共享中断线.</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">unsigned</span> <span class="keyword">long</span> flags, </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="comment">// 是与中断相关的设备的ASCII文本表示</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">char</span> *name, </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="comment">// 拥有共享中断线,dev讲提供唯一的标识信息.当删除中断处理程序需要释放时,能够知道删除哪一个.</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">void</span> *dev)</span></span></span><br></pre></td></tr></table></figure></p><p>request_irq()成功会返回0,否则返回非0值.<br>这里request_irq函数可能会睡眠,因此不能在中断上下文或者其他不允许阻塞的代码中调用该函数.<br>中断线共享仅仅指的是中断号共享,并不是处理程序共享.</p><h2 id="共享的中断处理程序"><a href="#共享的中断处理程序" class="headerlink" title="共享的中断处理程序"></a>共享的中断处理程序</h2><p>对于共享中断线的设备,首先request_irq()的flag参数为IRQF_SHARED标志<br>对于dev参数必须唯一.指向任意设备结构的指针就可以满足这一要求;通常选择设备结构,因为它是唯一的.这里设备结构是你要想响应的设备结构.<br>中断处理程序必须能够区分它的设备是否真的产生了中断.这需要硬件的支持,也需要程序中有相关的处理逻辑.</p><h2 id="释放中断处理程序"><a href="#释放中断处理程序" class="headerlink" title="释放中断处理程序"></a>释放中断处理程序</h2><p>使用free_irq(unsigned int irq, void *dev);<br>如果中断线是共享的,则传入dev参数,删除此dev对应的处理程序,知道最后一个处理程序时才会被禁用此中断线;如果不是共享的,则在删除处理程序的同时禁用此中断线.  </p><h2 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h2><p>上面提到了中断上下文.其实在执行一个中断处理程序时,内核处于中断上下文中.<br>中断上下文和进程没有瓜葛,因为没有后备进程,所以中断上下文不可以睡眠.因此在中断上下文中不能调用睡眠的函数.<br>在中断上下文具有较为严格的时间限制,所有的中断处理程序必须尽可能的迅速,简洁.尽量把工作从中断处理程序中分离出来.放在下半部执行．<br>在每个处理中有一个中断处理栈，大小为１页. 在栈中处理中断程序.</p><h2 id="中断控制"><a href="#中断控制" class="headerlink" title="中断控制"></a>中断控制</h2><p>禁止指定中断线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void disable_irq(unsigned int irq);//会等待当前处理程序完成后才返回</span><br><span class="line">void diable_irq_nosync(unsigned int irq);//强制返回</span><br><span class="line">void enable_irq(unsigned int irq);</span><br><span class="line">void synchronized_irq(unsigned int irq);</span><br></pre></td></tr></table></figure></p><p>前两个函数禁止中断控制器上制定的中断线.synchronized_irq等待一个特定的中断处理程序的退出.<br>对于调用禁用函数可以嵌套,但是有一点就是调用多少次禁用中断线函数,就要调用多少次启动函数才能够重新激活.</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux进程调度</title>
      <link href="/2019/04/01/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
      <url>/2019/04/01/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><p>linux采用两种不同的优先级范围.<br>第一种用nice值,范围为-20到19,越低优先级越高.<br>第二种是实时优先级,从0-99,越大优先级越高.  </p><p>在系统调度中总会解决I/O密集型的和CPU密集型的进程的协调,I/O密集型要求有更好的响应性,而执行时间应该更少.CPU要求有更好的执行时间,而不是花费更多时间用来调度.</p><h2 id="调度器类"><a href="#调度器类" class="headerlink" title="调度器类"></a>调度器类</h2><p>linux调度器是以模块方式提供的,每个模块化结构成为调度器类,允许多种不同的可动态添加的调度算法并存.每个调度器都有一个优先级,会按照优先级顺序便利调度类,拥有一个可执行进程的最高优先级的调度器类胜出,选出下面要执行的一个程序.</p><h2 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h2><p>在linux中采用公平调度算法CFS,允许每个进程运行一段时间,循环轮转,选择运行最少的进程作为下一个运行进程,而不在采用分配给每个进程时间片.CFS在所有可运行进程总数基础上计算出一个进程应该运行多久.通过用nice值作为进程获得处理器运行比的权重,越低的优先级进程获得更低的处理器使用权重.在这里nice值并不是通过绝对值值来进行划分的,而是通过相对差值来分配权重的.避免了优先级差值不大的两个进程得到的处理器使用权重相差过大的情况.<br>在这里是由操作系统来确定进程应该使用多久,假设nice=0的进程分配时间片为100ms,则另一个nice=20的进程时间片为5ms.<br>如果按照绝对差值来分配时间片可能出现下列情况:<br>两个进程优先级分别为0和1,一个为100ms,则另一个为95ms,这时候基本没有问题.但是当两个优先级分别为18和19,那么一个为10ms,一个为5ms,这样前者比后者多出了一倍的处理器时间,是相对不合理的.</p><h2 id="linux调度的实现"><a href="#linux调度的实现" class="headerlink" title="linux调度的实现"></a>linux调度的实现</h2><h3 id="时间记账"><a href="#时间记账" class="headerlink" title="时间记账"></a><strong>时间记账</strong></h3><p>CFS不再有时间片概念,维护每个进程运行的时间的记账,保存在进程描述符中.<br>每个进程都有一个虚拟运行时间,该运行时间的计算是所有可运行进程总数的标准化(是被加权的).虚拟时间以ns为单位.CFS使用vruntime变量来记录一个程序到底运行了多长时间以及还应该在运行多久.<br>vruntime运行时间计算如下:</p><ul><li>首先的到当前进程的执行时间,然后在根据当前可运行进程总数对运行时间进行加权计算,在将权重值与当前进程的vruntime相加.</li><li>vruntime准确的测量给定进程的运行时间,而且可知道谁应该是下一个被运行的进程,因为他是根据运行时间最小的进程优先调度的.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static const int prio_to_weight[40] = &#123;</span><br><span class="line">/* -20 */     88761,     71755,     56483,     46273,     36291,</span><br><span class="line">/* -15 */     29154,     23254,     18705,     14949,     11916,</span><br><span class="line">/* -10 */      9548,      7620,      6100,      4904,      3906,</span><br><span class="line">/*  -5 */      3121,      2501,      1991,      1586,      1277,</span><br><span class="line">/*   0 */      1024,       820,       655,       526,       423,</span><br><span class="line">/*   5 */       335,       272,       215,       172,       137,</span><br><span class="line">/*  10 */       110,        87,        70,        56,        45,</span><br><span class="line">/*  15 */        36,        29,        23,        18,        15,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在linux中CPU nice值每下降1,则获得多10%的cpu时间,而这10%有一个相对的概念.就像上文所说的,如果用绝对的方式来说那么就会出现两倍的差距;<br>这里一张表表明了40个优先级的权重表示.比如有A,B两个进程nice都为0,那么每个的cpu占用时间都为1024/(1024+1024)=50%(这里1024代表上面0对应的权值),但是B要少出10的cpu时间的话,则将B的nice值加1,则应该有1024/(1024+B的权值) = 45%;算出来B的权值为837,与820相差不多,所以这里是按照相对值来计算获得的cpu时间的.<br><strong>以上参考博文 <a href="https://blog.csdn.net/u010173306/article/details/46743491" target="_blank" rel="noopener">https://blog.csdn.net/u010173306/article/details/46743491</a></strong></p><h3 id="进程选择"><a href="#进程选择" class="headerlink" title="进程选择"></a><strong>进程选择</strong></h3><p>主要选择具有最小vruntime的任务;通过使用红黑树来保存这些进程</p><h3 id="调度器入口"><a href="#调度器入口" class="headerlink" title="调度器入口"></a><strong>调度器入口</strong></h3><p>进程调度的时候首先是以调度器的优先级为顺序从高到低一次检查每个调度类,并且从最高优先级的调度类中选择最高优先级的进程.这样就找到最高优先级的进程,也就是vruntime最小的进程.</p><h3 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a><strong>睡眠和唤醒</strong></h3><p>内核操作: 首先标记自己为休眠状态,从可执行红黑树中移除,放入等待队列.在选择一个可执行进程.唤醒相反.<br>等待队列: 维护一个等待队列,当要休眠的时候放入到等待队列.编码是一个while(true)循环中等待,在被唤醒后在此检查条件是否为真,为真就会退出循环,将自己移除出等待队列,加入可执行红黑树中.<br>唤醒:唤醒操作通过函数wake_up()进行,唤醒指定的等待队列上的所有进程.</p><h2 id="抢占和上下文切换"><a href="#抢占和上下文切换" class="headerlink" title="抢占和上下文切换"></a>抢占和上下文切换</h2><p>内核中有一个参数为need_resched参数,表明是否需要重新执行一次调度,此过程称为抢占.</p><ul><li>用户抢占:　在系统调用返回用户控件或从中断处理程序返回用户空间是会发生用户抢占，当然need_resched参数要设置</li><li>内核抢占: 除了need_resched参数还有一个preempt_count参数,表明是否持有锁,在preempt_count为0的时候说明在执行任务持有锁,此次抢占是不安全的.直到当前新进程持有的所有锁都释放了,才会重新执行调度.</li></ul><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用在用户空间进程和硬件设备之间添加了一个中间层,作用有三个:</p><ol><li>首先为用户空间提供了一种硬件的抽象接口.这样应用程序不管磁盘类型和介质,不管文件系统是那种类型</li><li>第二 系统调用保证了系统的稳定和安全.作为硬件设备和应用程序之间的中间人可以基于权限,用户类型和其他规则对需要进行的访问进行裁决,避免引用程序不正当的使用硬件设备.</li><li>每个进程都运行在虚拟系统中,而在用户控件和系统的其余部分提供这样一层公共接口.在linux中系统调用是用户空间进入内核的唯一手段,除了异常和陷入外,他们是内核唯一的合法入口.</li></ol><p>在linux中,每个系统调用被赋予一个系统调用号. 这样就可以根据一个独一无二的号关联系统调用.进程不会提及系统调用的名称.如果一个系统调用删除,他所占用的系统调用号不允许被回收,否则以前编译过的代码调用此系统调用,但是事实上却调用另一个系统调用容易引发错误.如果一个系统调用被删除会用sys_ni_syscall()替换,此函数返回-ENOSYS.内核记录了系统调用表中的所有已注册过的系统调用的列表.存储在sys_call_table中. </p><h3 id="指定系统调用"><a href="#指定系统调用" class="headerlink" title="指定系统调用"></a><strong>指定系统调用</strong></h3><p>所有的系统调用陷入内核方式都一样,所以必须把系统调用号一并创给内核.在x86上,系统调用号通过eax寄存器传递给内核.在陷入内核前,用户空间就把响应系统调用锁对应的号放入eax中.</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a><strong>参数传递</strong></h3><p>调用系统调用有时需要一些参数,最简单的办法是把参数也存放在寄存器里.在ebx ecx edx esi edi按照顺序存放前5个参数.应用用一个单独的寄存器存放指向所有这些参数在用户空间地址的指针.给用户空间的返回值也通过寄存器传递.</p><h3 id="调用参数限制"><a href="#调用参数限制" class="headerlink" title="调用参数限制"></a><strong>调用参数限制</strong></h3><p>在进行系统调用之前会先检查他们所有的参数是否合法有效.在接受用户空间的指针前,内核必须保证:</p><ul><li>指针指向的内存区域属于用户空间.进程决不能哄骗内核去读内核空间的数据.</li><li>指针指向的内核区域在进程的地址空间里.进程绝不能哄骗内核去读取其他进程的数据.</li><li>如果是读,该内存可以被读;如果是写操作,该内存应该可写;如果是可执行,必须被标记为可执行.进程局不能绕过内存访问限制.<br>如果调用成功返回0,否则返回标准-EFAULT<h3 id="绑定系统调用"><a href="#绑定系统调用" class="headerlink" title="绑定系统调用"></a><strong>绑定系统调用</strong></h3>在编写完一个系统调用后，要把它注册程一个正式的系统调用</li></ul><ol><li>首先在系统调用表的最后加入一个表项,从0开始算起</li><li>系统调用必须被编译进内核映像(不能被编译成模块)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux进程管理</title>
      <link href="/2019/03/31/linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2019/03/31/linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="linux进程管理"><a href="#linux进程管理" class="headerlink" title="linux进程管理"></a>linux进程管理</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><blockquote><p>进程就是处于执行期的程序.但不仅仅局限于一段可执行程序代码.通常还要包括其他资源,打开的文件,挂起的信号,内核内部数据,处理器状态,一个或多个具有内存映射的内存地址空间或多个执行线程.<br>在linux中线程是一种特殊的进程.是内核调度的对象.每个线程都拥有一个独立的程序计数器,进程栈,一组进程寄存器.<br>在操作系统中进程提供两种虚拟机机制:虚拟处理器和虚拟内存   </p></blockquote><h2 id="进程描述符及任务结构"><a href="#进程描述符及任务结构" class="headerlink" title="进程描述符及任务结构"></a>进程描述符及任务结构</h2><blockquote><p>内核把进程的列表存在叫任务队列的双向循环链表中.链表的每一项类型为task_struct称为进程描述符的机构.主要保存有:打开的文件,进程的地址空间,挂起的信号,进程的状态等.<br>每个进程都有自己的父进程,父进程可以管理其子进程.通过fork创建子进程.<br>在系统中有一个进程内核栈,动态生成task_struct只需要在栈上创建一个新结构thread_info,thread_info中包含了指向task_struct的指针.</p></blockquote><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在linux中线程创建和普通进程的创建类似,但是在调用clone()(也就是复制父进程的资源)的时候要传入参数指明要共享的资源.因为在linux中线程和普通的进程差不多,只是有共享资源.  </p><h2 id="进程终结"><a href="#进程终结" class="headerlink" title="进程终结"></a>进程终结</h2><p>原因: </p><ul><li>可能是自身引起,调用exit()系统调用.可能被其他进程终结.<br>过程:</li></ul><ol><li>讲tast_struct中标志成员设置为PF_EXITING.</li><li>调用deltimersync()删除任意内核定时器.根据返回结果,确保没有定时器在排队,也没有定时器处理程序在运行.</li><li>如果BSD(伯克利软件套件)进程记账功能开启,do_exit()调用函数输出记账信息.</li><li>调用exit_files和exit_fs(),分别递减文件描述符,文件系统数据的引用技术.如果每个引用技术为0,则可以释放</li><li>把退出代码保存下来,供父进程随时检索.</li><li>调用exit_notify()向父进程发送信号,给子进程重新找养父,养父为线程组的其他线程或者init进程,并吧线程状态设置为EXIT_ZOMBIE</li><li>切换新的进程</li></ol><blockquote><p>在每个进程结束之后都会保留一个退出信息,等待父进程调用结束后在被释放.(通过wait()函数).<br>如果父进程在子进程之前退出,就会在当前线程组内找一个线程作为父亲,如果不行就让init进程做他们的父进程.保证了每个进程死亡之后不会僵死,会有父进程回收此进程的退出代码信息</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
