<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mysql-InnoDB行记录格式</title>
      <link href="/2019/05/29/Mysql-InnoDB%E8%A1%8C%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F/"/>
      <url>/2019/05/29/Mysql-InnoDB%E8%A1%8C%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h1><p>InnoDB存储引擎是面向列的,就是说数据是按照行进行存放的. 每个页存放的行记录也是有硬性定义的,最多允许存放16KB/2-200行的记录.这里主要介绍两种行记录格式.Compact和Redundant格式.</p><h1 id="Compact行记录格式"><a href="#Compact行记录格式" class="headerlink" title="Compact行记录格式"></a>Compact行记录格式</h1><p><img src="/2019/05/29/Mysql-InnoDB行记录格式/compact.png" alt></p><p>首先首部是一个非NULL变长字段长度列表,并且是按照列的顺序逆序放置的,其长度为:</p><ul><li>若列的长度小于255字节,用1字节表示</li><li>若大于255字节,用2字节表示</li></ul><p>变长字段的长度最大不可以超过2字节,因为在MySQL数据库中varchar类型的最大长度限制为65535.<br>也就是列表中的最后一个数据就是表中第一个变长字段的数据列的数据的长度.</p><p>变长字段之后的第二个部分就是NULL标志位,该位只是了该行数据中是否有NULL值,有则用1表示,该部分所占的字节为1字节.记下来是记录头信息,占用5字节.主要含义为:<br><img src="/2019/05/29/Mysql-InnoDB行记录格式/记录头信息.png" alt></p><p>这里的n_owned是该记录拥有的记录数,因为在InnoDB中,页中的行数据是存储在一个个槽中的,每个槽中可能有多条数据,这个值就是记录所在的槽中有几条记录的.<br>最后就是实际的每个列的数据. 这里需要注意的是,NULL不占该部分任何空间.就是NULL除了有NULL标志位外,没有任何的存储空间.<br>每行数据除了用户定义的列之外,还有两个隐藏列,事务ID列和回滚指针列.如果没有制定主键,还会增加一个6字节的worid列.</p><h1 id="Redundant行记录格式"><a href="#Redundant行记录格式" class="headerlink" title="Redundant行记录格式"></a>Redundant行记录格式</h1><p><img src="/2019/05/29/Mysql-InnoDB行记录格式/redundant.png" alt><br>首部不同与Compact,这里存储的是字段长度偏移列表.同样按照列的顺序逆序放置.是判断每一列的起始位置的偏移量来找见每个列的.<br>记录头信息:<br><img src="/2019/05/29/Mysql-InnoDB行记录格式/redundant记录头.png" alt></p><p>对于Redundant记录格式,记录头占用6字节,其中n_fields值代表一行中列的数量.占10位,也就是最多有1023个列.  </p><p>对于NULL值的处理与Compact不一样,在REdundant中只有varchar的NULL值不占空间,而其他确定长度的字段类型还是要占用空间.而Compact中都不占用空间.</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> InnoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL-InnoDB索引</title>
      <link href="/2019/05/29/MYSQL-InnoDB%E7%B4%A2%E5%BC%95/"/>
      <url>/2019/05/29/MYSQL-InnoDB%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引在Mysql中是很有用的,通过索引能够很快速的找到我们所要查询的数据.这里讲一下InnoDB存储引擎中的索引实现.</p><h1 id="B-索引"><a href="#B-索引" class="headerlink" title="B+索引"></a>B+索引</h1><p>在InnoDB引擎中,索引是通过B+树来实现的.并且是聚集索引.B+树不理解的可以去搜一下,网上教程挺多的.B+树索引在数据库中有一个特性就是高扇出性,在数据库中,树的高度一般都是2-4层.这也就是说一般查找某一个键值的记录只需要进行2-4次IO就可以.   </p><p>在InnoDB引擎中中B+树索引可以分为聚集索引和辅助索引,他们两个不同的地方在与聚集索引的叶子节点中存放的是行记录,辅助索引中存放的是主键值.在B+树中,非叶子节点也就是索引节点,非叶子节点是真正存储数据的节点.两种索引不同的地方在于叶子节点存放的数据是不同的.</p><h2 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h2><p>InnoDB引擎表是索引组织表,就是表中数据按照主键顺序存放.而聚集索引就是按照每张表的主键id构造一颗B+树,同时叶子节点中存放的就是整张表的行记录数据,就是聚集索引的叶子节点为数据页.上一篇博文说过在InnoDB中的数据都是按照页来存储的.这里B+树中的每个节点都对应一个页.大小为16KB.每个数据页都是由一个双向链表来连接的.    </p><h2 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h2><p>辅助索引,叶子节点并不包含行记录的全部数据.叶节点除了包含键值以外,每个叶子节点中的索引行中还包含了一个书签.该书签用来告诉InnoDB在哪里可以找到与索引相对应的行数据.这个书签其实就是对应的行数据的聚集索引键.     </p><p>因此在InnoDB中如果通过辅助索引来查找数据的,IO次数会比按照主键查询多一倍.</p><h2 id="B-树索引的分裂"><a href="#B-树索引的分裂" class="headerlink" title="B+树索引的分裂"></a>B+树索引的分裂</h2><p>传统的B+树索引的分裂是直接从中间开始分裂的.这种情况可能会导致一个问题就是分裂之后的数据页大部分空间都被浪费了.比如说一页中存储4条数据.插入1,2,3,4.是一页.这时候再插入5.会将1,2为一页,但是这一个节点中不会在存储其他的任何东西.会导致空间浪费.</p><p>针对这一点,INnoDB对于B+树索引的分裂做了一点小优化.对此InnoDB做了简单调整.<br>在InnoDB引擎中的PageHeader中有一下几个部分用来保存插入的顺序信息:</p><ul><li>PAGE_LAST_INSERT</li><li>PAGE_DIRECTION</li><li>PAGE_N_DIRECTION</li></ul><p>通过这些信息,InnoDB引擎可以决定是向左还是向右进行分裂.同时决定分裂点记录为哪一个.如果插入是随机的,则取页的中间记录作为分裂点的记录.这里没有优化.而如果上次的插入是递增或递减的,那么会做出一些优化.<br>比如向某一方向插入的记录数量为5,并且目前已经定位到的记录(InnoDB引擎插入时,首先需要进行定位,定位到的记录为带插入记录的前一条记录)之后还有三条记录,则分裂点的记录为定位到的记录后的第三条记录.</p><h2 id="Multi-Range-Read优化"><a href="#Multi-Range-Read优化" class="headerlink" title="Multi-Range Read优化"></a>Multi-Range Read优化</h2><p>MySQL5.6版本开始支持Multi-Range Read优化.简称(MRR)优化,这个优化主要目的就是为了减少磁盘的随机访问,并且将随机访问转化为较为顺序的数据访问.因为顺序访问磁盘效率会高,这里MRR会根据辅助索引查询的结果对主键进行排序,按照主键排序的顺序进行书签查找. 其次就是能够减少缓冲池中页被替换的次数. 批量处理对键值的查询操作.</p><p>MRR工作方式如下:</p><ul><li>将查询到的辅助索引键放入一个缓存中,这是缓存的数据根据辅助索引键排序</li><li>借着按照ROWID来进行排序</li><li>根据RowID的排序顺序来访问实际的数据文件.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> InnoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB表存储格式</title>
      <link href="/2019/05/28/InnoDB%E8%A1%A8%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F/"/>
      <url>/2019/05/28/InnoDB%E8%A1%A8%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><p>InnoDB引擎作为现在mysql的默认引擎,支持事务处理与外键约束,并且有很高的性能.今天这里来说一下InnoDB存储引擎中表的存储格式.  </p><h1 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h1><p>在InnoDB中,表都是根据主键顺序组织存放的.在InnoDB引擎中,每个表都有一个主键,如果在创建表的时候没有显示定义,则将表中的第一个非空唯一索引设为主键,如果没有这样的索引,则会自动创建一个6字节大小的指针.<br>看一个例子:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> mysql&gt; create table t( a int not null, unique key(a) );</span><br><span class="line"> mysql&gt; insert into t select 1;</span><br><span class="line"> mysql&gt; select _rowid from t;</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| _rowid |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">|      1 |</span><br><span class="line">+<span class="comment">--------+</span></span><br></pre></td></tr></table></figure></p><p>这里没有定义主键,会将第一个唯一非空索引设置为主键.也就是a作为主键.</p><h2 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h2><p>从InnoDB存储引擎的逻辑存储结构来看,所有数据都被逻辑地存放在一个空间中,称之为表空间.表空间又有由段(segment),区(extent),页(page)组成.页中存放着一个个的记录.<br><img src="/2019/05/28/InnoDB表存储格式/表空间结构.jpg" alt></p><h2 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h2><p>表空间可以看做是InnoDB存储引擎逻辑结构的最高层,所有的数据都被存放在表空间中.InnoDB引擎中有一个参数innodb_file_per_table,用来设置表空间的.如果开启了此参数,每张表内的数据可以单独放在一个表空间内,如果没开,则所有的表共享一个表空间. </p><h1 id="段"><a href="#段" class="headerlink" title="段"></a>段</h1><p>上图说明了表空间是由各个段组成的,常见的段有数据段,索引段,回滚段.在InnoDB中,表是索引组织的,因此就是索引就是数据.<br>就是数据段即为B+树上的叶子节点.索引段就是B+树上的非叶子节点. </p><h1 id="区"><a href="#区" class="headerlink" title="区"></a>区</h1><p>区是由连续的页组成的空间.在任何情况下每个区的大小都是1MB.默认情况下,InnoDB引擎中的页大小为16KB,即一个区中一共有64个连续的页.在InnoDB1.2.x版本中增加了innodb_page_size参数,该参数可以将默认的页大小设置为4K,8K,但是页中的数据库不压缩,这时候区中页的数量变为256,128.<br>这里有一个问题就是当启用了innodb_file_per_table后,创建的表的默认大小是96KB,区是连续的64个页,创建的表大小至少应该是1MB才对.这是因为在每个段开始的时候,先用32个页大小的碎片页来存放数据,在使用完这些页之后才是64个连续页的申请.这主要是对于一些小表或者undo这类的段,可以在开始时候申请较少的空间,节省磁盘容量的开销.   </p><h1 id="页"><a href="#页" class="headerlink" title="页"></a>页</h1><p>页是InnoDB磁盘管理的最小单位,在InnoDB引擎中,默认每个页的大小为16KB.<br>在InnoDB存储引擎中,常见的页类型有:</p><ul><li>数据页</li><li>undo页</li><li>系统页</li><li>事务数据页</li><li>插入缓冲位图页</li><li>插入缓冲空闲列表页</li><li>未压缩的二进制大对象页</li><li>压缩的二进制大对象页</li></ul><h1 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h1><p>InnoDB数据页由一下7个部分组成.</p><ul><li>File Header 文件头 38字节</li><li>Page Header (页头) 56字节</li><li>Infimun和Supremum Records</li><li>User Records(用户记录,就是行记录)</li><li>Free Space(空闲空间)</li><li>Page Directory(页目录)</li><li>File Trailer(文件结尾信息)<br><img src="/2019/05/28/InnoDB表存储格式/InnoDB数据页结构.png" alt></li></ul><h2 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h2><p>File Header用来记录页的一些头信息.包含此页的一些头信息.<br><img src="/2019/05/28/InnoDB表存储格式/FileHeader.png" alt></p><h1 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h1><p><img src="/2019/05/28/InnoDB表存储格式/PageHeader.png" alt></p><h2 id="Infimum-和-Supremum-Record"><a href="#Infimum-和-Supremum-Record" class="headerlink" title="Infimum 和 Supremum　Record"></a>Infimum 和 Supremum　Record</h2><p>在InnoDB存储引擎中,每个数据页中有两个虚拟的行记录,用来限定边界.Infimum记录的是比该页中任何主键值都要小的值,Supremum是比任何可能值都要大的值.这俩值在页创建时被简历,并且在任何情况下都不会被删除.</p><h2 id="User-Record-和Free-Space"><a href="#User-Record-和Free-Space" class="headerlink" title="User Record 和Free Space"></a>User Record 和Free Space</h2><p>User Record就是实际存储行记录的内容.在InnoDB中,每个行记录都会存储下一条记录的相对位置.因此这里存储的行记录可以想成是一个链表数据结构.<br>Free Space则就是空闲空间,同样也是链表数据结构.在一条记录被删除后,该空间会被加入空闲链表中.</p><h2 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h2><p>页目录中存放了记录的相对位置.有时候这些记录指针称为Slots(槽)或者目录槽.但是在InnoDB中并不是每个记录一个槽,这里的槽是个稀疏目录,即一个槽中可能有多个记录.每个记录都有一个n_owned的值,记录此记录所在槽中有多少个记录.伪记录Infimum的n_owned值总是1,记录Supremum的n_owned的取值范围为[1,8],当记录被插入或删除的时候需要对槽进行分裂或平衡的维护操作.<br>在Slots中记录按照索引键值顺序存放,这样利用二叉查找迅速找到记录的指针.由于Slots是一个稀疏目录,所以二叉查找是一个粗略的结果,之后在根据记录的下一个指针继续查找相关的记录.  </p><h2 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h2><p>为了检测页是否已经完整的写入磁盘(如可能发生的写入过程中磁盘损坏,机器关机等),InnoDB存储引擎的也中设置了File Trailer部分.File Trailer中只有一个FIL_PAGE_END_LSN部分,占用8字节.前4字节代表该页的checksum值,最后四字节和FileHeader中的FIL_PAGE_LSN相同.将这两个值与FileHeader中的两个值相比,是否一致,(这里checksum的比较需要通过InnoDB的checksum函数来进行比较,不是简单的等值比较),以此来保证页的完整性.</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> InnoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty之ChannelHandler事件</title>
      <link href="/2019/05/21/Netty%E4%B9%8BChannelHandler%E4%BA%8B%E4%BB%B6/"/>
      <url>/2019/05/21/Netty%E4%B9%8BChannelHandler%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="ChannelHandler事件"><a href="#ChannelHandler事件" class="headerlink" title="ChannelHandler事件"></a>ChannelHandler事件</h2><p>Netty是一款基于事件驱动的异步I/O框架.因此有很多事件.有时候不清楚事件是什么时候触发的,这里总结一下.</p><h2 id="inbound事件"><a href="#inbound事件" class="headerlink" title="inbound事件"></a>inbound事件</h2><p>入站事件,在Netty中入站事件是相对于被动发生的一些事件．比如说可读，写事件改变．是从管道的头部向尾部流动．<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMethodHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在将此handler添加到管道中的时候会触发此事件.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HandlerAdd"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在将此handler从管道中移除的时候会触发此事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HandlerRemove"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在此handler对应的pipeline对应的Channel注册到多路复用器上时触发.在handlerAdd之后</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"registered"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消注册时候触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"unregistered"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接建立之后触发,在handlerAdd和channelRegister之后</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channelActive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 连接关闭之后触发,在handlerRemove之前</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channelInActive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当Channel可读之后,会触发.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channelRead"</span>);</span><br><span class="line">        ctx.write(Unpooled.copiedBuffer(<span class="string">"hello"</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">        ctx.fireUserEventTriggered(<span class="string">"bac"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一次读操作完成会调用.并不一定是读取一个数据包.这里一次可能读取不了全部的消息,所以分步读取.如果很大的数据包,会分很多次读取.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"readComplete"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发的用户事件,可以自己定义.需要自己手动调用ctx.fireUserEventTriggered()方法触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eventTriggered"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在写状态改变的时候触发.这个情况一般发生在发送数据太多,对方的接收缓冲区满了,因此不可写,之后等待对方可写之后会触发此事件.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"writeChanged"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发生异常时候触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"exception"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="outbound事件"><a href="#outbound事件" class="headerlink" title="outbound事件"></a>outbound事件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">出站事件，相对来说是主动发生的事件，需要用户手动去调用的事件．数据流动为从尾部到头部．</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOutboundMethodHandler</span> <span class="keyword">extends</span> <span class="title">ChannelOutboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行绑定端口的时候调用此函数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bind"</span>);</span><br><span class="line">        <span class="keyword">super</span>.bind(ctx, localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发起连接的时候调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"connect"</span>);</span><br><span class="line">        <span class="keyword">super</span>.connect(ctx, remoteAddress, localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 断开连接时候调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"disconnect"</span>);</span><br><span class="line">        <span class="keyword">super</span>.disconnect(ctx, promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭Channel时候调用,或者手动触发ctx.close()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"close"</span>);</span><br><span class="line">        <span class="keyword">super</span>.close(ctx, promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用ctx.deregister()方法才可以</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deregister</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"deregister"</span>);</span><br><span class="line">        <span class="keyword">super</span>.deregister(ctx, promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里的读事件并不同于入站的读事件,而是注册读事件,是一个主动的动作.</span></span><br><span class="line">    <span class="comment">// 如果设置了自动读参数,则会在每次读操作完成之后调用此函数.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"read"</span>);</span><br><span class="line">        <span class="keyword">super</span>.read(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写数据会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"write"</span>);</span><br><span class="line">        <span class="keyword">super</span>.write(ctx, msg, promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 刷新数据才会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"flush"</span>);</span><br><span class="line">        <span class="keyword">super</span>.flush(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Netty </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty之unsafe</title>
      <link href="/2019/05/19/Netty%E4%B9%8Bunsafe/"/>
      <url>/2019/05/19/Netty%E4%B9%8Bunsafe/</url>
      
        <content type="html"><![CDATA[<h1 id="unsafe简介"><a href="#unsafe简介" class="headerlink" title="unsafe简介"></a>unsafe简介</h1><p>Unsafe接口实际上是Channel接口的辅助接口,它不应该被用户代码直接调用,实际上的I/O操作都是有Unsafe接口负责完成的.</p><h1 id="API定义"><a href="#API定义" class="headerlink" title="API定义"></a>API定义</h1><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">返回值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">localAddress()</td><td style="text-align:center">SocketAddress</td><td style="text-align:center">返回本地绑定的Socket地址</td></tr><tr><td style="text-align:center">remoteAddress()</td><td style="text-align:center">SocketAddress</td><td style="text-align:center">返回通信对端的Socket地址</td></tr><tr><td style="text-align:center">register(EventLoop eventLoop, ChannelPromise promise)</td><td style="text-align:center">void</td><td style="text-align:center">注册Channel到多路复用器上,一旦注册操作完成,通知ChannelFuture</td></tr><tr><td style="text-align:center">bind(SocketAddress localAddress, ChannelPromise promise)</td><td style="text-align:center">void</td><td style="text-align:center">绑定指定的localAddress到当前的Channel上,完成后通知ChannelFuture</td></tr><tr><td style="text-align:center">connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</td><td style="text-align:center">void</td><td style="text-align:center">绑定完成之后,连接服务器,操作完成之后通知ChannelFuture</td></tr><tr><td style="text-align:center">disconnect(ChannelPromise promise)</td><td style="text-align:center">void</td><td style="text-align:center">断开连接,完成后通知ChannelFuture</td></tr><tr><td style="text-align:center">close(ChannelPromise promise)</td><td style="text-align:center">void</td><td style="text-align:center">关闭Channel连接,完成后通知</td></tr><tr><td style="text-align:center">closeForcibly()</td><td style="text-align:center">void</td><td style="text-align:center">强制关闭连接</td></tr><tr><td style="text-align:center">deregister(ChannelPromise promise)</td><td style="text-align:center">void</td><td style="text-align:center">取消此Channel在多路复用器上的注册</td></tr><tr><td style="text-align:center">beginRead()</td><td style="text-align:center">void</td><td style="text-align:center">设置网络操作位为用于读取消息</td></tr><tr><td style="text-align:center">write(Object msg, ChannelPromise promise)</td><td style="text-align:center">void</td><td style="text-align:center">发送消息,完成之后通知ChannelFuture</td></tr><tr><td style="text-align:center">flush()</td><td style="text-align:center">void</td><td style="text-align:center">将发送缓冲数组中的消息写入到Channel中</td></tr><tr><td style="text-align:center">voidPromise()</td><td style="text-align:center">ChannelPromise</td><td style="text-align:center">返回一个特殊的可重用和传递的ChannelPromise,它不用于操作陈宫或失败的通知器,仅仅作为容器使用</td></tr><tr><td style="text-align:center">outboundBuffer()</td><td style="text-align:center">ChannelOutboundBuffer</td><td style="text-align:center">返回消息发送缓冲区</td></tr></tbody></table><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="继承类图"><a href="#继承类图" class="headerlink" title="继承类图"></a>继承类图</h2><p><img src="/2019/05/19/Netty之unsafe/对比类图.jpg" alt><br>这里继承类图,左边是Unsafe的继承类图,右边是Unsafe所属的类.<br>这里依旧从顶自下的分析unsafe的原理.</p><h1 id="AbstractUnsafe源码分析"><a href="#AbstractUnsafe源码分析" class="headerlink" title="AbstractUnsafe源码分析"></a><strong>AbstractUnsafe源码分析</strong></h1><p>这相当于是最顶层的实现类,实现了大部分方法.</p><h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a><strong>字段</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractUnsafe</span> <span class="keyword">implements</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新建一个输出缓冲区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ChannelOutboundBuffer outboundBuffer = <span class="keyword">new</span> ChannelOutboundBuffer(AbstractChannel.<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// recvhandler</span></span><br><span class="line">    <span class="keyword">private</span> RecvByteBufAllocator.Handle recvHandle;</span><br><span class="line">    <span class="comment">// 是否刷新数据 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> inFlush0;</span><br><span class="line">    <span class="comment">/** true if the channel has never been registered, false otherwise */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> neverRegistered = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a><strong>API</strong></h2><p><strong>获取地址</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SocketAddress <span class="title">localAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> localAddress0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SocketAddress <span class="title">remoteAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remoteAddress0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用外部类的方法,这些方法也就是AbstractChannel的方法,但是并没有被实现,要子类自己去实现.</p><p><strong>注册</strong><br>注册方法主要是将当前Unsafe对应的Channel注册到EventLoop的多路复用器上,然后调用pipeline.fireChannelRegistered()传播注册事件,之后如果已经激活了,调用pipeline.fireChannelActive()方法传播事件.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (eventLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"eventLoop"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRegistered()) &#123;</span><br><span class="line">        promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">"registered to an event loop already"</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</span><br><span class="line">        promise.setFailure(</span><br><span class="line">                <span class="keyword">new</span> IllegalStateException(<span class="string">"incompatible event loop type: "</span> + eventLoop.getClass().getName()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(</span><br><span class="line">                    <span class="string">"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;"</span>,</span><br><span class="line">                    AbstractChannel.<span class="keyword">this</span>, t);</span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里是注册的代码.首先判断一些先决条件,eventLoop不能为空,再判断是否已经被注册过了,之后,设置此eventLoop为此Channel的evetnLoop.之后有一个是否要异步执行的判断,如果当前线程就是与Channel对应的EventLoop所对应的线程,则不存在异步,直接调用register0()方法,如果不是.则异步调用,在eventLoop所有的线程去调用注册方法.  再来看一下register0()方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先Channel是否取消和是否打开着.接着调用doRegister()方法.此方法是由AbstractNioUnsafe对应的AbstractNioChannel实现,下面再介绍.接着唤醒handlerAdd()事件.然后传播.在向ChannelPromise中设置成功标识.接着在pipeline中传播register事件.然后在判断此Channel是否被激活,如果被激活,在判断是否是第一次注册,如果是,传播active事件.在判断是否是自动读,如果设置了自动读,则自动向多路复用器上注册读事件.如果中间出现异常,强制关闭连接,将异常信息写入promise中.</p><p><strong>bind</strong><br>bind方法主要用于绑定指定的端口.对于服务端,用于绑定监听端口,可以设置backlog参数,对于客户端,用于指定客户端Channel的本地绑定socket地址,具体实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line">    <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doBind(localAddress);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        closeIfClosed();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    safeSetSuccess(promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>绑定操作首先判断Channel是否取消和是否打开,不符合直接返回.然后调用doBind()方法执行绑定操作.此绑定操作在NioSocketChannel和NioServerSocketChannel中有不同的实现.<br>客户端代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">    SocketUtils.bind(javaChannel(), localAddress);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    SocketUtils.bind(javaChannel().socket(), localAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务端代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到客户端就是直接将Channel绑定到本地地址,服务端还有一个配置参数,也就是backlog参数.<br>再来看bind()方法的如下代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">    invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            pipeline.fireChannelActive();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码的意思就是说,如果在绑定之前是没有激活的,在绑定了之后被激活了,那么就会触发active事件.</p><p><strong>disconnect</strong><br>这个方法用于服务端或客户端主动关闭连接.代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!promise.setUncancellable()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doDisconnect();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        closeIfClosed();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wasActive &amp;&amp; !isActive()) &#123;</span><br><span class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.fireChannelInactive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    safeSetSuccess(promise);</span><br><span class="line">    closeIfClosed(); <span class="comment">// doDisconnect() might have closed the channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关闭连接方法就是调用了doDisconnect()方法执行具体操作,之后会异步调用fireChannelInactive()方法传播事件.</p><p><strong>deregister</strong><br>取消注册事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deregister</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise, <span class="keyword">final</span> <span class="keyword">boolean</span> fireChannelInactive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!promise.setUncancellable()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                </span><br><span class="line">                doDeregister();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Unexpected exception occurred while deregistering a channel."</span>, t);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fireChannelInactive) &#123;</span><br><span class="line">                    pipeline.fireChannelInactive();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Some transports like local and AIO does not allow the deregistration of</span></span><br><span class="line">                <span class="comment">// an open channel.  Their doDeregister() calls close(). Consequently,</span></span><br><span class="line">                <span class="comment">// close() calls deregister() again - no need to fire channelUnregistered, so check</span></span><br><span class="line">                <span class="comment">// if it was registered.</span></span><br><span class="line">                <span class="keyword">if</span> (registered) &#123;</span><br><span class="line">                    registered = <span class="keyword">false</span>;</span><br><span class="line">                    pipeline.fireChannelUnregistered();</span><br><span class="line">                &#125;</span><br><span class="line">                safeSetSuccess(promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果已经被取消注册,则直接设置成功.调用外部类的doDeregister()方法来执行取消注册操作.在AbstractNioChannel类中定义.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDeregister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    eventLoop().cancel(selectionKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用eventLoop中的cancel来取消注册.之后传播取消注册事件.</p><p><strong>write</strong><br>write方法并不是真正向Channel中写数据,而是将数据添加到发送缓冲区中.知道调用flush才真正将数据发送出去.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line">    ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</span><br><span class="line">    <span class="keyword">if</span> (outboundBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        safeSetFailure(promise, newWriteException(initialCloseCause));</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        msg = filterOutboundMessage(msg);</span><br><span class="line">        size = pipeline.estimatorHandle().size(msg);</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    outboundBuffer.addMessage(msg, size, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到,如果本channel不存在输出缓冲区,则直接将msg释放.在找到msg的size,之后添加到outboundBuffer中</p><p><strong>flush</strong><br>真正向Channel中写数据是在调用了此方法的时候.来看一下代码.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">outboundBuffer.addFlush();</span><br><span class="line">flush0();</span><br></pre></td></tr></table></figure></p><p>这里首先将输出缓冲区的消息标记为以刷新.然后调用flush0()方法,将消息发送出去.看一下flush0()的代码片段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">inFlush0 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!isActive()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isOpen()) &#123;</span><br><span class="line">            outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Do not trigger channelWritabilityChanged because the channel is closed already.</span></span><br><span class="line">            outboundBuffer.failFlushed(newFlush0Exception(initialCloseCause), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        inFlush0 = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    doWrite(outboundBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里首先看Channel是否是激活状态,如果不是,则报错.如果是,调用doWrite()方法,向Channel中写数据.这个doWrite()方法是根据子类的不同有不同的实现.分别在AbstractNioByteChannel(客户端)和AbstractNioMessageChannel(服务端)实现.具体的逻辑在上一篇Channel讲解中说过.这里就不细说了.总之,就是将此输出缓冲区中的数据写出去.</p><h2 id="AbstractNioUnsafe源码分析"><a href="#AbstractNioUnsafe源码分析" class="headerlink" title="AbstractNioUnsafe源码分析"></a><strong>AbstractNioUnsafe源码分析</strong></h2><p>AbstracNioUnsafe是AbstractUnsafe类的NIO实现.主要实现了connect,finishConnnect等方法.<br>方法解析<br><strong>connect</strong><br>连接方法,用来连接远程服务端.实现代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (connectPromise != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConnectionPendingException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">        <span class="keyword">if</span> (doConnect(remoteAddress, localAddress)) &#123;</span><br><span class="line">            fulfillConnectPromise(promise, wasActive);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            connectPromise = promise;</span><br><span class="line">            requestedRemoteAddress = remoteAddress;</span><br><span class="line">            <span class="keyword">int</span> connectTimeoutMillis = config().getConnectTimeoutMillis();</span><br><span class="line">            <span class="comment">// 设置定时任务,在这之后,</span></span><br><span class="line">            <span class="keyword">if</span> (connectTimeoutMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                connectTimeoutFuture = eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        ChannelPromise connectPromise = AbstractNioChannel.<span class="keyword">this</span>.connectPromise;</span><br><span class="line">                        ConnectTimeoutException cause =</span><br><span class="line">                                <span class="keyword">new</span> ConnectTimeoutException(<span class="string">"connection timed out: "</span> + remoteAddress);</span><br><span class="line">                        <span class="keyword">if</span> (connectPromise != <span class="keyword">null</span> &amp;&amp; connectPromise.tryFailure(cause)) &#123;</span><br><span class="line">                            close(voidPromise());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            promise.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (future.isCancelled()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (connectTimeoutFuture != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            connectTimeoutFuture.cancel(<span class="keyword">false</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        connectPromise = <span class="keyword">null</span>;</span><br><span class="line">                        close(voidPromise());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        promise.tryFailure(annotateConnectException(t, remoteAddress));</span><br><span class="line">        closeIfClosed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用doConnect()方法来建立连接.主要的实现在NioSocketChannel类中实现.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doConnect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (localAddress != <span class="keyword">null</span>) &#123;</span><br><span class="line">        doBind0(localAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> connected = SocketUtils.connect(javaChannel(), remoteAddress);</span><br><span class="line">        <span class="keyword">if</span> (!connected) &#123;</span><br><span class="line">            selectionKey().interestOps(SelectionKey.OP_CONNECT);</span><br><span class="line">        &#125;</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> connected;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            doClose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在发起连接请求后,操作可能有三种结果.</p><ol><li>连接成功,返回true</li><li>暂时没有连接上,服务端没有返回ACK应答,结果不确定返回false,但是这个时候需要将NioSocketChannel中的SelectionKey设置为OP_CONNECT,监听连接应答消息.</li><li>连接失败,抛异常.关闭连接.   </li></ol><p>在调用玩doConnect()方法之后,会判断连接结果.如果成功出发ChannelActive事件.如下代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fulfillConnectPromise</span><span class="params">(ChannelPromise promise, <span class="keyword">boolean</span> wasActive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (promise == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> active = isActive();</span><br><span class="line">    <span class="keyword">boolean</span> promiseSet = promise.trySuccess();</span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; active) &#123;</span><br><span class="line">        <span class="comment">// 这里出发ChannelActive事件</span></span><br><span class="line">        pipeline().fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!promiseSet) &#123;</span><br><span class="line">        close(voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Active事件在最后会将此Channel中的SelectionKey设置为OP_READ,监听读事件.<br>如果没有连接上服务器.则根据连接超时事件设置定时任务,超时时间之后出发校验,如果发现还没有完成,则关闭连接句柄.释放资源.并且关闭连接.<br>之后在设置连接结果,如果接收到连接完成通知,则判断连接是否被取消,如果取消则关闭句柄,释放资源,发起取消注册操作.</p><p><strong>finishConnect</strong><br>客户端接受到服务端的TCP握手应答信息.通过finishConnect()方法对连接结果进行判断.代码如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">    doFinishConnect();</span><br><span class="line">    fulfillConnectPromise(connectPromise, wasActive);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    fulfillConnectPromise(connectPromise, annotateConnectException(t, requestedRemoteAddress));</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (connectTimeoutFuture != <span class="keyword">null</span>) &#123;</span><br><span class="line">        connectTimeoutFuture.cancel(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    connectPromise = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先获取连接状态,当前返回false,之后执行doFinishConnect()方法,在NioSocketChannel中实现,具体实现如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFinishConnect</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!javaChannel().finishConnect()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里连接成功返回true,连接失败返回false,发生异常的返回false. 只要连接失败就会抛出Error.<br>如果这里连接完成就会执行fulfillConnectPromise(connectPromise, wasActive)方法,负责将Socketchannel修改为监听读操作.监听网络读事件.传播channelActive事件.   </p><p>在检查期间发生异常之后,则由定时任务关闭客户端连接,将Channel从Reactor线程的多路复用器上擦除.</p><h2 id="NioByteUnsafe源码分析"><a href="#NioByteUnsafe源码分析" class="headerlink" title="NioByteUnsafe源码分析"></a><strong>NioByteUnsafe源码分析</strong></h2><p>这里就是实现了父类的read()方法,这里重点分析此方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">    <span class="keyword">if</span> (shouldBreakReadReady(config)) &#123;</span><br><span class="line">        clearReadPending();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">    <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line">    ByteBuf byteBuf = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure></p><p>这里,首先获取连接的配置信息.然后获取此Channel绑定的管道,从设置中获取缓冲区分配器,和分配器的handler.<br>在向下看<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">    allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">    <span class="keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        byteBuf.release();</span><br><span class="line">        byteBuf = <span class="keyword">null</span>;</span><br><span class="line">        close = allocHandle.lastBytesRead() &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (close) &#123;</span><br><span class="line">            readPending = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">    readPending = <span class="keyword">false</span>;</span><br><span class="line">    pipeline.fireChannelRead(byteBuf);</span><br><span class="line">    byteBuf = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br></pre></td></tr></table></figure></p><p>先为byteBuf分配一个合适的缓冲区.只有调用doReadBytes(byteBuf)方法将可读数据写入byteBuf中.实现代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取handler</span></span><br><span class="line"><span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line"><span class="comment">// 将可读数据变为byteBuf的可写数据</span></span><br><span class="line">allocHandle.attemptedBytesRead(byteBuf.writableBytes());</span><br><span class="line"><span class="comment">// 读取数据到buf</span></span><br><span class="line"><span class="keyword">return</span> byteBuf.writeBytes(javaChannel(), allocHandle.attemptedBytesRead());</span><br></pre></td></tr></table></figure></p><p>从javaChannel中读取数据到buf中,长度为bytebuf可写的长度.当然真正读取到的数据不一定比length长,可能会小,返回读取的字节数.<br>下面接着看read()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line"><span class="keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    byteBuf.release();</span><br><span class="line">    byteBuf = <span class="keyword">null</span>;</span><br><span class="line">    close = allocHandle.lastBytesRead() &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (close) &#123;</span><br><span class="line">        readPending = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>设置上次读取字节的数量,之后判断是否读取到数据,如果没有读取到数据,则释放byteBuf. 如果读取数据小于0,则说明发生了异常.设置close为false.读取失败.需要关闭.退出循环.<br>如果读取成功则说明完成了一次异步读取事件.这个时候会出发一次ChannelRead()事件,这里有一点就是,完成一次读操作并不代表着读到了一条完整的信息.也可能是一条不完整的.可能会有粘包现象.所以需要在pipeline中自行处理.之后再将bytebuf释放. 因为每次读操作都未必能够完成缓冲区的全部读取工作,所以会对读取的字节数进行累加.在累加之前会对长度上线做保护,如果累计读取的字节数已经发生溢出,则将读取的字节数设置为整形最大值,退出循环.主要是为了防止本次读取时间过长,影响后面排队的task任务.这里如果没有溢出,执行累加操作.   在循环体内,会判断读操作的次数,默认一次最多只能执行16此读操作.如果超过,不允许在读,等待下一次selector轮询周期在执行.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">    readPending = <span class="keyword">false</span>;</span><br><span class="line">    pipeline.fireChannelRead(byteBuf);</span><br><span class="line">&#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">continueReading</span><span class="params">(UncheckedBooleanSupplier maybeMoreDataSupplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> config.isAutoRead() &amp;&amp;</span><br><span class="line">            (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;</span><br><span class="line">            totalMessages &lt; maxMessagePerRead &amp;&amp;</span><br><span class="line">            totalBytesRead &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">~~~ </span><br><span class="line">这个默认的读消息次数为<span class="number">16</span>此,因此到达<span class="number">16</span>次之后会直接退出,等待下一次再继续读.当读取消息完成之后,出发读操作完成事件.如果中间失败过,则关闭此链接.</span><br><span class="line">~~~java</span><br><span class="line">allocHandle.readComplete();</span><br><span class="line">pipeline.fireChannelReadComplete();</span><br><span class="line"><span class="keyword">if</span> (close) &#123;</span><br><span class="line">    closeOnRead(pipeline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后如果设置了非自动读.则取消掉注册上去的读操作事件.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">    removeReadOp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="NioMessageUnsafe源码分析"><a href="#NioMessageUnsafe源码分析" class="headerlink" title="NioMessageUnsafe源码分析"></a><strong>NioMessageUnsafe源码分析</strong></h2><p>此类是用来给服务端使用的,用来接受新来的连接.有一个链表字段,用来存储新过来的连接.  也是只复写了父类的read()方法,与NioByteUnsafe的read()方法基本一致,但是在调用的实际子类的实现方法上,调用的是<br>doReadMessages()方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">eventLoop</span><span class="params">()</span>.<span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 获取配置</span></span><br><span class="line">    <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">    <span class="comment">// 获取管道</span></span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line">    <span class="comment">// 设置config</span></span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line">    Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 读取message到readBuf()中</span></span><br><span class="line">                <span class="keyword">int</span> localRead = doReadMessages(readBuf);</span><br><span class="line">                <span class="keyword">if</span> (localRead == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (localRead &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    closed = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 增加一次消息处理次数,最大为16</span></span><br><span class="line">                allocHandle.incMessagesRead(localRead);</span><br><span class="line">            &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            exception = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = readBuf.size();</span><br><span class="line">        <span class="comment">// 将缓冲区中的消息都传入管道中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            readPending = <span class="keyword">false</span>;</span><br><span class="line">            pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清除消息</span></span><br><span class="line">        readBuf.clear();</span><br><span class="line">        </span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        <span class="comment">// 出发读完成操作</span></span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果出现异常,关闭连接,出发异常事件</span></span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">            closed = closeOnReadError(exception);</span><br><span class="line">            pipeline.fireExceptionCaught(exception);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">            inputShutdown = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (isOpen()) &#123;</span><br><span class="line">                close(voidPromise());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">            removeReadOp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 读取消息操作</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SocketChannel ch = SocketUtils.accept(javaChannel());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果获取到一个新连接.</span></span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加入到缓冲区中</span></span><br><span class="line">            buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Failed to create a new channel from an accepted socket."</span>, t);</span><br><span class="line">        <span class="comment">// 失败之后关闭.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Failed to close a socket."</span>, t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Netty </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty之Channel</title>
      <link href="/2019/05/18/Netty%E4%B9%8BChannel/"/>
      <url>/2019/05/18/Netty%E4%B9%8BChannel/</url>
      
        <content type="html"><![CDATA[<h1 id="Channel简介"><a href="#Channel简介" class="headerlink" title="Channel简介"></a>Channel简介</h1><p>Channel是Netty网络操作的抽象类,聚合了一组功能包括但不限于网络的读写,客户端发起连接,主动关闭连接等.也包括了Netty框架相关的功能,比如获得该Channel的EventLoop和pipeline等.     </p><p>在Netty中Channel是和JDK的SocketChannel分开的. 通过自定义的Channel对网络的I/O操作,网络I/O相关联的其他操作封装起来.统一对外提供.并且为SocketChannel和ServerSocketChannel提供了统一的视图.由不同的子类实现不同的功能.公共功能在抽象父类实现.最大的实现了功能和接口的重用.</p><h1 id="Channel抽象类方法"><a href="#Channel抽象类方法" class="headerlink" title="Channel抽象类方法"></a>Channel抽象类方法</h1><p><img src="/2019/05/18/Netty之Channel/channel方法.png" alt><br>这里就是Channel的内部的方法.里面包含一个抽象接口unsafe,是Channel的辅助接口.实际上具体的网络读写操作都是unsafe来完成的.Channel使用来给用户提供的一个调用接口.接下来来分析一些它的实现类来看看是怎么实现的.</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>在Netty中,Channel的实现类特别多,但是最终我们用到的应该是NioServerSocketChannel和NIOSocketChannel.这里就着重介绍这两个核心类.先来看一下这两个核心类的继承类图</p><h2 id="NioServerSocketChannel"><a href="#NioServerSocketChannel" class="headerlink" title="NioServerSocketChannel"></a>NioServerSocketChannel</h2><p><img src="/2019/05/18/Netty之Channel/NioServerSocketChannel类图.png" alt></p><h2 id="NioSocketChannel"><a href="#NioSocketChannel" class="headerlink" title="NioSocketChannel"></a>NioSocketChannel</h2><p><img src="/2019/05/18/Netty之Channel/NioSocketchannel.png" alt></p><p>分析源码就从上向下分析吧,先从Abstractchannel类开始.这是一个抽象类.</p><h2 id="AbstractChannel源码分析"><a href="#AbstractChannel源码分析" class="headerlink" title="AbstractChannel源码分析"></a><strong>AbstractChannel源码分析</strong></h2><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a><strong>字段</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannel</span> <span class="keyword">extends</span> <span class="title">DefaultAttributeMap</span> <span class="keyword">implements</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 日志</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternalLogger logger = InternalLoggerFactory.getInstance(AbstractChannel.class);</span><br><span class="line">    <span class="comment">// 异常.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClosedChannelException ENSURE_OPEN_CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(</span><br><span class="line">            <span class="keyword">new</span> ExtendedClosedChannelException(<span class="keyword">null</span>), AbstractUnsafe.class, <span class="string">"ensureOpen(...)"</span>);</span><br><span class="line">    <span class="comment">// 关闭异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClosedChannelException CLOSE_CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(</span><br><span class="line">            <span class="keyword">new</span> ClosedChannelException(), AbstractUnsafe.class, <span class="string">"close(...)"</span>);</span><br><span class="line">    <span class="comment">// 写时关闭一次样</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClosedChannelException WRITE_CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(</span><br><span class="line">            <span class="keyword">new</span> ExtendedClosedChannelException(<span class="keyword">null</span>), AbstractUnsafe.class, <span class="string">"write(...)"</span>);</span><br><span class="line">    <span class="comment">// 刷新关闭异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClosedChannelException FLUSH0_CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(</span><br><span class="line">            <span class="keyword">new</span> ExtendedClosedChannelException(<span class="keyword">null</span>), AbstractUnsafe.class, <span class="string">"flush0()"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NotYetConnectedException FLUSH0_NOT_YET_CONNECTED_EXCEPTION = ThrowableUtil.unknownStackTrace(</span><br><span class="line">            <span class="keyword">new</span> NotYetConnectedException(), AbstractUnsafe.class, <span class="string">"flush0()"</span>);</span><br><span class="line">    <span class="comment">// 父Channel</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Channel parent;</span><br><span class="line">    <span class="comment">// ChannelId,每个Channel都会有一个全局id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelId id;</span><br><span class="line">    <span class="comment">// Unsafe实例,</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line">    <span class="comment">// 与Channel绑定的pipeline</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultChannelPipeline pipeline;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> VoidChannelPromise unsafeVoidPromise = <span class="keyword">new</span> VoidChannelPromise(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CloseFuture closeFuture = <span class="keyword">new</span> CloseFuture(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 本地地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> SocketAddress localAddress;</span><br><span class="line">    <span class="comment">// 远程地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> SocketAddress remoteAddress;</span><br><span class="line">    <span class="comment">// 当前Channel注册的EventLoop</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> EventLoop eventLoop;</span><br><span class="line">    <span class="comment">// 是否已经注册</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> registered;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> closeInitiated;</span><br><span class="line">    <span class="comment">// 初始化异常</span></span><br><span class="line">    <span class="keyword">private</span> Throwable initialCloseCause;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache for the string representation of this channel */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> strValActive;</span><br><span class="line">    <span class="keyword">private</span> String strVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里,AbstractChannel聚合了所有Channel使用到的能力对象.由AbstractChannel统一进行初始化和封装.如果功能和子类相关.则由子类去实现.这里不得不说一句,Netty的设计极大的利用了继承体系.代码复用规则利用的是淋漓尽致.接下来看具体实现.</p><h3 id="核心API分析"><a href="#核心API分析" class="headerlink" title="核心API分析"></a><strong>核心API分析</strong></h3><p><strong>初始化</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        id = newId();</span><br><span class="line">        unsafe = newUnsafe();</span><br><span class="line">        pipeline = newChannelPipeline();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AbstractUnsafe <span class="title">newUnsafe</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title">newChannelPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPipeline(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">~~~ </span><br><span class="line">就是新建一个新建一个pipeline,unsafe实例和id属性.unsafe与子类相关,所以这里是newUnsafe()抽象方法,由子类实现.pipeline都用的是默认的pipeline,在这里实现.</span><br><span class="line"></span><br><span class="line">**网络I/O操作**</span><br><span class="line">~~~java</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pipeline.connect(remoteAddress, localAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">disconnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pipeline.disconnect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pipeline.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">deregister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pipeline.deregister();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里可以看到网络I/O操作就是调用pipeline的网络操作进行.也就是调用其中的handler进行具体逻辑.</p><p><strong>公共API</strong><br>对于一些公共的API,例如remoteAddress()和localAddress()方法等,此类中提供了一些实现.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SocketAddress <span class="title">remoteAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SocketAddress remoteAddress = <span class="keyword">this</span>.remoteAddress;</span><br><span class="line">    <span class="keyword">if</span> (remoteAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.remoteAddress = remoteAddress = unsafe().remoteAddress();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// Sometimes fails on a closed socket in Windows.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> remoteAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先从自己变量中获取,如果没有,在调用通过unsafe来获取.此unsafe()是需要子类去自己实现的.   </p><h2 id="AbstractNioChannel源码分析"><a href="#AbstractNioChannel源码分析" class="headerlink" title="AbstractNioChannel源码分析"></a>AbstractNioChannel源码分析</h2><h3 id="字段-1"><a href="#字段-1" class="headerlink" title="字段"></a><strong>字段</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractNioChannel</span> <span class="keyword">extends</span> <span class="title">AbstractChannel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternalLogger logger =</span><br><span class="line">            InternalLoggerFactory.getInstance(AbstractNioChannel.class);</span><br><span class="line">    <span class="comment">// 关闭管道异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClosedChannelException DO_CLOSE_CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(</span><br><span class="line">            <span class="keyword">new</span> ClosedChannelException(), AbstractNioChannel.class, <span class="string">"doClose()"</span>);</span><br><span class="line">    <span class="comment">// 这里使用SelectableChannel来使得ServerSocketChannel和</span></span><br><span class="line">    <span class="comment">// SocketChannel可以共用.通过此引用可以代表任何一个JDK的Channel,因此实现了公用,提供了统一的接口.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SelectableChannel ch;</span><br><span class="line">    <span class="comment">// 感兴趣事件集合</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> readInterestOp;</span><br><span class="line">    <span class="comment">// 这是Channel注册到选择器上所返回的选择键,这里使用</span></span><br><span class="line">    <span class="comment">// volatile是为了为了保证多个线程并发写操作时SelectionKey的可见性</span></span><br><span class="line">    <span class="keyword">volatile</span> SelectionKey selectionKey;</span><br><span class="line">    <span class="keyword">boolean</span> readPending;</span><br><span class="line">    <span class="comment">// 保存连接操作结果</span></span><br><span class="line">    <span class="keyword">private</span> ChannelPromise connectPromise;</span><br><span class="line">    <span class="comment">// 连接超时定时器</span></span><br><span class="line">    <span class="keyword">private</span> ScheduledFuture&lt;?&gt; connectTimeoutFuture;</span><br><span class="line">    <span class="comment">// 请求通信地址</span></span><br><span class="line">    <span class="keyword">private</span> SocketAddress requestedRemoteAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="API"><a href="#API" class="headerlink" title="API"></a><strong>API</strong></h3><p><strong>初始化</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.ch = ch;</span><br><span class="line">        <span class="keyword">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ch.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(</span><br><span class="line">                            <span class="string">"Failed to close a partially initialized socket."</span>, e2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Failed to enter non-blocking mode."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>初始化就是根据传进来的参数设置Channel,此Channel是JDK内置的Channel.然后设置感兴趣事件,接着设置为非阻塞模式.如果中间发生异常,则抛出.</p><p><strong>doRegister</strong><br>首先来看一下doRegister()方法.也就是Channel的注册方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">                eventLoop().selectNow();</span><br><span class="line">                selected = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先定义一个变量来表示是否成功.调用此SelectableChannel的register方法,将当前的Channel注册到EventLoop的多路复用器上.这里的SelectableChannel就相当于是JDK中的实现了此类的任意一个Channel.这里的register方法由具体的Channel实现.也就是JDK中的Channel的register方法.<br>这里注册感兴趣的事件为0,也就是对任何事件都不感兴趣,仅仅完成注册操作,之后接受到网络事件通知的时候可以在设置SelectionKey的感兴趣事件.如果此Channel已经取消,则抛出异常.如果是第一次处理该异常,则立即调用selectNow()方法将已经取消掉的selectionKey从多路复用器中删掉.继续发起下一次操作.如果仍然有异常,说明无法删除已经被取消的selectionKey,JDK中出现的BUG,直接抛出异常. </p><p><strong>doBeginRead</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">    <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readPending = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的主要作用就是开始读,意思是开始监听读事件.上面注册也说到了,注册的时候并不会注册感兴趣事件.一般会在这里调用监听读事件,这里的doBeginRead()说的是注册读事件,并不是开始读数据.当调用调用Channel.read()或者ChannelHandlerContext.read()会调用此方法,注意这两个方法都是出站的方法.入站的方法是ctx.fireChannelRead(msg)方法.<br>代码也很容易看懂,首先看此选择键是否有效,如果有效,则将读事件添加上去.在设置读等待标志位.</p><h2 id="AbstractNioMessageChannel源码分析"><a href="#AbstractNioMessageChannel源码分析" class="headerlink" title="AbstractNioMessageChannel源码分析"></a><strong>AbstractNioMessageChannel源码分析</strong></h2><p><img src="/2019/05/18/Netty之Channel/NioMessageChannel方法类图.png" alt></p><p>类中依旧有一个unsafe类,类是覆盖的父类的方法.<br>只有一个变量是用来表示输入是否完成标志.接下来看一下基本的方法</p><p><strong>doBeginRead()</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inputShutdown) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里调用父类的方法,也就是AbstractNioChannel的方法</span></span><br><span class="line">    <span class="keyword">super</span>.doBeginRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>doWrite()</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(ChannelOutboundBuffer in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SelectionKey key = selectionKey();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = key.interestOps();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Object msg = in.current();</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">                key.interestOps(interestOps &amp; ~SelectionKey.OP_WRITE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = config().getWriteSpinCount() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (doWriteMessage(msg, in)) &#123;</span><br><span class="line">                    done = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                in.remove();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Did not write all messages.</span></span><br><span class="line">                <span class="keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) == <span class="number">0</span>) &#123;</span><br><span class="line">                    key.interestOps(interestOps | SelectionKey.OP_WRITE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (continueOnWriteError()) &#123;</span><br><span class="line">                in.remove(e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在一个循环中做写事件.首先获取选择键,接着获取此选择键的感兴趣的事件.接着就进入循环中写数据.看下面片段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object msg = in.current();</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">                key.interestOps(interestOps &amp; ~SelectionKey.OP_WRITE);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先先获得要写的数据.如果为空,则说明已经没有数据要写了.再将<br>key的可写事件取消注册.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = config().getWriteSpinCount() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (doWriteMessage(msg, in)) &#123;</span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先设置一个半包标识为false,这个半包标识是什么呢,就是当缓冲区的数据特别多的时候,不可能一下子就发送完成,但是Netty又是一个高性能的异步I/O框架.所以不可能会让你一直运行下去,所以就有了半包标识来判断是否写入数据完成了.<br>这里的doWriteMessage(msg, in)没有实现,等待子类去实现,由子类来执行真正的写数据操作.<br>这里进入循环中,首先获取写事件的循环次数,一般默认为16,如果写入数据成功,则设置done标识符为true,退出循环,删除掉输出缓冲区中的数据,并且在之后取消选择键上的写事件.如果调用子类方法失败,则继续调用,直到超过最大次数16次之后退出循环,这个时候done为false,需要将写事件重新注册上去,待下次多路复用器选择后继续执行写操作.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (done) &#123;</span><br><span class="line">   in.remove();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) == <span class="number">0</span>) &#123;</span><br><span class="line">        key.interestOps(interestOps | SelectionKey.OP_WRITE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的方法都不重要了.因此就不多说了.有兴趣可以自己看一看.</p><h2 id="AbstractNioByteChannel源码分析"><a href="#AbstractNioByteChannel源码分析" class="headerlink" title="AbstractNioByteChannel源码分析"></a><strong>AbstractNioByteChannel源码分析</strong></h2><p>字段比较简单,有一个用于刷新数据的runnable(),用来异步将数据写入Socket中.这里不多说了,建议自己去看一看比较好.接下来看一些主要方法:</p><h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a><strong>API</strong></h3><p><strong>doWrite()</strong><br>这个方法类似于AbstractNioMessageChannel的doWrite()方法,但是要发送的数据不一样.看代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(ChannelOutboundBuffer in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> writeSpinCount = config().getWriteSpinCount();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Object msg = in.current();</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clearOpWrite();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        writeSpinCount -= doWriteInternal(in, msg);</span><br><span class="line">    &#125; <span class="keyword">while</span> (writeSpinCount &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    incompleteWrite(writeSpinCount &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先的到此channel的writeSpinCount值,之后循环向channel中写数据.这个值为了在发送缓冲区满了的时候不会一直因为执行此操作而浪费cpu,将此消息等到下次轮询的时候在发送.<br>首先从发送消息缓冲区弹出一条消息,接着判断消息是否为空.如果为空,说明消息发送完成,清除半包标识则调用clearOpWrite()清除写事件.</p><p><strong>clearOpWrite</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clearOpWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SelectionKey key = selectionKey();</span><br><span class="line">    <span class="keyword">if</span> (!key.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = key.interestOps();</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">        key.interestOps(interestOps &amp; ~SelectionKey.OP_WRITE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>清除半包标识就是通过将SelectionKey的网络网络操作位的写操作位置0来实现.</p><p><strong>doWriteInternal</strong></p><p>上面doWrite()方法主要是通过此方法来发送数据.这里来看一下.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doWriteInternal</span><span class="params">(ChannelOutboundBuffer in, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBuf) &#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        <span class="keyword">if</span> (!buf.isReadable()) &#123;</span><br><span class="line">            in.remove();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> localFlushedAmount = doWriteBytes(buf);</span><br><span class="line">        <span class="keyword">if</span> (localFlushedAmount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            in.progress(localFlushedAmount);</span><br><span class="line">            <span class="keyword">if</span> (!buf.isReadable()) &#123;</span><br><span class="line">                in.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看一下代码,太长了,只写了一部分.首先判断是否是ByteBuf类型的,如果是,则进行强制类型转换. 如果不可此Bytebuf不可读,则从发送消息数组中移除此消息.继续循环处理其他消息.<br>如果buf中有数据,则调动doWriteBytes(buf)方法向Channel写数据,这里是需要子类去实现的.返回写入的字节数.如果此返回0,说明没有发送出去数据,可能发送缓冲区满了,则返回Integer.MAX_INT.这个时候需要设置写半包标识,待下一次选择写数据.<br>如果写入的数据大于0,则调用in.progress(localFlushedAmount)方法来更新输出缓冲区的发送进度信息.然后对发送的buf进行判断,如果没有数据,则从消息队列中删除.  </p><p><strong>incompleteWrite</strong><br>在doWrite()方法的最后会调用此函数,判断是否已经写入完成了.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incompleteWrite(writeSpinCount &lt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>看代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">incompleteWrite</span><span class="params">(<span class="keyword">boolean</span> setOpWrite)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (setOpWrite) &#123;</span><br><span class="line">        setOpWrite();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearOpWrite();</span><br><span class="line">        eventLoop().execute(flushTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法比较简单.首先判断是否需要设置半包标识,也就是上面doWrite()方法中的writeSpinCount是否小于0,小于0说明数据没有发送完成,因为如果数据发送完成会通过break退出循环,导致writeSpinCount大于0,只有在还有数据没有发送完成的时候才会小于0.则需要设置半包标识,待下次发送.如果发送完成了.则清除半包标识,获取eventloop执行冲刷数据操作.就是真正向Channel中写数据的操作.之前的只是一些向Channel中写数据的逻辑调用.</p><p><strong>setOpWrite</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setOpWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SelectionKey key = selectionKey();</span><br><span class="line">    <span class="keyword">if</span> (!key.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = key.interestOps();</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) == <span class="number">0</span>) &#123;</span><br><span class="line">        key.interestOps(interestOps | SelectionKey.OP_WRITE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主要就是设置半包标识,也就是向Channel中注册写事件.一般来说,写事件都会发生,只有在自己发送消息太多,对方的发送缓冲区满了的情况下写事件才不会发生.</p><h2 id="NioServerSocketChannel-1"><a href="#NioServerSocketChannel-1" class="headerlink" title="NioServerSocketChannel"></a><strong>NioServerSocketChannel</strong></h2><p>字段没有什么好说的,主要看一下方法.<br><strong>初始化</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//DEFAULT_SELECTOR_PROVIDER是默认的JDK的Selector的提供者</span></span><br><span class="line">    <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> provider.openServerSocketChannel();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(</span><br><span class="line">                <span class="string">"Failed to open a server socket."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里初始化父类,然后忽的默认的SelectorProvider,来创建新的ServerSocketChannel.  </p><p><strong>doBind()</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">绑定方法主要就是调用javaChannel也就是jdk的Channel的绑定地址的方法.不过这里有了判断,判断这里平台中的jdk版本,有不一样的调用措施.</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>doReadMessage</strong><br>NioServerSocketChannel是继承的AbstractNioMessageChannel类.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SocketChannel ch = SocketUtils.accept(javaChannel());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Failed to create a new channel from an accepted socket."</span>, t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Failed to close a socket."</span>, t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先accept等待有连接接入,如果有的话,新建一个NioSocketChannel加入buf中.之后传入pipeline中的handler处理事件.</p><h2 id="NioSocketChannel源码分析"><a href="#NioSocketChannel源码分析" class="headerlink" title="NioSocketChannel源码分析"></a><strong>NioSocketChannel源码分析</strong></h2><p>NioScketChannel是继承自AbstractNioByteChannel类,与NIOServerSocketChannel不一样.至于再向上层走就一样了.这就是Netty的设计的好处,极可能的找到所有的共同点,在父类进行公共功能的实现.依赖与具体的由子类来实现. </p><h3 id="API实现"><a href="#API实现" class="headerlink" title="API实现"></a><strong>API实现</strong></h3><p><strong>doBind</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    doBind0(localAddress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        SocketUtils.bind(javaChannel(), localAddress);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        SocketUtils.bind(javaChannel().socket(), localAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过此工具类来进行绑定操作.</p><p><strong>doConnect</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doConnect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (localAddress != <span class="keyword">null</span>) &#123;</span><br><span class="line">        doBind0(localAddress);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> connected = SocketUtils.connect(javaChannel(), remoteAddress);</span><br><span class="line">        <span class="keyword">if</span> (!connected) &#123;</span><br><span class="line">            selectionKey().interestOps(SelectionKey.OP_CONNECT);</span><br><span class="line">        &#125;</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> connected;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            doClose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>连接操作就是首先看本地地址,不为空则先执行绑定操作,之后调用工具类来执行连接操作.如果连接成功,返回成功,如果连接未完成,则向SelectionKey上添加连接事件.以便下一次轮询继续执行连接操作.如果出错,则执行doClose()操作.说明连接被拒绝或者被rest.</p><p><strong>doWriteBytes</strong><br>上面说道在AbstractNioByteChannel中的doWriteInternal()方法中调用了由子类复写的doWriteBytes(buf)方法,现在来看一下这里的实现.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doWriteBytes</span><span class="params">(ByteBuf buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedWrittenBytes = buf.readableBytes();</span><br><span class="line">    <span class="keyword">return</span> buf.readBytes(javaChannel(), expectedWrittenBytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先获取buf中的可读字节,之后在向channel中写入javaChannel中写入字节.</p><p><strong>doReadBytes</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadBytes</span><span class="params">(ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line">    allocHandle.attemptedBytesRead(byteBuf.writableBytes());</span><br><span class="line">    <span class="keyword">return</span> byteBuf.writeBytes(javaChannel(), allocHandle.attemptedBytesRead());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>直接将channel的数据写入到参数byteBuf中.</p><p><strong>doWrite</strong><br>重点看一下doWrite()方法,这个方法是执行写操作的.覆盖了父类的写方法<br>看一下实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(ChannelOutboundBuffer in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SocketChannel ch = javaChannel();</span><br><span class="line">    <span class="keyword">int</span> writeSpinCount = config().getWriteSpinCount();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (in.isEmpty()) &#123;</span><br><span class="line">            clearOpWrite();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxBytesPerGatheringWrite = ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();</span><br><span class="line">        </span><br><span class="line">        ByteBuffer[] nioBuffers = in.nioBuffers(<span class="number">1024</span>, maxBytesPerGatheringWrite);</span><br><span class="line">        <span class="keyword">int</span> nioBufferCnt = in.nioBufferCount();</span><br><span class="line">        <span class="keyword">switch</span> (nioBufferCnt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                writeSpinCount -= doWrite0(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                ByteBuffer buffer = nioBuffers[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> attemptedBytes = buffer.remaining();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> localWrittenBytes = ch.write(buffer);</span><br><span class="line">                <span class="keyword">if</span> (localWrittenBytes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    incompleteWrite(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                adjustMaxBytesPerGatheringWrite(attemptedBytes, localWrittenBytes, maxBytesPerGatheringWrite);</span><br><span class="line">                in.removeBytes(localWrittenBytes);</span><br><span class="line">                --writeSpinCount;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                <span class="keyword">long</span> attemptedBytes = in.nioBufferSize();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> localWrittenBytes = ch.write(nioBuffers, <span class="number">0</span>, nioBufferCnt);</span><br><span class="line">                <span class="keyword">if</span> (localWrittenBytes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    incompleteWrite(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                adjustMaxBytesPerGatheringWrite((<span class="keyword">int</span>) attemptedBytes, (<span class="keyword">int</span>) localWrittenBytes,</span><br><span class="line">                        maxBytesPerGatheringWrite);</span><br><span class="line">                in.removeBytes(localWrittenBytes);</span><br><span class="line">                --writeSpinCount;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (writeSpinCount &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    incompleteWrite(writeSpinCount &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看一下写操作.这里writeSpinCount就是对循环写的次数进行控制.因为如果发送缓冲区满了,则会阻塞,消息无法发送出去,如果不对写的次数进行限制的话,则线程无法对其他正在排队的task进行处理.因此对此做出控制,默认为16.<br>然后,首先获取到此输出缓冲区中的ByteBufffer的个数.如果为0,则直接看看是否还有其他东西可以写入.比如说文件等等.如果个数为1,则说明只有一个ByteBufffer,只写入第0个索引的缓冲区.如果超过1个,将此缓冲区数组中的数据都写入进去. 如果写入数据的操作返回0或负数,则调用incompleteWrite(true)方法,将此Channel设置为写半包状态,待下一次选择之后重新写入数据.  如果成功向其中写入数据,则移除输出缓冲区的响应的已经写入的字节.  意思就是 ch.write()方法会返回一个数值,就是已经写入的字节数.这个时候,会移除掉缓冲区中相应的字节数.再将可循环次数减1.<br>之后调用adjustMaxBytesPerGatheringWrite()方法来尽量使得系统的发送缓冲区的大小和自己设置的一样.这了主要是因为一些系统可能默认会改变自己设置的一些参数</p><p>剩下的还有一些方法就比较简单了,这里就不一一介绍了.可以自己去看一看源码.<br>这上面说的几个应该就是Channel旗下的几个核心类了.这里只说了api的实现,但是开头也说了,具体的操作很多还是靠其中的内部类unsafe来实现的.这里没有介绍,还是需要看看unsafe中怎么实现的.</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Netty </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty之事件传播机制</title>
      <link href="/2019/05/16/Netty%E4%B9%8B%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/05/16/Netty%E4%B9%8B%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Netty事件传播机制"><a href="#Netty事件传播机制" class="headerlink" title="Netty事件传播机制"></a>Netty事件传播机制</h1><p>使用过Netty应该都知道,Netty是通过在pipeline中设置一系列处理器来对数据进行一系列处理的.但是总是可能因为事件传播不过去而特别烦恼,也不知道是哪里出错了.今天这里来分析一下在Netty中的事件传播机制.</p><h1 id="入站和出站"><a href="#入站和出站" class="headerlink" title="入站和出站."></a>入站和出站.</h1><p>入站和出站首先要知道这三个类.ChannelHandler,ChannelOutboundHandler和ChannelInboundHandler.这两个一个是用来处理出站事件,一个处理入站事件.类文件结构图<br><img src="/2019/05/16/Netty之事件传播机制/class.jpg" alt><br>Netty对这两个接口都进行了一个适配.继承适配器之后只需要实现需要的方法就可以了,而不需要实现所有的方法.ChannelInboundHandlerAdapter和ChannelOutboundHandlerAdapter.<br>这两个类一个是处理入站,一个处理出站事件.入站事件(ChannelInboundHandler)就是数据从远程主机发送过来的事件,反之则是出站事件.而这些handler最终都被添加到一个pipeline中,在这个pipeline中流动.<br><img src="/2019/05/16/Netty之事件传播机制/pipeline.jpg" alt><br>这个管道中的handler的顺序取决于调用addLast()添加的顺序.能够看到,如果是入站事件,将会沿着pipeline中的头一直传入到尾部.出站事件则从尾部向头部传送.还有就是入站事件只传送给入站事件,出站事件只传送给出站事件.  </p><h1 id="pipeline初始化"><a href="#pipeline初始化" class="headerlink" title="pipeline初始化"></a>pipeline初始化</h1><p>想要明白pipeline中的事件传播过程,就首先要知道pipeline中的数据结构,要知道它中间到底存了些什么,都是干什么用的.<br>上一篇文章说到了当创建Channel的时候会自动创建与之绑定的Pipeline<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannel</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        id = newId();</span><br><span class="line">        unsafe = newUnsafe();</span><br><span class="line">        pipeline = newChannelPipeline();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其实就是创建一个DefaultChannelPipeline</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title">newChannelPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPipeline(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>进入看看这个DefaultChannelPipeline类,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelPipeline</span> <span class="keyword">implements</span> <span class="title">ChannelPipeline</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">"channel"</span>);</span><br><span class="line">        succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line">        voidPromise =  <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 建立一个尾节点</span></span><br><span class="line">        tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 新建头结点</span></span><br><span class="line">        head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里就能看出来了,在pipeline中的一个个处理器通过链表来连接起来的.但是在构造之初又添加了一个尾节点和头结点.就是在pipeline的两端都会有一个处理器.这两个个节点又是干什么的呢.下面再来看一下实现代码</p><p>再来看一下TailContext类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TailContext</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerContext</span> <span class="keyword">implements</span> <span class="title">ChannelInboundHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TailContext(DefaultChannelPipeline pipeline) &#123;</span><br><span class="line">        <span class="keyword">super</span>(pipeline, <span class="keyword">null</span>, TAIL_NAME, TailContext.class);</span><br><span class="line">        setAddComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        onUnhandledInboundChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        onUnhandledInboundChannelInactive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        onUnhandledChannelWritabilityChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> </span>&#123;</span><br><span class="line">        onUnhandledInboundUserEventTriggered(evt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        onUnhandledInboundException(cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        onUnhandledInboundMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        onUnhandledInboundChannelReadComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到这个类继承了AbstractChannelHandlerContext类,也就是它也是一个ChannelHandlerContext.在pipeline中的handler就是被封装到context中,然后通过链表连接起来的.<br>在发现实现了ChannelInboundHandler接口,也就是用来处理入站事件的.这个节点也能够看到是Tail也就是尾节点.不管怎么添加处理器节点,此节点永远在尾部处理程序.用来做善后.并且也用来作为输出数据的起始节点.<br>先来看一下具体的善后方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelPipeline</span> <span class="keyword">implements</span> <span class="title">ChannelPipeline</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个方法使用来善后异常捕获方法.如果异常传播到这里没有被处理,这里会发出警告,并且会释放异常</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.warn(</span><br><span class="line">                    <span class="string">"An exceptionCaught() event was fired, and it reached at the tail of the pipeline. "</span> +</span><br><span class="line">                            <span class="string">"It usually means the last handler in the pipeline did not handle the exception."</span>,</span><br><span class="line">                    cause);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundChannelActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundChannelInactive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传播事件,到这里 依旧会发出警告,接着如果可以释放掉,也就是释放此消息</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.debug(</span><br><span class="line">                    <span class="string">"Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. "</span> +</span><br><span class="line">                            <span class="string">"Please check your pipeline configuration."</span>, msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在来看一下HeadContextle<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadContext</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerContext</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span>, <span class="title">ChannelInboundHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line"></span><br><span class="line">        HeadContext(DefaultChannelPipeline pipeline) &#123;</span><br><span class="line">            <span class="keyword">super</span>(pipeline, <span class="keyword">null</span>, HEAD_NAME, HeadContext.class);</span><br><span class="line">            unsafe = pipeline.channel().unsafe();</span><br><span class="line">            setAddComplete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// NOOP</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// NOOP</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            unsafe.bind(localAddress, promise);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接方法  调用unsafe发起连接,出站事件</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                SocketAddress remoteAddress, SocketAddress localAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">                ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            unsafe.connect(remoteAddress, localAddress, promise);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断开连接方法,调用unsafe断开连接. 出站事件</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            unsafe.disconnect(promise);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            unsafe.close(promise);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deregister</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            unsafe.deregister(promise);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读消息事件.在有消息可以读取的时候会调用pipeline.read()方法,这个方法首先调用此方法,这里调用unsafe.beginRead()方法,开始读取,之后再传播可读事件.</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            unsafe.beginRead();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            unsafe.write(msg, promise);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            unsafe.flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">            ctx.fireExceptionCaught(cause);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            invokeHandlerAddedIfNeeded();</span><br><span class="line">            ctx.fireChannelRegistered();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            ctx.fireChannelUnregistered();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Remove all handlers sequentially if channel is closed and unregistered.</span></span><br><span class="line">            <span class="keyword">if</span> (!channel.isOpen()) &#123;</span><br><span class="line">                destroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            ctx.fireChannelActive();</span><br><span class="line"></span><br><span class="line">            readIfIsAutoRead();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            ctx.fireChannelInactive();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">            ctx.fireChannelRead(msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            ctx.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">            readIfIsAutoRead();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readIfIsAutoRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (channel.config().isAutoRead()) &#123;</span><br><span class="line">                channel.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> </span>&#123;</span><br><span class="line">            ctx.fireUserEventTriggered(evt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            ctx.fireChannelWritabilityChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到这里实现了入站和出栈顺序.入站是从pipeline的头部开始的.因此这里就是入站的开端.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    ctx.fireChannelRead(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过这个方法,可以看到,当有了可读事件之后,继续调用pipeline中的下一个入站处理器.调用ChannelRead()事件.<br>而出站是从后向前开始传递的.所有的处理器传递write事件,都会向前传递.知道这个头结点.然后执行unsafe.write(msg, promise)方法.这个unsafe就是调用具体的向Channel写数据的类.<br>到这里就能明白了.在我们定义的handler之外的数据是从哪里流入,又是从哪里流出. 从头结点开始读到可读事件开始,开始向后传递,如果一直向后传递会走到尾节点.之后会发出警告,然后释放掉可以释放的对象.<br>当最后执行可写事件之后,会一直向前传递写事件.最终会走到头结点.在调用unsafe.write(msg, promise);来把数据写入socket中.</p><p>到这里就能够明白在pipeline中管道中的数据的最终流向.这个头结点与尾节点就相当于是pipeline中的两个哨兵,为所有的操作都做一个善后工作.   </p><h1 id="pipeline中事件的传播"><a href="#pipeline中事件的传播" class="headerlink" title="pipeline中事件的传播"></a>pipeline中事件的传播</h1><h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p>我们知道pipeline中总会有两个节点,来处理事件的发生.可写事件是我们能够控制的.但是什么时候会调用pipeline中的fireChannelRead来传播可读事件呢.看下面代码.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">    unsafe.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体的调用栈如下图:<br><img src="/2019/05/16/Netty之事件传播机制/调用栈.png" alt></p><p>当有数据可以读取的时候,会调用unsafe.read()方法,去读取其中的内容.看一下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractNioByteChannel</span> <span class="keyword">extends</span> <span class="title">AbstractNioChannel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">NioByteUnsafe</span> <span class="keyword">extends</span> <span class="title">AbstractNioUnsafe</span> </span>&#123;</span><br><span class="line">        ... </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 首先获取到配置</span></span><br><span class="line">            <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">            <span class="keyword">if</span> (shouldBreakReadReady(config)) &#123;</span><br><span class="line">                clearReadPending();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 拿到此Channel对应的pipeline</span></span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">            <span class="comment">// 获取分配器</span></span><br><span class="line">            <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">            allocHandle.reset(config);</span><br><span class="line">            ByteBuf byteBuf = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 创建一个足够小的Buffer,能够接受所有入站数据,不会浪费空间</span></span><br><span class="line">                    byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">                    <span class="comment">// 获取上次操作已经读取的字节.这经常发生在要处理协议的地方. 其中的doREadBytes()则是将字节读取进入byteBuf中</span></span><br><span class="line">                    allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">                    <span class="keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        byteBuf.release();</span><br><span class="line">                        byteBuf = <span class="keyword">null</span>;</span><br><span class="line">                        close = allocHandle.lastBytesRead() &lt; <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                            readPending = <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// </span></span><br><span class="line">                    allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">                    readPending = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 这里调用pipeline传播读取数据操作.</span></span><br><span class="line">                    pipeline.fireChannelRead(byteBuf);</span><br><span class="line">                    byteBuf = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line"></span><br><span class="line">                allocHandle.readComplete();</span><br><span class="line">                pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                    closeOnRead(pipeline);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                handleReadException(pipeline, byteBuf, t, close, allocHandle);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">                    removeReadOp();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码可以看到.就是在这里调用pipeline.fireChannelRead(byteBuf)方法.来传播可读事件进行处理的.接下来就到了,pipeline中的事件传播了.<br>点进去这个方法可以看到以下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelPipeline</span> <span class="keyword">implements</span> <span class="title">ChannelPipeline</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里pipeline的启动读方法,也就是调用头结点的读方法</span></span><br><span class="line">        AbstractChannelHandlerContext.invokeChannelRead(head, msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用这个方法,传入参数为head,这里就会保证首先调用头结点的read方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">"msg"</span>), next);</span><br><span class="line">        EventExecutor executor = next.executor();</span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">            next.invokeChannelRead(m);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    next.invokeChannelRead(m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用头结点的channelRead()方法,开始向下传播</span></span><br><span class="line">                ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                notifyHandlerException(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fireChannelRead(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这就是上面提到的头结点的作用.有可读事件之后,首先调用pipeline的fireChannelRead方法.在方法内部.会继续调用头结点的channelRead()方法.之后通过头结点来向下传播事件.</p><p>也能发现.如果在入站事件,必须得显示调用fireChannelRead(byteBuf)才能够将可读事件继续向后传播.但是这个fireChannelRead()方法又是如何分辨出一个handler是处理入站事件或者处理出站事件的呢.先来看一下代码.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannelHandlerContext</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">        invokeChannelRead(findContextInbound(MASK_CHANNEL_READ), msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextInbound</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ctx = ctx.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((ctx.executionMask &amp; mask) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到首先先通过findContextInbound()方法找见下一个可以处理读事件的处理器.参数为MASK_CHANNEL_READ.这个MASK_CHANNEL_READ又是个什么呢.这个其实就是读事件的标识符.<br>这一系列事件标识符都定义在了ChannelHandlerMask类中.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_ALL_INBOUND = MASK_EXCEPTION_CAUGHT | MASK_CHANNEL_REGISTERED |</span><br><span class="line">        MASK_CHANNEL_UNREGISTERED | MASK_CHANNEL_ACTIVE | MASK_CHANNEL_INACTIVE | MASK_CHANNEL_READ |</span><br><span class="line">        MASK_CHANNEL_READ_COMPLETE | MASK_USER_EVENT_TRIGGERED | MASK_CHANNEL_WRITABILITY_CHANGED;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_ALL_OUTBOUND = MASK_EXCEPTION_CAUGHT | MASK_BIND | MASK_CONNECT | MASK_DISCONNECT |</span><br><span class="line">        MASK_CLOSE | MASK_DEREGISTER | MASK_READ | MASK_WRITE | MASK_FLUSH;</span><br></pre></td></tr></table></figure></p><p>上面的MASK_ALL_INBOUND和MASK_ALL_OUTBOUND就是区分入站和出站的数据的.但是这些常量是如何与pipeline中的handler中结合上的呢.这里就得说到pipeline中添加handler的操作了.在添加handler的时候,通过一系列的调用会到如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化默认的handlerContext</span></span><br><span class="line">DefaultChannelHandlerContext(</span><br><span class="line">        DefaultChannelPipeline pipeline, EventExecutor executor, String name, ChannelHandler handler) &#123;</span><br><span class="line">    <span class="comment">// 调用父类方法</span></span><br><span class="line">    <span class="keyword">super</span>(pipeline, executor, name, handler.getClass());</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor,</span><br><span class="line">                              String name, Class&lt;? extends ChannelHandler&gt; handlerClass) &#123;</span><br><span class="line">    <span class="comment">// 设置名字</span></span><br><span class="line">    <span class="keyword">this</span>.name = ObjectUtil.checkNotNull(name, <span class="string">"name"</span>);</span><br><span class="line">    <span class="comment">// 设置pipeline</span></span><br><span class="line">    <span class="keyword">this</span>.pipeline = pipeline;</span><br><span class="line">    <span class="comment">// 设置响应的执行器</span></span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="comment">// 设置可处理事件</span></span><br><span class="line">    <span class="keyword">this</span>.executionMask = mask(handlerClass);</span><br><span class="line">    <span class="comment">// Its ordered if its driven by the EventLoop or the given Executor is an instanceof OrderedEventExecutor.</span></span><br><span class="line">    ordered = executor == <span class="keyword">null</span> || executor <span class="keyword">instanceof</span> OrderedEventExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向管道中添加handler其实就是向管道中添加一个个的ChannelHandlerContext的过程.在这些Context中包含这处理器.<br>借着调用如下方法.mask().将自己的class类型传进去.来获取自己所能够处理的事件.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelHandlerMask</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mask0</span><span class="params">(Class&lt;? extends ChannelHandler&gt; handlerType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mask = MASK_EXCEPTION_CAUGHT;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ChannelInboundHandler.class.isAssignableFrom(handlerType)) &#123;</span><br><span class="line">                mask |= MASK_ALL_INBOUND;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelRegistered"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_CHANNEL_REGISTERED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelUnregistered"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_CHANNEL_UNREGISTERED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelActive"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_CHANNEL_ACTIVE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelInactive"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_CHANNEL_INACTIVE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelRead"</span>, ChannelHandlerContext.class, Object.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_CHANNEL_READ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelReadComplete"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_CHANNEL_READ_COMPLETE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelWritabilityChanged"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_CHANNEL_WRITABILITY_CHANGED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"userEventTriggered"</span>, ChannelHandlerContext.class, Object.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_USER_EVENT_TRIGGERED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ChannelOutboundHandler.class.isAssignableFrom(handlerType)) &#123;</span><br><span class="line">                mask |= MASK_ALL_OUTBOUND;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"bind"</span>, ChannelHandlerContext.class,</span><br><span class="line">                        SocketAddress.class, ChannelPromise.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_BIND;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"connect"</span>, ChannelHandlerContext.class, SocketAddress.class,</span><br><span class="line">                        SocketAddress.class, ChannelPromise.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_CONNECT;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"disconnect"</span>, ChannelHandlerContext.class, ChannelPromise.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_DISCONNECT;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"close"</span>, ChannelHandlerContext.class, ChannelPromise.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_CLOSE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"deregister"</span>, ChannelHandlerContext.class, ChannelPromise.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_DEREGISTER;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"read"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_READ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"write"</span>, ChannelHandlerContext.class,</span><br><span class="line">                        Object.class, ChannelPromise.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_WRITE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"flush"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                    mask &amp;= ~MASK_FLUSH;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"exceptionCaught"</span>, ChannelHandlerContext.class, Throwable.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_EXCEPTION_CAUGHT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// Should never reach here.</span></span><br><span class="line">            PlatformDependent.throwException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法应该能看出来,如果你的handler继承的是inboundHandler类的话,mask |= MASK_ALL_INBOUND;就相当与将此掩码设置为处理所有的入站事件.如果是outboundHandler会吃力所有的默认方法. 剩下的isSkippable()方法就是检索是否方法上有skip注解,如果有,则不处理这些事件.<br>下面在来看fireChannelRead(byteBuf)方法的实现.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextInbound</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ctx = ctx.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((ctx.executionMask &amp; mask) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里就是看下一个context是否能够处理此掩码所对应的事件.找到了就返回此Context.在调用此Context的对应方法来处理数据.<br>到这里就应该能明白了管道的传输机制了.<br>因为在添加handler的时候,为持有此handler的context添加了一些可处理事件的掩码.通过此掩码能够找到下一个能够处理此事件的Context.接着着处理此事件.   </p><h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><p>对于出站事件.也就是写数据的事件传播.也有自己的一套.<br>先来看一下最基本的写事件.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture ch1 =  ch.channel().writeAndFlush(Unpooled.copiedBuffer(<span class="string">"abc"</span>.getBytes()));</span><br></pre></td></tr></table></figure></p><p>如果是客户端发起写操作,那么应该会调用这句话.那这个writeAndFlush到底干了什么呢.看下面代码就知道了.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannel</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pipeline.writeAndFlush(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现会调用pipeline的写事件.这里pipeline在启动的时候也已经分析过了,其实就是DefaultChannelPipeline.看一下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelPipeline</span> <span class="keyword">implements</span> <span class="title">ChannelPipeline</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tail.writeAndFlush(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现调用Channel.write()方法其实就是调用pipeline中的尾节点的写数据操作.这里的尾节点就是当初创建pipeline的时候向pipeline中添加的结尾哨兵context. 因此这里就能明白了,不管在什么时候,如果调用的是channel.wirte()方法,数据必定是从尾节点开始向前传播的.<br>明白了Channel.write()的写操作原理,现在再来看一下它是怎么沿着pipeline传播出去的.接着看tail.writeAndFlush()方法.上面说过,这个tail节点是AbstractChannelHandlerContext的子类,这里的write方法就是调用的此父类的方法.看实现代码.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannelHandlerContext</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 开头检验部分删掉了</span></span><br><span class="line">        <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(flush ?</span><br><span class="line">                (MASK_WRITE | MASK_FLUSH) : MASK_WRITE);</span><br><span class="line">        <span class="keyword">final</span> Object m = pipeline.touch(msg, next);</span><br><span class="line">        EventExecutor executor = next.executor();</span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">                next.invokeWriteAndFlush(m, promise);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next.invokeWrite(m, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> AbstractWriteTask task;</span><br><span class="line">            <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">                task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">            &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">                task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!safeExecute(executor, task, promise, m)) &#123;</span><br><span class="line">                <span class="comment">// We failed to submit the AbstractWriteTask. We need to cancel it so we decrement the pending bytes</span></span><br><span class="line">                <span class="comment">// and put it back in the Recycler for re-use later.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// See https://github.com/netty/netty/issues/8343.</span></span><br><span class="line">                task.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看下面这个代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(flush ?</span><br><span class="line">                (MASK_WRITE | MASK_FLUSH) : MASK_WRITE);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextOutbound</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ctx = ctx.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((ctx.executionMask &amp; mask) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个寻找写一个处理出站的context好像和上面的寻找入站事件的有点相似.不过这里确实是一样的.也是通过此掩码来找到下一个处理此事件的context.这里是(MASK_WRITE | MASK_FLUSH)事件.上面也说过了,在添加handler的时候,会根据继承的父类,来判断此handler是否能够处理写事件或者是读事件.    </p><p>继续看这个方法内部<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object m = pipeline.touch(msg, next);</span><br><span class="line">EventExecutor executor = next.executor();</span><br><span class="line"><span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">        next.invokeWriteAndFlush(m, promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.invokeWrite(m, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractWriteTask task;</span><br><span class="line">    <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">        task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">    &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">        task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!safeExecute(executor, task, promise, m)) &#123;</span><br><span class="line">        <span class="comment">// We failed to submit the AbstractWriteTask. We need to cancel it so we decrement the pending bytes</span></span><br><span class="line">        <span class="comment">// and put it back in the Recycler for re-use later.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// See https://github.com/netty/netty/issues/8343.</span></span><br><span class="line">        task.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先调用touch方法,这个方法就是去释放掉这个msg的.这也就是为什么调用了write方法就不需要释放msg引用的原因了. 之后在判断当前线程是否是此executor的执行线程.如果是,则直接唤醒write方法(),接着向下传递.<br>如果不是此线程.则需要新建一个WriteTask,让此executor去执行此写操作.其中也是接着将写操作传递下去.不过是一个在本线程中执行.一个不在本线程中执行.在走到pipeline的head节点之后,回到用unsafe类来执行真正的向socket中写数据.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    unsafe.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</span><br><span class="line">    <span class="keyword">if</span> (outboundBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outboundBuffer.addFlush();</span><br><span class="line">    flush0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里之后会调用NioSocketChannel的doWrite()方法,真正的执行写数据.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioSocketChannel</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(ChannelOutboundBuffer in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取jdk的channel</span></span><br><span class="line">        SocketChannel ch = javaChannel();</span><br><span class="line">        <span class="keyword">int</span> writeSpinCount = config().getWriteSpinCount();</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 如果数据为空之后,则清除SelectionKey上的OPWrite()表示,不然可能会一直轮询,因为有写操作.</span></span><br><span class="line">            <span class="keyword">if</span> (in.isEmpty()) &#123;</span><br><span class="line">                clearOpWrite();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> maxBytesPerGatheringWrite = ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();</span><br><span class="line">            ByteBuffer[] nioBuffers = in.nioBuffers(<span class="number">1024</span>, maxBytesPerGatheringWrite);</span><br><span class="line">            <span class="keyword">int</span> nioBufferCnt = in.nioBufferCount();</span><br><span class="line">            <span class="comment">// 这里看buffer的引用数量</span></span><br><span class="line">            <span class="keyword">switch</span> (nioBufferCnt) &#123;</span><br><span class="line">                <span class="comment">// 如果是0的话</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    writeSpinCount -= doWrite0(in);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果引用为1的话</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                    ByteBuffer buffer = nioBuffers[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> attemptedBytes = buffer.remaining();</span><br><span class="line">                    <span class="comment">// 这里调用ch.write方法,向socket中写数据</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> localWrittenBytes = ch.write(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (localWrittenBytes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        incompleteWrite(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    adjustMaxBytesPerGatheringWrite(attemptedBytes, localWrittenBytes, maxBytesPerGatheringWrite);</span><br><span class="line">                    in.removeBytes(localWrittenBytes);</span><br><span class="line">                    --writeSpinCount;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>: &#123;</span><br><span class="line">                    <span class="keyword">long</span> attemptedBytes = in.nioBufferSize();</span><br><span class="line">                    <span class="comment">// 数量比1大,向socket中写n次.</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> localWrittenBytes = ch.write(nioBuffers, <span class="number">0</span>, nioBufferCnt);</span><br><span class="line">                    <span class="keyword">if</span> (localWrittenBytes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        incompleteWrite(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    adjustMaxBytesPerGatheringWrite((<span class="keyword">int</span>) attemptedBytes, (<span class="keyword">int</span>) localWrittenBytes,</span><br><span class="line">                            maxBytesPerGatheringWrite);</span><br><span class="line">                    in.removeBytes(localWrittenBytes);</span><br><span class="line">                    --writeSpinCount;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (writeSpinCount &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        incompleteWrite(writeSpinCount &lt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里就是写数据的实现了.当然了写数据不只这么简单,但是这篇文章是为了明白pipeline中的事件传播机制.主要是为了明白数据怎么传输,从哪里来,到那里去.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里,Netty中的pipeline中的事件传播机制就分析完了.虽然只分析了读写两个事件.但其实所有的事件都一样.和读写事件的传播是一样的.现在来总结一下最重要的几点    </p><ol><li>handler是保存在context中加入pipeline中的,并且用链表来关联起来</li><li>pipeline中有两大哨兵.headContext和tailContext. 当可读事件发生后,会首先调用head的读方法.之后继续向后传播,当使用channel.write()方法的时候,会使用tail节点的写方法写数据,之后向前传播.写到头结点之后调用unsafe.flush()方法将数据写入socket传入远端. </li><li>Netty中使用很多个掩码来区分入站和出站的事件.对于一个handler是处理出站还是入站方法是在context中包含有一个掩码值,来判断是否能够处理此事件.</li><li>入站事件必须显示的调用fireChannel**()方法才会将数据传播下去.而出站事件不需要.</li><li>ctx.channel().writeAndFlush(msg)和ctx.writeAndFlush(msg),前者是从尾节点向前写数据.后者是从当前位置写数据.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Netty </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty服务端启动分析</title>
      <link href="/2019/05/15/Netty%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/"/>
      <url>/2019/05/15/Netty%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Netty服务端"><a href="#Netty服务端" class="headerlink" title="Netty服务端"></a>Netty服务端</h1><p>大家都知道Netty启动服务端只需要配置好参数,然后调用bind()函数就可以启动了.下面这段代码就是普遍的的Netty中服务器的写法.我们从下面这段开始分析.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bootstrapServer.group(bossGroup,workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">for</span> (ChannelHandler handler : channelHandlers)&#123;</span><br><span class="line">                            ch.pipeline().addLast(handler);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .option(ChannelOption.SO_BACKLOG,<span class="number">1024</span>)</span><br><span class="line">                .option(ChannelOption.SO_RCVBUF,<span class="number">1024</span>)</span><br><span class="line">                .option(ChannelOption.SO_SNDBUF,<span class="number">1024</span>)</span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE,<span class="keyword">true</span>);</span><br><span class="line">ChannelFuture cf = bootstrapServer.bind(port).sync();</span><br></pre></td></tr></table></figure></p><p>本文略长,请耐心解读.本文分为四部分,分为NioServerSocketChannel的创建,初始化,注册和端口绑定四部分,也可以按需浏览.</p><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>从启动开始说起,启动之后,Bootstrap配置的参数才会一一设置到Channel中.从bind()方法说起.<br>bind()可以分为一下几个步骤:</p><ol><li>检查参数合法性,检查的是BootStrap中的设置的合法性,比如说是否有childHandler和childGroup</li><li>调用initAndRegister()方法,初始化和注册NioChannel</li><li>调用newChannel()方法创建Channel. 在newChannel()中初始化Channel和配置各种参数.</li><li>真正的绑定端口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture cf = bootstrapServer.bind(port).sync();</span><br></pre></td></tr></table></figure><p>一般我们就是通过bind()一个端口,然后进行启动服务端的.接下来看一看bind()到底做了什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这一句是检验参数的有效性,比如是否有childHandler 和 childGroup</span></span><br><span class="line">    validate();</span><br><span class="line">    <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"localAddress"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 真正执行bind()操作</span></span><br><span class="line">    <span class="keyword">return</span> doBind(localAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在看doBind()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span>, <span class="title">C</span>&gt;, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">        ...  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有一个initAndRegister方法()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span>, <span class="title">C</span>&gt;, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel = channelFactory.newChannel();</span><br><span class="line">            init(channel);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里可以看到是通过channelFactory来获得一个Channel 的,这个Factory又是个什么呢.其实在Netty默认的是ReflectiveChannelFactory.通过newChannel来获得一个Channel.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveChannelFactory</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">implements</span> <span class="title">ChannelFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里就是通过反射获得一个Channel</span></span><br><span class="line">            <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Unable to create Channel from class "</span> + constructor.getDeclaringClass(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是这个Factory是什么时候来的呢? 我们知道在我们配置BootStrap的时候我们会设置一个Channel的参数,如下面这个样子调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.channel(NioServerSocketChannel.class)</span><br></pre></td></tr></table></figure></p><p>这里设置了NioServerSocketChannel. 所以这里constructor其实就是一个NioServerSocketChannel的类型.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span>, <span class="title">C</span>&gt;, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (channelClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"channelClass"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里也就是将 channelFactory设置为ReflectiveChannelFactory.</span></span><br><span class="line">        <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(channelClass));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以也就很清晰明了了.这个channelFactory的由来.是通过上面传入的channel的参数来建立的.</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>上面说到newChannel()来看一下newChannel()是怎么创建一个Channel的<br>如果按照调用顺序最后一直点进去会发现一个语句,也就是newSocket方法.<br>这里创建ServerSocketChannel也有几步要走,总结一下如下:</p><ol><li>首先通过SelectorProvider创建一个ServerSocketChannel</li><li>根据ServerSocketChannel初始化和创建Netty封装的NioServerSocketChannel</li><li>初始化NioServerSocketChannelConfig配置参数.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServerSocketChannel</span></span>&#123;</span><br><span class="line">    <span class="comment">// 这里调用Jdk中的SelectorProvider</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();</span><br><span class="line">    <span class="comment">// 通过调用newSocket来返回一个JDK的ServerSocketChannel.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用SelectorProvider返回一个SocketChannel</span></span><br><span class="line">            <span class="keyword">return</span> provider.openServerSocketChannel();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(</span><br><span class="line">                    <span class="string">"Failed to open a server socket."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面提到factory调用newInstance来初始化NioServerSocket. 调用默认构造方法.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先调用newSocket()创建ServerSocketChannel,接着根据此Channel初始化NioServerSocketChannel.</span></span><br><span class="line">        <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里可以看是有JDK的身影,就是OP_ACCEPT,但是这里的OP_ACCEPT并不是马上就注册到选择器上的.这里只是初始化感兴趣事件而已.具体的注册函数在绑定操作实现的.之后在继续初始化channel,设置为非阻塞</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">// 初始化NioServerSocketChannelConfig</span></span><br><span class="line">        config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>再向深入了解,也就是上面的super()调用的方法就可以看到:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="keyword">this</span>.ch = ch;</span><br><span class="line">    <span class="comment">// 设置感兴趣的事件</span></span><br><span class="line">    <span class="keyword">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ch.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(</span><br><span class="line">                        <span class="string">"Failed to close a partially initialized socket."</span>, e2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Failed to enter non-blocking mode."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先将channel赋值,然后在设置感兴趣的事件.之后再设置为非阻塞.</p><p>之后再看parent方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannel</span> <span class="keyword">extends</span> <span class="title">DefaultAttributeMap</span> <span class="keyword">implements</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        id = newId();</span><br><span class="line">        unsafe = newUnsafe();</span><br><span class="line">        pipeline = newChannelPipeline();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里就是真正的设置Channel的参数.前面说过,每一个Channel都会有一个ChannelPipeline()于之相关联,并且会有一个Id.这里就是创建它们的地方.而这个unsafe 是用来实现I/O传输的.</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>到了这里基本上服务器Channel的创建就有了一个直观的了解.<br>现在再来看一下initAndRegister()方法中init()方法,这就是初始化ServerChannel的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span>, <span class="title">C</span>&gt;, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里刚才讲过了是创建了一个channel. 但是大致参数都没有配置,这里就是配置的过程.</span></span><br><span class="line">            channel = channelFactory.newChannel();</span><br><span class="line">            <span class="comment">// 这里的init()方法就是配置的过程.</span></span><br><span class="line">            init(channel);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                channel.unsafe().closeForcibly();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">        <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel.unsafe().closeForcibly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerBootstrap</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">        <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">            <span class="comment">// 这里是设置Channel的Option参数.</span></span><br><span class="line">            setChannelOptions(channel, options, logger);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">        <span class="comment">// 设置Attr值</span></span><br><span class="line">        <span class="keyword">synchronized</span> (attrs) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class="line">                channel.attr(key).set(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ChannelPipeline p = channel.pipeline();</span><br><span class="line">        <span class="comment">// 接下来就是设置childChannel的参数了.childChannel的参数也就是为新建的SocketChannel设置的参数.</span></span><br><span class="line">        <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">        <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">        <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">        <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class="line">        <span class="comment">// 获得选项参数</span></span><br><span class="line">        <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">            currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取附加的值</span></span><br><span class="line">        <span class="keyword">synchronized</span> (childAttrs) &#123;</span><br><span class="line">            currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对管道进行处理.为管道添加处理器.这里添加的处理器是为父类的.</span></span><br><span class="line">        p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                ChannelHandler handler = config.handler();</span><br><span class="line">                <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pipeline.addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最后进行对管道的处理,向管道中添加config的一些handler.<br>最后再异步想管道中添加一个处理程序也就是ServerBootstrapAcceptor. 将设置好的child的所有参数都传输进去.<br>group,handler,option,attrs等.</p><p>接下来看一下ServerBootstrapAcceptor类,这是ServerBootstrap的内部类.通过上面可以看到.这个Acceptor被添加到管道的最后一个位置.所以消息到这里通过前面一系列的处理,已经是一个Channel.这个时候就需要将Channel注册到childGroup中.<br>可以分为一下几步:    </p><ol><li>复写父类的channelRead()方法,监听连接事件</li><li>当有新连接到来的时候,调用channelRead()方法,获取新建立的channel.</li><li>为这个新建的channel配置参数,包括选项,pipeline中的处理器</li><li>将此Channel注册到childGroup中,监听事件.</li></ol><p>这个类不长,稍微看一看就能理解大概了.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerBootstrapAcceptor</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup childGroup;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler childHandler;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Runnable enableAutoReadTask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化,将child的参数都设置好,并且保存好</span></span><br><span class="line">        ServerBootstrapAcceptor(</span><br><span class="line">                <span class="keyword">final</span> Channel channel, EventLoopGroup childGroup, ChannelHandler childHandler,</span><br><span class="line">                Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions, Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs) &#123;</span><br><span class="line">            <span class="keyword">this</span>.childGroup = childGroup;</span><br><span class="line">            <span class="keyword">this</span>.childHandler = childHandler;</span><br><span class="line">            <span class="keyword">this</span>.childOptions = childOptions;</span><br><span class="line">            <span class="keyword">this</span>.childAttrs = childAttrs;</span><br><span class="line">            enableAutoReadTask = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="comment">// 这里设置自动读取</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    channel.config().setAutoRead(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 覆写Read()事件,在这个方法中,将新建立的连接添加到childGroup中.</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line">            <span class="comment">// 为新建的连接添加childHandler()处理器.</span></span><br><span class="line">            child.pipeline().addLast(childHandler);</span><br><span class="line">            setChannelOptions(child, childOptions, logger);</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class="line">                child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将此Channel注册到childGroup上.</span></span><br><span class="line">                childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="comment">//  添加回调函数,如果失败,则关闭.</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                            forceClose(child, future.cause());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                forceClose(child, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forceClose</span><span class="params">(Channel child, Throwable t)</span> </span>&#123;</span><br><span class="line">            child.unsafe().closeForcibly();</span><br><span class="line">            logger.warn(<span class="string">"Failed to register an accepted channel: &#123;&#125;"</span>, child, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelConfig config = ctx.channel().config();</span><br><span class="line">            <span class="keyword">if</span> (config.isAutoRead()) &#123;</span><br><span class="line">                config.setAutoRead(<span class="keyword">false</span>);</span><br><span class="line">                ctx.channel().eventLoop().schedule(enableAutoReadTask, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            ctx.fireExceptionCaught(cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>到这里初始化就基本完成了.初始化完成就应该到注册了.</p><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>上面初始化完成之后就要调用注册方法,也就是要将此ServerChannel注册到Selector上.在看一下initAndRegister方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span>, <span class="title">C</span>&gt;, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在init()初始化Channel之后有这么一段代码,可以看出来就是将channel注册到Selector上的.继续点进去之后会发现以下代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannel</span> <span class="keyword">extends</span> <span class="title">DefaultAttributeMap</span> <span class="keyword">implements</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (eventLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"eventLoop"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否已经注册过了</span></span><br><span class="line">            <span class="keyword">if</span> (isRegistered()) &#123;</span><br><span class="line">                promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">"registered to an event loop already"</span>));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</span><br><span class="line">                promise.setFailure(</span><br><span class="line">                        <span class="keyword">new</span> IllegalStateException(<span class="string">"incompatible event loop type: "</span> + eventLoop.getClass().getName()));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line">            <span class="comment">// 这里主要是看当前线程是否是EventLoop中Channel绑定的线程.如果是,直接调用,如果不是,则异步调用</span></span><br><span class="line">            <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">                register0(promise);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            register0(promise);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(</span><br><span class="line">                            <span class="string">"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;"</span>,</span><br><span class="line">                            AbstractChannel.<span class="keyword">this</span>, t);</span><br><span class="line">                    closeForcibly();</span><br><span class="line">                    closeFuture.setClosed();</span><br><span class="line">                    safeSetFailure(promise, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里就是真正的注册逻辑.首先判断eventLoop是否为空,在判断是否已经注册过了. 接着看这一句:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br></pre></td></tr></table></figure></p><p>这里就是将此Channel绑定到此EventLoop上.这个EventLoop也就是当初我们调用方法b.group(bossGroup, workerGroup)中的bossGroup中的一个eventLoop.在Netty中,一个EventLoop包含多个Channel.而每个Channel的事件都是由同一个EventLoop来执行的. 这里就是执行真正的绑定操作. 再向下走会执行register0()方法.来看一下register0()方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">                <span class="comment">// 真正的执行注册方法的地方</span></span><br><span class="line">                doRegister();</span><br><span class="line">                neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">                registered = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒并且传播handlerAdd</span></span><br><span class="line">                pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">                safeSetSuccess(promise);</span><br><span class="line">                <span class="comment">// 传播ChannelRegistered()方法</span></span><br><span class="line">                pipeline.fireChannelRegistered();</span><br><span class="line">                <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                        pipeline.fireChannelActive();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                        beginRead();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                closeForcibly();</span><br><span class="line">                closeFuture.setClosed();</span><br><span class="line">                safeSetFailure(promise, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>这里又做了几件事情.</p><ul><li>doRegister()就是调用jdk的register方法进行注册.并且把NioServerSocketChannel自己作为attachment添加进去.</li><li>调用pipeline.invokeHandlerAddedIfNeeded(); 也就是唤醒HandlerAdd()事件.就是普通复写的handlerAdded()事件将会被触发.</li><li>pipeline.fireChannelRegistered();传播事件,这里传播Registered()事件.<br>这里应该就是在刚刚注册好的时候判断一下是否有连接到达.如果有,并且是第一次连接,就传播此事件.</li></ul><p>再来看一下doRegister()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里就是真正执行注册的地方.</span></span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">                eventLoop().selectNow();</span><br><span class="line">                selected = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// We forced a select operation on the selector before but the SelectionKey is still cached</span></span><br><span class="line">                <span class="comment">// for whatever reason. JDK bug ?</span></span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面javaChannel()也就是java中的channel,第一个参数就是此eventLoop中的selector选择器.0代表不监听任何事件.再讲自己作为attachment传进去.当下一次获得事件的时候可以直接把此NioServerSocketChannel拿出来用,然后做一些事件传播.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invokeHandlerAddedIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> channel.eventLoop().inEventLoop();</span><br><span class="line">        <span class="comment">// 如果是第一次调用,肯定为true</span></span><br><span class="line">        <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">            firstRegistration = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// We are now registered to the EventLoop. It's time to call the callbacks for the ChannelHandlers,</span></span><br><span class="line">            <span class="comment">// that were added before the registration was done.</span></span><br><span class="line">            callHandlerAddedForAllHandlers();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看官方的注释,就是说在整个注册过程还没有全部完成之前应该先回调ChannelHandlers中的handlerAdd()方法.所以就是在这里回调我们的复写的handlerAdd()方法的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRegistered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext.invokeChannelRegistered(head);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在这里调用毁掉我们的Register方法.所以handlerAdd事件是发生在register事件之前的.</p><p>到这里整个注册过程应该就明了了. 在总结一下:</p><ol><li>将此ServerSocketChannel绑定到对应的eventLoop上</li><li>执行注册操作</li><li>调用jdk中的注册方法,将javaChannel注册到Selector上,并且将对应的NioServerSocketChannel作为attachment添加上去</li><li>回调handler中handlerAdd()方法和register()方法</li><li>注册完成.返回,继续执行绑定操作</li></ol><p>注意,这里注册完成之后,Channel并没有完成绑定操作,也就是说,注册在Selector上的Channel并没有绑定端口.</p><h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><p>在一系列的准备工作完成之后,就是真正执行绑定操作的时候了.到这里initAndRegister方法算是结束了. 在来看一下doBind()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span>, <span class="title">C</span>&gt;, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">        <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> regFuture;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">            ChannelPromise promise = channel.newPromise();</span><br><span class="line">            doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Registration future is almost always fulfilled already, but just in case it's not.</span></span><br><span class="line">            <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">            regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    Throwable cause = future.cause();</span><br><span class="line">                    <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span></span><br><span class="line">                        <span class="comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span></span><br><span class="line">                        promise.setFailure(cause);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Registration was successful, so set the correct executor to use.</span></span><br><span class="line">                        <span class="comment">// See https://github.com/netty/netty/issues/2586</span></span><br><span class="line">                        promise.registered();</span><br><span class="line"></span><br><span class="line">                        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到,在这里又有一个回调,因为在Netty中都是异步执行的,所以初始化和Register也都是异步执行的.所以这里会先判断是否已经初始化和注册完成.如果完成,直接调用这个doBind0()方法,如果没有完成,添加一个监听事件,在完成之后调用doBind0()方法.<br>在来看一下doBind0()方法都做了什么事情<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span>, <span class="title">C</span>&gt;, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里也是异步执行bind操作,是调用的channel的bind()方法的.这里的channel也就是传入的Channel的类型.</span></span><br><span class="line">        channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                    channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.setFailure(regFuture.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再向调用栈的深处走,这个bind()方法会调用AbstractChannel中的内部类AbstractUnsafe的bind()方法,也就是如下的方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractUnsafe</span> <span class="keyword">implements</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            assertEventLoop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;</span><br><span class="line">                localAddress <span class="keyword">instanceof</span> InetSocketAddress &amp;&amp;</span><br><span class="line">                !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;</span><br><span class="line">                !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123;</span><br><span class="line">                logger.warn(</span><br><span class="line">                        <span class="string">"A non-root user can't receive a broadcast packet if the socket "</span> +</span><br><span class="line">                        <span class="string">"is not bound to a wildcard address; binding to a non-wildcard "</span> +</span><br><span class="line">                        <span class="string">"address ("</span> + localAddress + <span class="string">") anyway as requested."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                doBind(localAddress);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                safeSetFailure(promise, t);</span><br><span class="line">                closeIfClosed();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">                invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        pipeline.fireChannelActive();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            safeSetSuccess(promise);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现这里会调用doBind()方法,这个doBind()方法就是我们bind()方法的真正实现了.也就是在我们为bootstrap配置的Channel的bind()方法.这里调用的是NioServerSocketChannel的doBind()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServerSocketChannel</span> <span class="keyword">extends</span> <span class="title">AbstractNioMessageChannel</span></span></span><br><span class="line"><span class="class">                             <span class="keyword">implements</span> <span class="title">io</span>.<span class="title">netty</span>.<span class="title">channel</span>.<span class="title">socket</span>.<span class="title">ServerSocketChannel</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">            javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到,这里就是将javaChannel()方法绑定到本地的某个端口上.这里就是调用的jdk的bind()方法来绑定端口和地址的.<br>然后再Unsafe的bind()方法的最后,这里是要传播Active()事件. 不知道大家发现没有,在刚才注册的阶段,并没有channel并没有注册感兴趣的事件,而是没有感兴趣的事件.下面在看到底在哪里注册感兴趣的事件.就是在这个fireChannelActive中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannel</span> <span class="keyword">extends</span> <span class="title">DefaultAttributeMap</span> <span class="keyword">implements</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再向下走,会调用pipeline中的头结点的channelActive()方法,关于这个头结点可以理解为pipeline中的出入口.所有从出入管道的数据都要走这里.这里也应该是传播读事件的开端.具体的可以看另一篇文章. 这里要传播active方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelPipeline</span> <span class="keyword">implements</span> <span class="title">ChannelPipeline</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadContext</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerContext</span> </span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span>, <span class="title">ChannelInboundHandler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">            ctx.fireChannelActive();</span><br><span class="line"></span><br><span class="line">            readIfIsAutoRead();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里,有两件事情要做.</p><ol><li>传播Active事件</li><li>注册accept事件.</li></ol><p>传播Active事件都不说了,和上面传播handlerAdd事件一样.重点说一下注册accept事件.从readIfAutoRead()方法开始<br>最终会调用到AbstractNioChannel的doBeginRead()方法上.调用堆栈如下:<br><img src="/2019/05/15/Netty服务端启动分析/调用堆栈.png" alt><br>下面看一下doBeginRead()方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractNioChannel</span> <span class="keyword">extends</span> <span class="title">AbstractChannel</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">        <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">        <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        readPending = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">        <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">            selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里调用doBeginRead()方法,我们刚开始的时候说过,将Channel注册到Selector上的时候,并没有感兴趣的时间.因此这里的interestOps应该为0,但是我们在创建NioServerSocketChannel()的时候,Netty中的Channel是有传入过要注册事件的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里想就向这个AbstractNioChannel的readInterestOp赋值,注意,这里的readInterestOp是感兴趣的事件,并不是读事件.也就是感兴趣事件为接受连接.所以上面的代码就容易理解了.就是将新建的NioServerSocketChannel的刚兴趣的事件真正绑定到javaChannel上去.到这里.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>服务端启动其实就类似与平时我们编写NIO的方式,不过就是为我们做好了很多封装.我们只需要配置好参数,并且写好业务逻辑就好了,不需要我们去管理连接的Channel.极大的简化了我们的编程. 这里在做一下启动过程的大致流程的总结.</p><h2 id="配置属性"><a href="#配置属性" class="headerlink" title="配置属性"></a>配置属性</h2><ol><li>首先有两个EventLoopGroup,一个为parent,用来监听连接事件,一个为child,用来监听已经建立好的Channel的事件.   </li><li>设置Channel的类型,是NIO还是OIO或者是AIO</li><li>设置parentChannel的选项参数,</li><li>设置childHandler.为建立好的连接添加处理器</li><li>设置childOption选项</li></ol><h2 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h2><ol><li>调用bind()方法启动服务器.</li><li>新建一个Channel(这个时候也会初始化此Channel的Pipeline)</li><li>初始化Channel</li><li>将Channel注册上去,并且将NioSelectorChannel作为attachment添加上去</li><li>绑定端口,为channel添加感兴趣事件.</li></ol><p>到这里就算完成了.整个Netty服务端的启动过程就大致明了了.</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Netty </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty基本使用</title>
      <link href="/2019/05/15/Netty%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/05/15/Netty%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><p>Netty就是封装了JDK的NIO网络库。用官网的话说是，Netty是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能服务器和客户端。</p><h2 id="为什么使用Netty而不用jdk"><a href="#为什么使用Netty而不用jdk" class="headerlink" title="为什么使用Netty而不用jdk"></a>为什么使用Netty而不用jdk</h2><ol><li>JDK中使用的话需要对NIO编程有足够的了解，编程也比较复杂，不小心就会出现很多bug</li><li>Netty底层的I/O模型可以随意更换，而不需要改变太多的代码，只需要改一些参数就可以了。</li><li>Netty解决了jdk的一些bug，比如select空轮询导致cpu100</li><li>Netty自带拆包解包，异常检测机制，可以让用户只关心业务逻辑</li><li>自带很多协议栈，比如http协议，google的protobuf协议</li></ol><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>首先如果想要使用Netty，建议首先要了解一下NIO网络编程，可以不熟悉，但是一定要了解。对理解起来会有帮助.<br>首先看一下服务端怎么实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先定义两个事件循环组,一个是用来接受新建连接,一个用来处理已经建立好的连接</span></span><br><span class="line"><span class="keyword">int</span> port = <span class="number">9999</span>;</span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 是一个启动 Nio服务器的一个辅助类,可以在这个服务中直接使用Channel</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ServerBootstrap boot = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        <span class="comment">// 将这两个 事件循环组加进去</span></span><br><span class="line">        boot = boot.group(bossGroup,workerGroup)</span><br><span class="line">                <span class="comment">// 设置为NIO模式</span></span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">// 设置事件处理程序</span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 这里添加的类是真正处理业务逻辑的类</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> DiscardServerHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 指定实现的通道实现的配置参数,这里是TCP/IP服务器</span></span><br><span class="line"><span class="comment">                 * 所以允许设置Socket的参数选项比如tcpNodeloy,keepAlive</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * SO_BACKLOG 是一个数量设置</span></span><br><span class="line"><span class="comment">                 * 在linux内核中,有两个队列,一个是正在连接队列,一个是已经连接队列</span></span><br><span class="line"><span class="comment">                 * SO_BACKLOG 是设置这个缓冲区大小的,也就是这两个队列的大小</span></span><br><span class="line"><span class="comment">                 * 设置的值为两个队列最大能接受的值,当两个队列的大小超过这个值,新来的连接将会被抛弃</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>)<span class="comment">// 设置tcp缓冲区大小</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * option()是提供个NioServerSocketChannel用来接受进来的连接</span></span><br><span class="line"><span class="comment">                 * childOption()是提供给由父管道ServerChannel接受到的连接.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE,<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//  调用bind()方法启动服务器,sync()就是异步调用.变为后台线程.</span></span><br><span class="line">        ChannelFuture f = boot.bind(port).sync();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里一直会等待,知道socket关闭</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// Thread.sleep(Integer.MAX_VALUE)</span></span><br><span class="line">        <span class="comment">// 相当于阻塞进程.</span></span><br><span class="line">        f.channel().closeFuture().sync();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 关闭</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只需要这些代码就可以建立好一个服务器,当然了,还需要写一个实现业务逻辑,就是说要写一个Handler,这里我们实现一个最简单的网络程序,也就是接收到数据什么都不做,只是简单的打印出来.下面看Handler的实现.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在有数据可以读取的时候调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteBuf in = (ByteBuf)msg;</span><br><span class="line">            System.out.println(in.toString(CharsetUtil.UTF_8));</span><br><span class="line">           </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发生异常时候调用,关闭连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当出现Throwable对象的时候,当netty抛异常时候调用此方法,可以在其中设置异常逻辑,比如发送错误码</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面可以很清除的看到覆盖了父类的方法.channelRead(). 上面说过Netty是事件驱动的框架.这里就体现出来了.当socket可读的时候就会调用此方法,这里不执行任何逻辑,只是简单的丢弃.所以说它是异步的事件驱动的.</p><p>之后就可以运行服务器.然后用telnet访问本地的9999端口就可以发送消息.</p><p>到这里一个简单的服务器就搭建好了.  接下来再详细讲解一下其中各个组件的功能与作用.</p><h2 id="BootStrap"><a href="#BootStrap" class="headerlink" title="BootStrap"></a>BootStrap</h2><p>这是一个引导类,通过设置BootStrap类的开始,该类提供了一个用于应用程序网络层的配置容器</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>底层网络传输api必须提供给应用I/O操作接口,Netty自己对JDK的channel进行了进一步的封装,使得网络编程有更好的可扩展性. Channel 定义了与 socket 丰富交互的操作集：bind, close, config, connect, isActive, isOpen, isWritable, read, write 等等。</p><h2 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h2><p>ChannelHandler支持很多种协议,并且提供用于进行数据处理的地方.ChannelHandler由特定的一些事件触发,触发之后会调用不同的方法,用户只需要自己实现ChannelHandler的一些方法就好了.当然实际编程中一般应该实现ChannelInboundHandlerAdapter和ChannelOutboundHandlerAdapter类,这两个类已经默认实现了ChannelHandler的方法.用户只需要在复写自己感兴趣的事件,然后进行处理就可以了.</p><h2 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h2><p>ChannelPipeline提供了一个容器ChannelHandler链,并提供了一个API用于管理沿着这条链进行的入站和出站的事件流动.每一个Channel都有自己的ChannelPipeline.是在创建Channel的时候自动创建ChannelPipeline的.  ChannelHandler 是如何安装在 ChannelPipeline？ 主要是实现了ChannelHandler 的抽象 ChannelInitializer。ChannelInitializer子类 通过 ServerBootstrap 进行注册。当它的方法 initChannel() 被调用时，这个对象将安装自定义的 ChannelHandler 集到 pipeline。当这个操作完成时，ChannelInitializer 子类则 从 ChannelPipeline 自动删除自身。</p><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>EventLoop用于处理Channel的I/O操作,一个单一的EventLoop通常会处理多个Channel事件.</p><h2 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h2><p>因为Netty中所有的事件都是异步的,因为一个操作无法立即返回,这个时候就有了ChannelFuture能够在之后确定它的结果.ChannelFuture的addListener()方法可以添加注册事件,当操作完成之后会被通知.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面是对Netty的一个最基本的认识.总之Netty是一个强大的基于事件驱动的一个网络编程框架,使用它能够很好的建立一个稳定的网络应用程序.</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Netty </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-RMI</title>
      <link href="/2019/05/08/java-RMI/"/>
      <url>/2019/05/08/java-RMI/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>RMI:远程方法调用(Remote Method Invocation),是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口.它使得客户机上的运行的程序能够调用远程服务器上的对象的对象.此远程调用特性就是为了能够在网络环境中分布操作.RMI就是简化了远程调用.  </p><p>RPC:远程过程调用,是在分布式中常用到的一个协议,此协议就是能够让调用远程对象如同调用本地对象一样,RMI就是其实现方式的一种,当然了,还有很多中实现方式,比如说rest方式等等.现在主要说一下RMI方式;</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h2><p><img src="/2019/05/08/java-RMI/RMI调用.jpg" alt>  </p><p>RMI主要由三个部分组成:</p><ul><li>registry(JDK提供的一个可独立运行的程序) </li><li>server程序,对外提供远程调用的服务对象</li><li>client 调用server提供的服务</li></ul><p>首先，先启动registry服务，启动时可以指定服务监听的端口，也可以使用默认的端口（1099）</p><p>其次，server端在本地先实例化一个提供服务的实现类，然后通过RMI提供的Naming/Context/Registry（下面实例用的Registry）等类的bind或rebind方法将刚才实例化好的实现类注册到registry上并对外暴露一个名称。</p><p><img src="/2019/05/08/java-RMI/stuc.png" alt></p><p>最后，client端通过本地的接口和一个已知的名称（即registry暴露出的名称）再使用RMI提供的Naming/Context/Registry等类的lookup方法从RMIService那拿到实现类,其实是RMI系统生成的stub存根代理。这样虽然本地没有这个类的实现类，但所有的方法都在接口里了，便可以实现远程调用对象的方法了.</p><p><img src="/2019/05/08/java-RMI/stub.jpg" alt><br>通信过程大致是这样,server端提供服务后会有一个skeleton骨干网,client调用者调用lookup方法会返回一个存根,通过此存根与server通信,调用远程的方法. 方法经过存根(stub),远程调用层,再到传输层,最后在到skeleton,通过skeleton调用实例方法,之后在将结果按照原路返回.<br>而这个stub和skeleton代理都是由RMI系统动态生成的.服务端只需要继承UnicastRemoteObject接口就可以了.这些底层细节是不需要我们去关心的.这就是它的强大之处.</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h2><p>首先必须有一个暴露的接口,这个接口在server和client中都得有,因为需要这个接口去调用方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.spj.rmidemo.bean.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserManage</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getUserName</span><span class="params">()</span><span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">getUser</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其次得server实现这个接口的具体方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里需要继承UnicastRemoteObject类,来允许jvm创建存根和代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserManageImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">UserManage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">UserManageImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"spj"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span><span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"spj"</span>,<span class="string">"123"</span>,<span class="number">21</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里就可以使用一个方法来暴露这个服务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所要暴露的对象</span></span><br><span class="line">        UserManage userManage = <span class="keyword">new</span> UserManageImpl();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个本地的注册中心,绑定端口2002</span></span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">2002</span>);</span><br><span class="line">        <span class="comment">// 这里能够使用Naming.rebind绑定对象或者使用registry.bind()暴露对象</span></span><br><span class="line">        <span class="comment">//Naming.rebind("rmi://127.0.0.1:2002/UserManageService",userManage);</span></span><br><span class="line">        registry.bind(<span class="string">"userManage"</span>,userManage);</span><br><span class="line">        System.out.println(<span class="string">"server is ready!"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>服务端的程序就写好了,而客户端可以没有这个实现类,也就是没有接口的实现类,就可以调用方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(<span class="number">2002</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// lookup方法参数为服务器绑定是设置的访问名称.</span></span><br><span class="line">            UserManage userManage = (UserManage)registry.lookup(<span class="string">"userManage"</span>);</span><br><span class="line">            <span class="comment">// 这里可以向调用本地方法一样调用远程方法.</span></span><br><span class="line">            System.out.println(userManage.getUser());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">User&#123;name=<span class="string">'spj'</span>, psss=<span class="string">'123'</span>, age=<span class="number">21</span>&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><p><a href="https://blog.csdn.net/qq_28081453/article/details/83279066" target="_blank" rel="noopener">https://blog.csdn.net/qq_28081453/article/details/83279066</a><br><a href="https://blog.csdn.net/xinghun_4/article/details/45787549" target="_blank" rel="noopener">https://blog.csdn.net/xinghun_4/article/details/45787549</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo踩坑教训</title>
      <link href="/2019/05/04/dubbo%E8%B8%A9%E5%9D%91%E6%95%99%E8%AE%AD/"/>
      <url>/2019/05/04/dubbo%E8%B8%A9%E5%9D%91%E6%95%99%E8%AE%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章主要总结一下自己踩过的dubbo的坑,因为不管是在配置的时候或者说调用的时候都会出现很多问题,碰到过很多坑,特此总结一下.持续更新.<br>说明一下,这里使用的dubbo是apache旗下的,不是alibaba旗下的.</p><h2 id="dubbo-配置消费方显示端口已经占用"><a href="#dubbo-配置消费方显示端口已经占用" class="headerlink" title="dubbo 配置消费方显示端口已经占用"></a><strong>dubbo 配置消费方显示端口已经占用</strong></h2><p>错误如下 :<br><img src="/2019/05/04/dubbo踩坑教训/2019-05-04&#32;18-55-29屏幕截图.png" alt><br>这个原因是因为在默认配置的情况下使用的qos端口号都是22222.但是在消费方想要用这个端口的时候,服务提供方已经占用了,这个时候就需要去配置一下qos来实现部署的.</p><p>qos就是Dubbo的在线运维命令. 可以对服务进行动态的配置,控制以及查询.</p><p>具体配置如下:     </p><h3 id="使用dubbo-properties文件进行配置"><a href="#使用dubbo-properties文件进行配置" class="headerlink" title="使用dubbo.properties文件进行配置"></a>使用dubbo.properties文件进行配置</h3><p>加上一下属性就好了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dubbo.application.qos.enable=<span class="keyword">true</span></span><br><span class="line">dubbo.application.qos.port=<span class="number">33333</span></span><br><span class="line">dubbo.application.qos.accept.foreign.ip=<span class="keyword">false</span></span><br></pre></td></tr></table></figure></p><h3 id="使用XML进行配置"><a href="#使用XML进行配置" class="headerlink" title="使用XML进行配置"></a>使用XML进行配置</h3><p>将其中一方的qos端口设置为没有被占用的任何一个就可以了.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-provider"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"qos.enable"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"qos.accept.foreign.ip"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"qos.port"</span> <span class="attr">value</span>=<span class="string">"33333"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="使用springboot自动装配方式"><a href="#使用springboot自动装配方式" class="headerlink" title="使用springboot自动装配方式"></a>使用springboot自动装配方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dubbo.application.qosEnable=<span class="keyword">true</span></span><br><span class="line">dubbo.application.qosPort=<span class="number">33333</span></span><br><span class="line">dubbo.application.qosAcceptForeignIp=<span class="keyword">false</span></span><br></pre></td></tr></table></figure><h2 id="com-alibaba-com-caucho-hessian-io-HessianProtocolException-无法反序列化问题"><a href="#com-alibaba-com-caucho-hessian-io-HessianProtocolException-无法反序列化问题" class="headerlink" title="com.alibaba.com.caucho.hessian.io.HessianProtocolException 无法反序列化问题"></a><strong>com.alibaba.com.caucho.hessian.io.HessianProtocolException 无法反序列化问题</strong></h2><p>这个原因也有,这原因主要是因为Hessian的序列化的方式的问题.<br>dubbo是采用Hessian（比jdk自带反序列化高效）进行反序列化的，该反序列化创建对象时，会取参数最少的构造方法来创建对象，构造方法参数设置默认值，基本类型设置为相应基本类型的默认值，不是基本类型设置为null.所以这里就会出现null对象,导致无法被序列化.<br>只要在序列化对象上添加一个无参构造方法就好了.当然如果没有自定义的构造方法,会有默认的构造方法,所以也不会出错.</p><h2 id="dubbo-显示两个重复的配置"><a href="#dubbo-显示两个重复的配置" class="headerlink" title="dubbo 显示两个重复的配置"></a><strong>dubbo 显示两个重复的配置</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Duplicate application configs: &lt;dubbo:application valid=<span class="string">"true"</span> name=<span class="string">"demo-provider"</span> prefix=<span class="string">"dubbo.application"</span> id=<span class="string">"demo-provider"</span> /&gt; and &lt;dubbo:application owner=<span class="string">"debug"</span> valid=<span class="string">"true"</span> organization=<span class="string">"dubbox"</span> name=<span class="string">"dubboOne-consume"</span> prefix=<span class="string">"dubbo.application"</span> id=<span class="string">"dubboOne-consume"</span> /&gt;</span><br></pre></td></tr></table></figure><p>这个是因为一个应用要求只有一个application配置,这个问题我觉得可能是出现在自己不是很了解的情况下,一个应用配置了两个application. 向我刚开始一样:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://dubbo.apache.org/schema/dubbo</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"$&#123;dubbo.registry.address&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"rest"</span> <span class="attr">threads</span>=<span class="string">"500"</span> <span class="attr">contextpath</span>=<span class="string">"v1"</span> <span class="attr">server</span>=<span class="string">"tomcat"</span> <span class="attr">accepts</span>=<span class="string">"500"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--看这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-provider"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"dubboOne-consume"</span> <span class="attr">owner</span>=<span class="string">"debug"</span> <span class="attr">organization</span>=<span class="string">"dubbox"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这里配置了两个application.导致出错了.只需要删掉其中一个就好了.这个时候就又有人问了.这么配置的主要原因就是为了一个应用即充当提供方有当消费方.   这里就需要另外一个配置了.<br>参考官方文档:  提供方提供配置的时候.需要用到 dubbo:service 来进行接口暴露.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>消费方使用服务的时候需要用到reference配置来使用:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.DemoService"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>所以当一个应用即充当消费方又是服务提供方不需要配置两个application.只需要配置好要引用的rpc服务和自己所需要暴露的接口就好了.</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo配置过程</title>
      <link href="/2019/05/03/dubbo%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/05/03/dubbo%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="dubbo"><a href="#dubbo" class="headerlink" title="dubbo"></a>dubbo</h1><h2 id="dubbo背景"><a href="#dubbo背景" class="headerlink" title="dubbo背景"></a>dubbo背景</h2><p>在如今设备配置已经到达极限的时候,则需要进行分布式进行处理,将一些应用功能分开管理,但是又必须得互相有沟通,可以通过简单的接口暴露和RPC引用远程服务,通过配置URL地址进行调用,通过F5等硬件进行负载均衡.但是当应用服务规模再进一步扩大的情况下,如果只是简单的通过RMI等方法暴露接口的话,服务的URL配置和管理将变得特别的困难,这个时候就需要实现一个注册中心,动态地注册和发现服务,使得服务的位置透明,并通过在消费方获取服务提供地址列表,实现软负载均衡<br>但是如果在进一步发展,服务器的依赖关系变得错综复杂,甚至分不清那个服务在那个服务之前启动,这个时候需要自动画出应用间的依赖图,来帮助架构师理清系统关系.<br>但是当应用规模扩大的时候还必须要确定多少台机器合适,也必须要有一个服务来进行调用统计,响应时间计算,通过这些来判断需要多少机器,来进行管理.</p><h2 id="dubbo架构"><a href="#dubbo架构" class="headerlink" title="dubbo架构"></a>dubbo架构</h2><p><img src="/2019/05/03/dubbo配置过程/dubbo-architecture.jpg" alt></p><p>这就是dubbo基本的架构图.<br>大致流程:</p><ol><li>服务提供方应该向注册中心注册自己要发布的服务,</li><li>其次消费方去注册中心订阅自己所需要的服务</li><li>当注册中心发现有服务的话会通知消费方服务提供放暴露的接口地址,如果一个服务有多个提供者,则会返回一个服务接口列表,由消费方调用</li><li>消费方依靠这个地址列表去找到对应的服务提供者.这里如果有多台机器在代码中会可以实现软负载均衡,寻找合适的服务提供者去请求.</li><li>服务方和消费方也都会在内存中存储调用次数和时间,定时向监控中心发送数据.</li></ol><h2 id="API方式"><a href="#API方式" class="headerlink" title="API方式"></a><strong>API方式</strong></h2><p>API方式也是根据上述的流程.<br>首先必须得有一个注册中心: 一般来说注册中心使用zookeeper,zookeeper启动过程可以去网上搜索.挺简单的.<br>接着应该有一个服务提供者提供服务.<br>使用Dubbo的服务必须有几个参数得指明.一个是application,也就是提供服务的应用.一个是注册中心的配置,因为你要向注册中心注册一个服务.这也是必须的.来看一下提供方代码:   </p><p>首先应该有一个接口,也就是提供的服务的接口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorImpl</span> <span class="keyword">implements</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着就可以提供服务了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 这个也就是提供服务的类,当有消费方请求的时候使用这个类来进行计算并且返回.</span></span><br><span class="line">        Calculator  calculator = <span class="keyword">new</span> CalculatorImpl();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要有一个应用来发布这个服务.服务必须得有名字</span></span><br><span class="line">        ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(<span class="string">"add"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接注册服务配置</span></span><br><span class="line">        RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">        <span class="comment">// 配置本地的zookeeper注册中心.还可以使用广播的方式,只需要将zookeeper改为broadcast即可</span></span><br><span class="line">        registryConfig.setAddress(<span class="string">"zookeeper://192.168.1.202:2181"</span>);</span><br><span class="line">        registryConfig.setUsername(<span class="string">"superj88"</span>);</span><br><span class="line">        registryConfig.setPassword(<span class="string">"superj88"</span>);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 服务提供协议配置 为服务提供协议配置.这里设置为dubbo,当然了,也可以是rest也就是http协议.</span></span><br><span class="line">        <span class="comment">// RPC只是一个框架,具体实现怎么都可以,当然了,必须得经过网络传输</span></span><br><span class="line">        ProtocolConfig protocol = <span class="keyword">new</span> ProtocolConfig();</span><br><span class="line">        protocol.setName(<span class="string">"dubbo"</span>);</span><br><span class="line">        <span class="comment">// 设置监听的端口</span></span><br><span class="line">        protocol.setPort(<span class="number">12345</span>);</span><br><span class="line">        protocol.setThreads(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务提供者暴露服务配置</span></span><br><span class="line">        ServiceConfig service = <span class="keyword">new</span> ServiceConfig();</span><br><span class="line">        <span class="comment">// 设置服务暴露的应用</span></span><br><span class="line">        service.setApplication(applicationConfig);</span><br><span class="line">        service.setRegistry(registryConfig);<span class="comment">// 多个注册中心用setRegistries()</span></span><br><span class="line">        <span class="comment">// 设置协议</span></span><br><span class="line">        service.setProtocol(protocol);</span><br><span class="line">        <span class="comment">// 设置接口,通过这个接口调用此服务</span></span><br><span class="line">        service.setInterface(Calculator.class);</span><br><span class="line">        </span><br><span class="line">        service.setRef(calculator);</span><br><span class="line">        service.setVersion(<span class="string">"1.0.0"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里执行暴露服务操作,具体就是向注册中心注册自己的服务</span></span><br><span class="line">        service.export();</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>消费方代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前应用配置</span></span><br><span class="line">        ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(<span class="string">"consumer"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接注册中心配置</span></span><br><span class="line">        RegistryConfig registry = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">        registry.setAddress(<span class="string">"zookeeper://localhost:2181"</span>);</span><br><span class="line">        registry.setUsername(<span class="string">"superj88"</span>);</span><br><span class="line">        registry.setPassword(<span class="string">"superj88"</span>);</span><br><span class="line">        applicationConfig.setRegistry(registry);</span><br><span class="line">        <span class="comment">// 引用远程服务</span></span><br><span class="line">        ReferenceConfig&lt;Calculator&gt; reference = <span class="keyword">new</span> ReferenceConfig&lt;&gt;(); <span class="comment">// 此实例很重，封装了与注册中心的连接以及与提供者的连接，请自行缓存，否则可能造成内存和连接泄漏</span></span><br><span class="line">        reference.setApplication(applicationConfig);</span><br><span class="line">        reference.setRegistry(registry); <span class="comment">// 多个注册中心可以用setRegistries()</span></span><br><span class="line">        reference.setInterface(Calculator.class);</span><br><span class="line">        reference.setVersion(<span class="string">"1.0.0"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里消费方还必须得有要调用服务的接口.</span></span><br><span class="line">        Calculator calculator = reference.get();</span><br><span class="line">        System.out.println(calculator.add(<span class="number">100</span>,<span class="number">2000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Spring集成-xml方式"><a href="#Spring集成-xml方式" class="headerlink" title="Spring集成 xml方式"></a><strong>Spring集成 xml方式</strong></h2><p>provider.xml配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- dubbo 应用名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-provider"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注册中心地址, 发布出来的服务要注册到这个地址上 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用的协议,这里是dubbo,绑定20890端口,  还有rest就是基于http协议的调用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20890"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定发布的哪一个的服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">class</span>=<span class="string">"org.apache.dubbo.samples.basic.impl.DemoServiceImpl"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个是发布服务锁制定的接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.samples.basic.api.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>consumer.xml配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 消费者的应用名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-consumer"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注册中心 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">group</span>=<span class="string">"aaa"</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 表示自己要使用那个服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">check</span>=<span class="string">"false"</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.samples.basic.api.DemoService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>还有很多配置,详情请看dubbo官网<a href="http://dubbo.apache.org/zh-cn/docs/user/configuration/xml.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/configuration/xml.html</a>.   </p><h2 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置:"></a><strong>基于注解的配置:</strong></h2><h3 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h3><p>首先也必须要配置应用共享的一些属性,比如应用名称,注册地址,使用的协议和绑定的端口等.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dubbo.application.name=annotation-provider</span><br><span class="line">dubbo.registry.address=zookeeper:<span class="comment">//127.0.0.1:2181</span></span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">dubbo.protocol.port=<span class="number">20880</span></span><br></pre></td></tr></table></figure></p><p>指定包的扫描路径:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDubbo</span>(scanBasePackages = <span class="string">"org.apache.dubbo.samples.simple.annotation.impl"</span>)</span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/spring/dubbo-provider.properties"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderConfiguration</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用Service注解暴露服务"><a href="#使用Service注解暴露服务" class="headerlink" title="使用Service注解暴露服务"></a>使用Service注解暴露服务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(protocol = &#123;<span class="string">"dubbo"</span>,<span class="string">"rest"</span>&#125;,version = <span class="string">"1.0"</span>, timeout=<span class="number">3000</span>)</span><br><span class="line"><span class="comment">// 这里的@Path路径中,如果上面协议中指定了rest服务,必须要指明路径.不然会报错.</span></span><br><span class="line"><span class="meta">@Path</span>(<span class="string">"moocOne"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboTestService</span> <span class="keyword">implements</span> <span class="title">IDubboTestService</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h3><p>配置应用基本属性:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dubbo.application.name=annotation-consumer</span><br><span class="line">dubbo.registry.address=zookeeper:<span class="comment">//127.0.0.1:2181</span></span><br><span class="line">dubbo.consumer.timeout=<span class="number">3000</span></span><br></pre></td></tr></table></figure></p><p>消费方使用服务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"annotationAction"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过此注解引用服务</span></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> AnnotationService annotationService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> annotationService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>指定spring扫描路径<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableDubbo</span>(scanBasePackages = <span class="string">"org.apache.dubbo.samples.simple.annotation.action"</span>)</span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/spring/dubbo-consumer.properties"</span>)</span><br><span class="line"><span class="meta">@ComponentScan</span>(value = &#123;<span class="string">"org.apache.dubbo.samples.simple.annotation.action"</span>&#125;)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-SPI机制</title>
      <link href="/2019/05/02/Java-SPI%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/05/02/Java-SPI%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="SPI简介"><a href="#SPI简介" class="headerlink" title="SPI简介"></a>SPI简介</h2><p>SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件.<br>SPI其实就是 基于接口的编程 + 策略模式 + 配置文件 组合实现的动态加载机制.<br>Java SPI就是提供一个机制,通过为某个接口寻找服务的一个实现机制.通过读取你在配置文件中配置的参数,来为你提供相应的服务.核心思想就是解耦.将程序的装配权移动到程序之外,也就是配置文件中. </p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>就是调用这可以根据实际需要,启用,扩展和替换一些实现的策略.<br>举个例子: </p><ul><li>数据库驱动加载接口实现类的加载.jdbc通过配置不同,实现不同的数据库驱动的加载</li><li>日志门面接口实现类加载 .SLF4J加载不同提供商的日志实现类</li></ul><h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍:"></a>使用介绍:</h2><p>首先定义一个接口与它的多个实现类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spj.spi;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RobotBoy</span> <span class="keyword">implements</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello,I am a boy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RobotGirl</span> <span class="keyword">implements</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello,I am a girl"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~ </span><br><span class="line">其次在 src/main/resources 目录下建立 META-INF/services 目录.新建一个以此接口命名的文件,我这里是com.spj.spi.Robot,然后在想文件中写入它的两个实现类.实现类必须要写类的全限定名称. 借着来用spi测试一下:</span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaSpiTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServiceLoader&lt;Robot&gt; serviceLoader = ServiceLoader.load(Robot.class);</span><br><span class="line">        Iterator&lt;Robot&gt; matchter = serviceLoader.iterator();</span><br><span class="line">        <span class="keyword">while</span> (matchter.hasNext())&#123;</span><br><span class="line">            Robot robot = matchter.next();</span><br><span class="line">            robot.sayHello();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台输出: </span><br><span class="line">hello,I am a boy</span><br><span class="line">hello,I am a girl</span><br></pre></td></tr></table></figure></p><p>这里会将两个实现类加载进来. 通过ServiceLoader来进行接口服务的发现与加载. </p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现:"></a>具体实现:</h2><p>首先看ServiceLoader的具体属性:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoader</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 看到这个前缀表明了你必须得将配置文件放在这个目录下</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"META-INF/services/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个就是上面要寻找的服务的接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来加载类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问控制器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来缓存加载成功的类</span></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="keyword">private</span> LazyIterator lookupIterator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体加载过程:<br>在查找下一个实现类的时候,首先会看缓存providers中是否有,如果没有,则进行加载配置文件中的类.实现如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    String cn = nextName;</span><br><span class="line">    nextName = <span class="keyword">null</span>;</span><br><span class="line">    Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过名称加载类</span></span><br><span class="line">        c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取到之后,将此类缓存到providers中.</span></span><br><span class="line">        S p = service.cast(c.newInstance());</span><br><span class="line">        providers.put(cn, p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated"</span>,</span><br><span class="line">             x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断还有没有下一个.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String fullName = PREFIX + service.getName();</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                configs = loader.getResources(fullName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            fail(service, <span class="string">"Error locating configuration files"</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pending = parse(service, configs.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">    nextName = pending.next();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java SPI机制主要是为了解耦,通过将具体实现与应用程序分开,方便管理,在需要配置不同的实现的情况下,不需要进行代码改动,而只需要改变配置就可以了.<br>当然,Java SPI机制也有一些缺点,虽然其中确实有延迟加载,但是如果想要获得某个实现类的话就只能遍历获取,将每个实现类多遍历一遍,就造成了浪费.</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-NIO之Buffer</title>
      <link href="/2019/05/01/java-NIO%E4%B9%8BBuffer/"/>
      <url>/2019/05/01/java-NIO%E4%B9%8BBuffer/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Java NIO类在jdk中有了源生支持,实现了一套自己的NIO框架,当然了底层依然是系统调用.但是在NIO中必不可少的就是缓冲区,随后的Channel和Selector随后在介绍.</p><h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><p><img src="/2019/05/01/java-NIO之Buffer/Buffer.png" alt><br>这就是Buffer的大致继承体系,很多都没有罗列出来,因为主要讲解的是ByteBuffer.这里大概说一下,Buffer是一个抽象类,包括一个Buffer的最基本属性,比如,容量,位置,上界,标记.子类通过调用父类构造方法来实例化这几个参数,子类也都有各自的容量实现.比如ByteBuffer类用字节数组当缓冲区.旗下又有两个自己的实现类.<br>在jdk中,buffer有很多中实现,例如intBuffer,LongBuffer,ByteBuffer等,但是在NIO中实现的大多使用的是ByteBuffer,重点来看一下ByteBuffer.</p><h1 id="Buffer属性以及相关操作"><a href="#Buffer属性以及相关操作" class="headerlink" title="Buffer属性以及相关操作."></a>Buffer属性以及相关操作.</h1><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>capacity 容量</td><td>Buffer所能够存放的最大容量</td></tr><tr><td>position 位置</td><td>下一个被读或写的位置</td></tr><tr><td>limit 上界</td><td>可供读写的最大位置,用于限制position position &lt; limit</td></tr><tr><td>mark 标记</td><td>标记位置,用于记录某次读写的位置,可以通过reset()方法回到这里</td></tr></tbody></table><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化:"></a>初始化:</h2><p>ByteBuffer是一个抽象类,它有两个实现类,分别是上面图中显示的HeapByteBuffer和DirectByteBuffer.而且这两个类都不能被外部访问,都是包级的.而是应该通过allocate、allocateDirect 和 wrap 等方法初始化. 先看一下allocate方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity);</span><br><span class="line">&#125;</span><br><span class="line"> HeapByteBuffer(<span class="keyword">int</span> cap, <span class="keyword">int</span> lim) &#123;            <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, lim, cap, <span class="keyword">new</span> <span class="keyword">byte</span>[cap], <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 这里又调用父类构造方法,也就是ByteBuffer的构造方法</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">ByteBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap,  </span><br><span class="line">                 <span class="keyword">byte</span>[] hb, <span class="keyword">int</span> offset)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在调用顶级父类Buffer的构造方法</span></span><br><span class="line">        <span class="keyword">super</span>(mark, pos, lim, cap); </span><br><span class="line">        <span class="keyword">this</span>.hb = hb;</span><br><span class="line">        <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在来看一下Buffer的构造方法</span><br><span class="line">Buffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap) &#123;       <span class="comment">// package-private</span></span><br><span class="line">        <span class="keyword">if</span> (cap &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative capacity: "</span> + cap);</span><br><span class="line">        <span class="keyword">this</span>.capacity = cap;</span><br><span class="line">        limit(lim);</span><br><span class="line">        position(pos);</span><br><span class="line">        <span class="keyword">if</span> (mark &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mark &gt; pos)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"mark &gt; position: ("</span></span><br><span class="line">                                                   + mark + <span class="string">" &gt; "</span> + pos + <span class="string">")"</span>);</span><br><span class="line">            <span class="keyword">this</span>.mark = mark;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>通过创建一个HeapByteBuffer()来构造一个ByteBuffer对象,类如其名,这是一个堆上的缓冲区.而DirectByteBuffer是一个堆外的缓冲区,在堆外分配的.这里就不细说了.当然了,warp()和allocateDirect()也是一样的道理.<br>初始化完成后,mark=1,初始position位置为0,也就是从0开始,limit就等于容量大小</p><h2 id="读写ByteBuffer"><a href="#读写ByteBuffer" class="headerlink" title="读写ByteBuffer"></a>读写ByteBuffer</h2><p>首先看一下HeapByteBuffer()的get()方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读操作就是直接读取下一个index的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hb[ix(nextGetIndex())];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(offset, length, dst.length);</span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    System.arraycopy(hb, ix(position()), dst, offset, length);</span><br><span class="line">    position(position() + length);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">// offset就是偏移量,是一个数字的偏移量,这里字节数组所以偏移量为1,如果为intBuffer当然会是4了.</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后会检查这里的读是否超过了读的界限.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextGetIndex</span><span class="params">()</span> </span>&#123;                       </span><br><span class="line">        <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">        <span class="keyword">return</span> position++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 这个方法直接找到下n个位置</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextGetIndex</span><span class="params">(<span class="keyword">int</span> nb)</span> </span>&#123;                   </span><br><span class="line">    <span class="keyword">if</span> (limit - position &lt; nb)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="keyword">int</span> p = position;</span><br><span class="line">    position += nb;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然了读操作也不能无限制的读啊,当然的是需要有一个界限了,这里就有了下面这个方法,能够检测是否还能继续读取.可以就返回true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> position &lt; limit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在看一下写操作:这里写操作和读操作类似,但是有很多重载,就不一一介绍了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">    hb[ix(nextPutIndex())] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextPutIndex</span><span class="params">()</span> </span>&#123;               </span><br><span class="line">    <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">return</span> position++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到,写操作也是直接向position位置写数据,这里其实会挺迷惑的.如果说写和读都需要让position加1,那么每次读的时候,肯定是读不到写的数据啊.当然了,jdk肯定考虑到了这个. 当我们写完数据需要在读取之前的数据的时候,我们就需要再次将position置位0,然后在开始读取我们的数据.Buffer中提供了修改positon的方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> newPosition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((newPosition &gt; limit) || (newPosition &lt; <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        position = newPosition;</span><br><span class="line">        <span class="keyword">if</span> (mark &gt; position) mark = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然了,如果我们想要正常读取数据的话只修改position是不够的,还应该再次修改limit的值,让它指向刚才写入的最后一个位置,我们才能保证读到的数据都是有效的.这就有了limit这个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((newLimit &gt; capacity) || (newLimit &lt; <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        limit = newLimit;</span><br><span class="line">        <span class="keyword">if</span> (position &gt; limit) position = limit;</span><br><span class="line">        <span class="keyword">if</span> (mark &gt; limit) mark = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>但是每次调用这两个方法都很麻烦啊,这里jdk也帮我们想到了,所以有了flip()方法.很多人都知道写入Buffer数据之后要使用flip()方法然后才能读取到数据,但是不知道为什么,看了下面代码应该就知道了.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        limit = position;</span><br><span class="line">        position = <span class="number">0</span>;</span><br><span class="line">        mark = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里看一个实例来了解一下吧:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>); <span class="comment">// 申请一个1024个字节的Buffer</span></span><br><span class="line">        buffer.put(<span class="string">"1234567"</span>.getBytes()); </span><br><span class="line">        <span class="comment">// 调用flip()函数将position置0,将limit置位当初写到的最后一个位置</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">// 如果还有读取的数据就读取</span></span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)buffer.get());<span class="comment">// 这里会按序输出1234567</span></span><br><span class="line">        &#125;</span><br><span class="line">        buffer.limit(<span class="number">1024</span>); <span class="comment">// 这里在设置limit为1024,因为如果不设置就会写不进去了.然后接下来才可以继续写.</span></span><br><span class="line">        System.out.println(buffer.position()); <span class="comment">// 这里输出position为7,也就是下一个要读或写的位置.</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="reset-方法"><a href="#reset-方法" class="headerlink" title="reset()方法"></a>reset()方法</h2><p>reset()方法主要是为了让我们能够在此回到上一个感兴趣的位置,比如在读取数据的时候发现出错了,我们就要重新读取,从上次对的地方开始读取.这就需要用到reset()方法.<br>当然了,reset()是要用到mark标记字段的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先用mark()方法标记当前位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mark = position;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 之后如果需要回到当前位置,就调用reset()将position置位mark的位置,开始读写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = mark;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">        position = m;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Buffer是NIO中的一个很重要的辅助类,虽然不难,但是很重要,有必要去了解一下它的实现与基本机制,最起码能够在写代码的时候不会因为各种读取不到数据,没有使用flip()方法等导致找很长时间bug.</p><p>参考自博文:<a href="http://www.tianxiaobo.com/2018/03/04/Java-NIO%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA/" target="_blank" rel="noopener">http://www.tianxiaobo.com/2018/03/04/Java-NIO%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA/</a><br>这位大佬写的很不错,浅显易懂.其他文章写的也都挺不错的.</p>]]></content>
      
      
      <categories>
          
          <category> java-NIO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>烦人的配置篇</title>
      <link href="/2019/04/30/%E5%B8%B8%E7%8A%AF%E9%94%99%E8%AF%AF/"/>
      <url>/2019/04/30/%E5%B8%B8%E7%8A%AF%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<p>##<br>鉴于自己在搭建项目的时候经常出现一些很莫名其妙的bug或者说配置问题,这里做一个记录,持续更新,更新自己遇到的BUG.以及如何解决.  </p><h2 id="idea-maven更改pom之后jdk自动变为1-5版本-导致还必须得重新更改设置"><a href="#idea-maven更改pom之后jdk自动变为1-5版本-导致还必须得重新更改设置" class="headerlink" title="idea+maven更改pom之后jdk自动变为1.5版本,导致还必须得重新更改设置."></a>idea+maven更改pom之后jdk自动变为1.5版本,导致还必须得重新更改设置.</h2><p>这里只需要更改maven安装目录下的/conf/setting.xml文件,在其中的加入如下片段:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;profiles&gt;</span><br><span class="line">&lt;profile&gt;  </span><br><span class="line">        &lt;id&gt;jdk-1.8&lt;/id&gt;  </span><br><span class="line">        &lt;activation&gt;  </span><br><span class="line">            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;  </span><br><span class="line">            &lt;jdk&gt;1.8&lt;/jdk&gt;  </span><br><span class="line">        &lt;/activation&gt;  </span><br><span class="line">        &lt;properties&gt;  </span><br><span class="line">            &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;  </span><br><span class="line">            &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;  </span><br><span class="line">            &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;  </span><br><span class="line">        &lt;/properties&gt;  </span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">&lt;/profiles&gt;</span><br></pre></td></tr></table></figure></p><p>这里我用的是JDK1.8,所以我把他们改成了jdk1.8,只要改成对应的版本.<br>之后再在idea中setting中更改maven配置<br><img src="/2019/04/30/常犯错误/maven导入变jdk变1.5解决.png" alt><br>将上面的maven用本地的,然后仓库和设置都是用本地的就可以了,也就是勾选上面两个override选项.<br>然后再在idea中重新导入一下idea就可以了</p><h2 id="java-Web-Servlet-报错"><a href="#java-Web-Servlet-报错" class="headerlink" title="java Web @Servlet 报错"></a>java Web @Servlet 报错</h2><p>java.lang.IllegalStateException: Cannot call sendError() after the response has been committed<br>出现这个错误信息. 这个错误就是在已经返回函数的情况下,又想连接中写入数据了,所以会出现这个情况.这个一般都出现在异步的情况.但是我这里也没有这么做.所以就也不是这个问题.  </p><p>最后找到原因,是因为没有导入tomcat的依赖包,但是能运行,在运行的时候因为没有tomcat的包,导致运行时候出错.导入包之后WebServlet注解也可以用了.也不会出现这个错误.</p>]]></content>
      
      
      <categories>
          
          <category> 项目错误汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> error </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java NIO之Selector</title>
      <link href="/2019/04/29/java-NIO%E4%B9%8Bselector/"/>
      <url>/2019/04/29/java-NIO%E4%B9%8Bselector/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Selector 是一个选择器,主要用法就是,通过将一个通道注册到selector中,然后在通过select方法获取到你监听的事件绑定的键. 相当于是以前需要不断轮询去判断io流是否可读,或者可写,或者新的连接已经到来.现在通过Selector帮你判断,当有可用的连接或者可读可写时,selectKeys()方法会返回一个可用的通道集合.通过调用selector.select()来实现,这个方法是阻塞的,当没有准备就绪的通道会阻塞.当然了,这一切包括通道和注册事件都是由一个SelectionKey保存的.<br>所以在讲解selector之前必须得现有一个SelectionKey和Channel的概念.  </p><h2 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h2><p>讲到Selector必须得将SelectionKey,因为每次向Selector中注册一个事件就会创建一个选择键,可以通过它的cancel方法,close等方法来关闭它或者取消它.</p><p>当把通道注册到Selector中的时候,Selector开始监听,但是Selector的返回就绪事件的时候总是返回一个SelectionKey,在这个key中包含了当初注册的通道,拿到这个通道然后开始做自己的事情,比如说读写,建立连接.<br>SelectionKey有四种事件: </p><ul><li>int OP_ACCEPT = 1 &lt;&lt; 4;   //监听接收连接请求</li><li>int OP_CONNECT = 1 &lt;&lt; 3;// 监听连接完成</li><li>int OP_WRITE = 1 &lt;&lt; 2; // 监听可写</li><li>int OP_READ = 1 &lt;&lt; 0;  // 可读   </li></ul><p>事件之间可以通过或运算进行组合,比如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestOps = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure></p><p>这里这个interestOps就是读和写事件的合集.因为每个事件都是2的整数倍,所以或运算之后判断每一位的状态就可以知道注册的事件合集</p><h3 id="两种事件集合-interestOps-和-readyOps"><a href="#两种事件集合-interestOps-和-readyOps" class="headerlink" title="两种事件集合:interestOps 和 readyOps"></a>两种事件集合:interestOps 和 readyOps</h3><p>interestOps就是感兴趣的事件集合,通过register方法注册时会调用此值,可以通过Selectionkey.interestOps()方法获得<br>readyOps 是就绪事件集合，可通过 SelectionKey readyOps() 获取。<br>下面来看一下SelectionKey中的具体的方法</p><h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法:"></a>具体方法:</h3><table><thead><tr><th style="text-align:center">返回值</th><th style="text-align:center">方法名</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">Object</td><td style="text-align:center">attach（Object obj)</td><td style="text-align:center">将给定的对象附加到此键</td></tr><tr><td style="text-align:center">Object</td><td style="text-align:center">attachment()</td><td style="text-align:center">返回附加给此键的对象</td></tr><tr><td style="text-align:center">abstract void</td><td style="text-align:center">cancel()</td><td style="text-align:center">请求取消此键的通道到其选择键的注册</td></tr><tr><td style="text-align:center">Channel</td><td style="text-align:center">channel()</td><td style="text-align:center">返回为之创建此键的通道</td></tr><tr><td style="text-align:center">SelectionKey</td><td style="text-align:center">interestOps(int ops)</td><td style="text-align:center">将此键的 interest 集合设置为给定值。</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">isAcceptable()</td><td style="text-align:center">测试此键的通道已经准备好接受新的套接字连接</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">isConnectable()</td><td style="text-align:center">测试此键的通道是否已经建立好连接</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">isReadable()</td><td style="text-align:center">测试是否有数据可读</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">isValid()</td><td style="text-align:center">此键是否有效</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">isWriteable()</td><td style="text-align:center">通道是否可写</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">selector()</td><td style="text-align:center">返回为此选择器创建的键。</td></tr></tbody></table><h2 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h2><p>ServerSocketChannel其实就是对ServerSocket的一个封装,使得它能够非阻塞接受请求.将socket变成通道形式的.具体类图看一下<br><img src="/2019/04/29/java-NIO之selector/SocketChannel.png" alt></p><p>上面说到向Selector中注册选择键,但是这个注册选择键又是怎么注册的呢.看下面代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里就是新建一个Selector</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"><span class="comment">// 这里建立一个服务的SocketChannel通道</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">// 设置为非阻塞</span></span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 绑定端口</span></span><br><span class="line">serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line"><span class="comment">// 这里执行注册监听连接事件</span></span><br><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"><span class="comment">// accept 方法接受一个连接,返回一个SocketChannel.</span></span><br><span class="line">SocketChannel socketChannel =serverSocketChannel.accept();</span><br><span class="line"><span class="comment">// socket 返回一个ServerSocket. ServerSocket套接字就是服务端的套接字,用来接受连接请求.</span></span><br><span class="line">ServerSocket socket = serverSocketChannel.socket();</span><br></pre></td></tr></table></figure></p><p>这里调用register()方法就将这个Channel注册到了selector中.之后就会监听此通道的accept请求了.当然这里只是说明了注册方式,具体细节请继续看下去.<br>方法不多,但是很多方法都是继承子父类的,比如上面代码中的bind,register,configureBlocking.</p><p>这里的register主要就是使用</p><h2 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h2><p>SocketChannel,这个通道主要就类似于普通的Socket,但是使用通道来表示Socket的连接,通过通道和Selector和选择键可以实现非阻塞IO.<br>主要方法:  这里用一个例子来演示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也是通过open()打开一个连接</span></span><br><span class="line">SocketChannel socketChannel =  SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">8000</span>));</span><br><span class="line"><span class="comment">// 与ServerSocketChannel一样,也配置是异步</span></span><br><span class="line">socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 这里有一点就是如果要注册到Selector中的话必须首先设置为异步的.</span></span><br><span class="line">socketChannel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure></p><p>套接字通道不是连接网络套接字的完整抽象。必须通过调用 socket 方法所获得的关联 Socket 对象来完成对套接字选项的绑定、关闭和操作。不可能为任意的已有套接字创建通道，也不可能指定与套接字通道关联的套接字所使用的 SocketImpl 对象。</p><p>通过调用此类的某个 open 方法创建套接字通道。新创建的套接字通道已打开，但尚未连接。试图在未连接的通道上调用 I/O 操作将导致抛出 NotYetConnectedException。可通过调用套接字通道的 connect 方法连接该通道；一旦连接后，关闭套接字通道之前它会一直保持已连接状态。可通过调用套接字通道的 isConnected 方法来确定套接字通道是否已连接。</p><p>套接字通道支持非阻塞连接：可创建一个套接字通道，并且通过 connect 方法可以发起到远程套接字的连接，之后通过 finishConnect 方法完成该连接。可通过调用 isConnectionPending 方法来确定是否正在进行连接操作。</p><p>可单独地关闭 套接字通道的输入端和输出端，而无需实际关闭该通道。调用关联套接字对象的 shutdownInput 方法来关闭某个通道的输入端将导致该通道上的后续读取操作返回 -1（指示流的末尾）。调用关联套接字对象的 shutdownOutput 方法来关闭通道的输出端将导致该通道上的后续写入操作抛出 ClosedChannelException。</p><p>套接字通道支持异步关闭，这与 Channel 类中所指定的异步 close 操作类似。如果一个线程关闭了某个套接字的输入端，而同时另一个线程被阻塞在该套接字通道上的读取操作中，那么处于阻塞线程中的读取操作将完成，而不读取任何字节且返回 -1。I如果一个线程关闭了某个套接字的输出端，而同时另一个线程被阻塞在该套接字通道上的写入操作中，那么阻塞线程将收到 AsynchronousCloseException。</p><p>多个并发线程可安全地使用套接字通道。尽管在任意给定时刻最多只能有一个线程进行读取和写入操作，但数据报通道支持并发的读写。connect 和 finishConnect 方法是相互同步的，如果正在调用其中某个方法的同时试图发起读取或写入操作，则在该调用完成之前该操作被阻塞</p><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>Selector其实就是一个I/O多路复用器.通过复用</p><p>接下来主要说一下Selector类,这个类是NIO的核心类,如果没有它,那么可能我们还必须要像以前一样,要么阻塞在读或者写事件,要么轮询是否可读写,浪费cpu资源.Selector中可以是通过将一个通道注册上,当事件发生的时候将此通道所绑定的选择键返回给调用者,让调用这去处理,而不必让每个调用者轮询此连接是否可读可写.  </p><p>这里通过SelectionKey来表示从通道到选择器的注册:<br>在Selector中有三种键的集合:</p><ul><li>已选择集合: 是在前一次选择期间操作期间,检测每个键的通道是否已经至少为该键的相关操作集所标识的一个操作准备就绪,此集合由 selectedKeys 方法返回</li><li>已取消集合: 是被取消但是通道尚未注销的集合.不可直接访问此集合.</li><li>注册集合: 表示所有注册到此选择器上的键.包括以取消但是还未注销的键.通过keys()返回<br>当新创建Selector时,三个集合都是空的,每当有一个通道通过register向Selector注册该通道的时候,也会想选择器的键集添加一个与此通道绑定的键.而且需要在选择期间从键集中移除已经取消的键.<br>不管是通过关闭某个键的通道还是调用该键的 cancel 方法来取消键，该键都被添加到其选择器的已取消键集中。取消某个键会导致在下一次选择操作期间注销该键的通道，而在注销时将从所有选择器的键集中移除该键。</li></ul><p>通过选择操作将键添加到已选择键集中,可以通过调用已选择键集的remove()方法,或者调用该键集的迭代器的remove()方法移除此键.只能通过这两种方式来移除键集中的键.  </p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>Selector不能直接实例化,需要使用Selector.open()来初始化:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure></p><p>这里就打开连接了,当然了,建立一个Selector并不是这么简单,java帮我们封装了很多api,一些底层实现我们是不知道的,既然要理解Selector,这里我们也要看一下到底它都干了什么.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SelectorProvider.provider().openSelector();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>发现open()函数其实是调用了一个SelectorProvider()的函数来进行创建的.在进去调用栈看一看.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">provider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> provider;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;SelectorProvider&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> SelectorProvider <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (loadProviderFromProperty())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                            <span class="keyword">if</span> (loadProviderAsService())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                            <span class="comment">// 创建默认的SelectorProvider</span></span><br><span class="line">                        provider = sun.nio.ch.DefaultSelectorProvider.create();</span><br><span class="line">                        <span class="keyword">return</span> provider;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里调用Provider函数,创建一个SelectorProvider实例,在这个实例又调用这个DefaultSelectorProvider.create()真正创建一个Selecotr实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String var0 = (String)AccessController.doPrivileged(<span class="keyword">new</span> GetPropertyAction(<span class="string">"os.name"</span>));</span><br><span class="line">    <span class="keyword">if</span> (var0.equals(<span class="string">"SunOS"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> createProvider(<span class="string">"sun.nio.ch.DevPollSelectorProvider"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (SelectorProvider)(var0.equals(<span class="string">"Linux"</span>) ? createProvide(<span class="string">"sun.nio.ch.EPollSelectorProvider"</span>) : <span class="keyword">new</span> PollSelectorProvider());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这里应该明白了,其实到这里能看出来,如果是linux系统的话,Selector就是通过使用epoll来实现的.如果是SunOS就用DevPoll实现.到了这一步,大致对创建就有了一个了解.</p><h3 id="通道注册"><a href="#通道注册" class="headerlink" title="通道注册"></a>通道注册</h3><p>上面已经提到,通道注册的话就是需要调用通道的register方法来注册到selector中,不如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure></p><p>既然已经知道了这个Selector是使用epoll来实现的,那么注册应该就是使用的是函数epoll_ctl()函数了.但是java中确不是这么实现的.在register的调用栈中,确实没有出现epoll_ctl()函数的调用.它是通过先把所有的注册事件都放在了一个事件集合中,然后在选择的时候再进行统一注册.<br>接下来看一下register方法的调用过程:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用register方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Object att)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClosedChannelException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (regLock) &#123;</span><br><span class="line">            <span class="comment">// 如果通道没打开,则抛异常</span></span><br><span class="line">            <span class="keyword">if</span> (!isOpen())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">                <span class="comment">// 如果是无效事件,抛异常</span></span><br><span class="line">            <span class="keyword">if</span> ((ops &amp; ~validOps()) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">                <span class="comment">//如果是阻塞模式,抛异常</span></span><br><span class="line">            <span class="keyword">if</span> (blocking)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalBlockingModeException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里findkey方法会首先查看此通道是否已经被注册过</span></span><br><span class="line">            SelectionKey k = findKey(sel);</span><br><span class="line">            <span class="comment">// 如果注册过,将此事件加入到感兴趣事件中</span></span><br><span class="line">            <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">                k.interestOps(ops);</span><br><span class="line">                k.attach(att);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有,则去注册</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// New registration</span></span><br><span class="line">                <span class="keyword">synchronized</span> (keyLock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!isOpen())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">                    k = ((AbstractSelector)sel).register(<span class="keyword">this</span>, ops, att);</span><br><span class="line">                    addKey(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorImpl</span> <span class="keyword">extends</span> <span class="title">AbstractSelector</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(AbstractSelectableChannel var1, <span class="keyword">int</span> var2, Object var3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(var1 <span class="keyword">instanceof</span> SelChImpl)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalSelectorException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 新建一个SelectionKeyImpl</span></span><br><span class="line">            SelectionKeyImpl var4 = <span class="keyword">new</span> SelectionKeyImpl((SelChImpl)var1, <span class="keyword">this</span>);</span><br><span class="line">            var4.attach(var3);</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.publicKeys) &#123;</span><br><span class="line">                <span class="comment">// 调用注册函数</span></span><br><span class="line">                <span class="keyword">this</span>.implRegister(var4);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将此次注册事件添加到感兴趣事件集合中</span></span><br><span class="line">            var4.interestOps(var2);</span><br><span class="line">            <span class="keyword">return</span> var4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EPollSelectorImpl</span> <span class="keyword">extends</span> <span class="title">SelectorImpl</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这是上面的实现了的注册函数</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implRegister</span><span class="params">(SelectionKeyImpl var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.closed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 首先获得一个channel</span></span><br><span class="line">            SelChImpl var2 = var1.channel;</span><br><span class="line">            <span class="comment">// 获取到channel 的文件描述符</span></span><br><span class="line">            <span class="keyword">int</span> var3 = Integer.valueOf(var2.getFDVal());</span><br><span class="line">            <span class="comment">// 存储 文件描述符 和 SelectionKeyImpl 的映射关系</span></span><br><span class="line">            <span class="keyword">this</span>.fdToKey.put(var3, var1);</span><br><span class="line">            <span class="comment">// 将这个事件加入到pollWrapper中    </span></span><br><span class="line">            <span class="keyword">this</span>.pollWrapper.add(var3);</span><br><span class="line">            <span class="comment">// 将这个SelectionKey加入到键集合中</span></span><br><span class="line">            <span class="keyword">this</span>.keys.add(var1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionKeyImpl</span> <span class="keyword">extends</span> <span class="title">AbstractSelectionKey</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SelectionKey <span class="title">interestOps</span><span class="params">(<span class="keyword">int</span> ops)</span> </span>&#123;</span><br><span class="line">        ensureValid();</span><br><span class="line">        <span class="keyword">return</span> nioInterestOps(ops);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> SelectionKey <span class="title">nioInterestOps</span><span class="params">(<span class="keyword">int</span> ops)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((ops &amp; ~channel().validOps()) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="comment">// 转换并设置感兴趣的事件</span></span><br><span class="line">        channel.translateAndSetInterestOps(ops, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 设置 interestOps 变量</span></span><br><span class="line">        interestOps = ops;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class</span> <span class="title">EPollSelectorImpl</span> <span class="keyword">extends</span> <span class="title">SelectorImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putEventOps</span><span class="params">(SelectionKeyImpl ski, <span class="keyword">int</span> ops)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closed)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</span><br><span class="line">        SelChImpl ch = ski.channel;</span><br><span class="line">        <span class="comment">// 设置感兴趣的事件</span></span><br><span class="line">        pollWrapper.setInterest(ch.getFDVal(), ops);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EPollArrayWrapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setInterest</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (updateLock) &#123;</span><br><span class="line">            <span class="comment">// 扩容 updateDescriptors 数组，并存储文件描述符 fd</span></span><br><span class="line">            <span class="keyword">int</span> oldCapacity = updateDescriptors.length;</span><br><span class="line">            <span class="keyword">if</span> (updateCount == oldCapacity) &#123;</span><br><span class="line">                <span class="keyword">int</span> newCapacity = oldCapacity + INITIAL_PENDING_UPDATE_SIZE;</span><br><span class="line">                <span class="keyword">int</span>[] newDescriptors = <span class="keyword">new</span> <span class="keyword">int</span>[newCapacity];</span><br><span class="line">                System.arraycopy(updateDescriptors, <span class="number">0</span>, newDescriptors, <span class="number">0</span>, oldCapacity);</span><br><span class="line">                updateDescriptors = newDescriptors;</span><br><span class="line">            &#125;</span><br><span class="line">            updateDescriptors[updateCount++] = fd;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// events are stored as bytes for efficiency reasons</span></span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)mask;</span><br><span class="line">            <span class="keyword">assert</span> (b == mask) &amp;&amp; (b != KILLED);</span><br><span class="line">            <span class="comment">// 存储事件</span></span><br><span class="line">            setUpdateEvents(fd, b, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUpdateEvents</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">byte</span> events, <span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; MAX_UPDATE_ARRAY_SIZE) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((eventsLow[fd] != KILLED) || force) &#123;</span><br><span class="line">                eventsLow[fd] = events;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Integer key = Integer.valueOf(fd);</span><br><span class="line">            <span class="keyword">if</span> (!isEventsHighKilled(key) || force) &#123;</span><br><span class="line">                eventsHigh.put(key, Byte.valueOf(events));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到了implRegister()函数的时候基本就算完事了,所以说在注册的过程中,就只是将event添加到eventsLow数组中,至于epoll_ctl的调用,则是在选择期间调用.</p><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>在每次选择期间都可以将其从已选择键集或者键集中移除.移除完之后就会在下次选择期间看看是否事件发生,如果发生就继续将其添加到已选择键集中.主要有三个方法:</p><ul><li>select()      返回已经准备好I/O的通道数量</li><li>select(long)  返回已经准备好I/O的通道数量</li><li>selectNow()   返回已经准备好I/O的通道数量</li><li>selectKeys()  返回此选择器的已选择键集</li><li>keys()        返回此选择器键集<br>每次做选择都会有一下四步走.</li></ul><ol><li>将已取消键集中的键从选择器中注销.就是清空取消键集.也就是说调用了cancel()的键将在这个时候被真正的取消</li><li>在这之后会调用操作系统的epoll_ctl函数将通道感兴趣的事件注册到epoll实例中.然后开始wait事件发生.</li><li>如果说准备就绪的键已经在已选择键集中,就会更新此键的就绪操作集.如果此键不在已选择键集中,就将此键添加到已选择操作集中.更新就绪操作集</li><li>如果此过程中有过将任意键添加到取消键集中,就继续执行步骤1</li></ol><p>在这里要说明一下,select和selectKeys()是不一样的,select方法返回的是准备好I/O的通道的数量.而selectKeys返回的是选择器的已选择键集.如果编过程的人可能都碰到过这样的一种情况,就是在select()返回是0的情况,但是selectKeys()确返回了好几个键,这里就着重说一下,这个已选择键集和取消键集.这里的已选择键集就是如果你不去手动删除你已经处理完的已选择键集,那么选择器中的已选择键集还是不会变的.也就是说当你处理完一个已选择键集,如果没有通过remove()方法删除掉其中的键的话,这些键将依然存在与已选择键集中.这也就是为什么会出现上面说的那种情况.在编程 的时候需要注意这一点.    </p><p>当移除了已选择键集中的键并不会取消注册,取消有对应的cancel方法,移除已选择键集只是在调用selectKeys的时候不会在此返回上次已经处理过的准备好的通道.</p><h3 id="取消"><a href="#取消" class="headerlink" title="取消:"></a>取消:</h3><p>这里在说一下取消操作,取消操作需要调用SelectionKey.cancel()方法,但是这个方法映射到epoll中并不会立即取消epoll中实例的注册,而是先将此键放入取消键集中,然后等到下一次select()操作时,将此取消键集中的键注销掉.</p>]]></content>
      
      
      <categories>
          
          <category> NIO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java正则表达式</title>
      <link href="/2019/04/23/java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/04/23/java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是处理字符串的强大工具,它并不是java的特性.但是java有一套工具类提供了正则表达式的匹配功能. </p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ol><li>字符串匹配</li><li>字符串查找</li><li>字符串替换</li></ol><h2 id="Java类"><a href="#Java类" class="headerlink" title="Java类"></a>Java类</h2><p>java中正则表达式主要包括两个类:</p><ul><li>Pattern:  此对象是一个正则表达式的编译表示.此类没有共有的构造方法,只能通过静态编译方法来获得一个Pattern对象.比如<strong>Pattern.compile(“\d”);</strong> 这个样子.参数就是要编译的正则表达式.</li><li>Matcher: 是对输入字符串进行解释和匹配的引擎,它也没有公共的构造方法,只能通过Pattern对象的match方法来获得一个Matcher对象</li></ul><h2 id="Java中的正则表达式语法"><a href="#Java中的正则表达式语法" class="headerlink" title="Java中的正则表达式语法"></a>Java中的正则表达式语法</h2><p>首先说明java 中的正则表达式与普通的不一样,java中 ‘\‘ 表示的是要插入一个正则表达式的反斜杠,所以之后的字符具有特殊意义.所以在java中一个’\‘代表着其他语言中的一个’\’.为什么这么做呢,是因为java中字符串是不能有’\’的,如果有的话就必须得插入’\‘表示转义.所以在java字符串中就有了’\‘表示正则中的一个’\’了.这是java语言要求的.<br>下面来看一下具体用法</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">说明</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center">\</td><td style="text-align:center">将下一个字符标记为特殊字符,就是转义字符.</td><td style="text-align:center">例如 ‘\n’ 匹配 换行, ‘\\‘匹配’\‘.</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">匹配字符流的第一个字符</td><td style="text-align:center">例如”^d.*” 匹配 以d开头的字符串</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">匹配字符流的最后一个字符</td><td style="text-align:center">　如上　</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">零次或多次匹配前一个字符</td><td style="text-align:center">例如 “zo*” 匹配 “zoo” 和 “z” “zo”</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">一次或多次匹配前一个字符</td><td style="text-align:center">例如 “zo+” 匹配 “zoo” 和 “zo” 但是不匹配 “z”</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">匹配零次或一次之前的字符</td><td style="text-align:center">例如 “1?” 匹配”1” 和 “” 空</td></tr><tr><td style="text-align:center">{n}</td><td style="text-align:center">n为非负数,正好匹配前一个字符n次</td><td style="text-align:center">例如 “o{2}” 匹配 “oo”</td></tr><tr><td style="text-align:center">{n,}</td><td style="text-align:center">n为非负数,匹配至少n此</td><td style="text-align:center">如上</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:center">匹配n到m次之前的字符</td><td style="text-align:center">如上</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">匹配任意字符</td><td style="text-align:center">例如 “a.” 匹配 “ab” “ac” “ad”等</td></tr><tr><td style="text-align:center">(pattern)</td><td style="text-align:center">匹配 pattern 并捕获该匹配的子表达式.</td><td style="text-align:center">例如 “(ab?)” 匹配 “a” “ab”</td></tr><tr><td style="text-align:center">x&#124;y</td><td style="text-align:center">匹配x或者y字符</td><td style="text-align:center">“a&#124;b” 匹配 “a” 或 “b”</td></tr><tr><td style="text-align:center">[^abc]</td><td style="text-align:center">反向字符集 匹配非括号内的字符</td><td style="text-align:center">“[^123]” 匹配不是字符1 2 3 的所有字符</td></tr><tr><td style="text-align:center">[a-z]</td><td style="text-align:center">匹配a到z之间的所有字符</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">　边界字符　</td><td style="text-align:center">例如 “er\b” 匹配 “never”中的er,但是不匹配”verb”中的er</td></tr><tr><td style="text-align:center">\B</td><td style="text-align:center">非边界字符</td><td style="text-align:center">和上面反过来</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">匹配数字字符</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">\D</td><td style="text-align:center">匹配非数字字符</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">\n</td><td style="text-align:center">换行符</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">\s</td><td style="text-align:center">匹配任意空白字符</td><td style="text-align:center">包括空格符,制表符,换页符</td></tr><tr><td style="text-align:center">\S</td><td style="text-align:center">匹配任意非空白字符</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">\w</td><td style="text-align:center">匹配任意字类字符　</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">\W</td><td style="text-align:center">匹配任意非字类字符</td></tr></tbody></table><h2 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h2><p>具体看看Pattern的用法,对象如其名,是一个匹配模式的编译表示.在java中不能直接构造出来,只能通过静态方法complie()来获取Pattern实例.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pattern pattern =  Pattern.compile(<span class="string">"\\d+"</span>);</span><br><span class="line">System.out.println(pattern.pattern()); <span class="comment">// 输出 \d+</span></span><br></pre></td></tr></table></figure></p><p>此语句就返回一个匹配模式,此模式匹配全部的数字.</p><h3 id="Pattern-split-CharSequence-input"><a href="#Pattern-split-CharSequence-input" class="headerlink" title="Pattern.split(CharSequence input)"></a>Pattern.split(CharSequence input)</h3><p>Pattern 有一个split方法,这个方法与String.split()方法是一样的.返回用指定字符分割的字符数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern pattern =  Pattern.compile(<span class="string">"\\d+"</span>);</span><br><span class="line">String[] strs =  pattern.split(<span class="string">"nihao123hello123word"</span>);</span><br><span class="line">[nihao, hello, word]  <span class="comment">// 输出</span></span><br></pre></td></tr></table></figure></p><h3 id="matches-String-regex-CharSequence-input"><a href="#matches-String-regex-CharSequence-input" class="headerlink" title="matches(String regex, CharSequence input)"></a>matches(String regex, CharSequence input)</h3><p>这个方法是返回一个boolean值,判断输入是否与指定模式匹配.这里匹配是要全部匹配<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern.matches(<span class="string">"\\d+"</span>,<span class="string">"12312312"</span>);  <span class="comment">//true</span></span><br><span class="line">Pattern.matches(<span class="string">"\\d+"</span>,<span class="string">"123a12312"</span>); <span class="comment">//false  a不匹配</span></span><br><span class="line">System.out.println(Pattern.matches(<span class="string">"\\d+"</span>,<span class="string">""</span>)); <span class="comment">// false ,+ 说明一个或多个,空不匹配</span></span><br></pre></td></tr></table></figure></p><h3 id="matcher-CharSequence-input"><a href="#matcher-CharSequence-input" class="headerlink" title="matcher(CharSequence input)"></a>matcher(CharSequence input)</h3><p>返回一个Matcher类,Matcher类提供了比Pattern更为多的功能,它能够匹配多次,并且有分组支持.</p><h2 id="Matcher类方法"><a href="#Matcher类方法" class="headerlink" title="Matcher类方法"></a>Matcher类方法</h2><h3 id="matchers-lookingAt-find"><a href="#matchers-lookingAt-find" class="headerlink" title="matchers() / lookingAt() / find()"></a>matchers() / lookingAt() / find()</h3><p>Matcher类提供了三个匹配操作方法,三个方法都返回boolean值,匹配到时返回true,匹配不到返回false .<br>matchers()方法是对整个字符串进行匹配,只有整个字符串都匹配了才返回true<br>lookingAt() 只是对开头的字符进行匹配,只要开头有符合的,就返回true<br>find()对字符串匹配,匹配到的字符串可以在任意位置.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Pattern pattern =  Pattern.compile(<span class="string">"\\d+"</span>);</span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="string">"223322"</span>);</span><br><span class="line">        matcher.matches();  <span class="comment">// true</span></span><br><span class="line">        matcher.lookingAt(); <span class="comment">// true</span></span><br><span class="line">        matcher.find(); <span class="comment">// true </span></span><br><span class="line">        Matcher m2 = pattern.matcher(<span class="string">"2233dd"</span>);</span><br><span class="line">        m2.matches(); <span class="comment">// false  全部匹配才可以</span></span><br><span class="line">        m2.lookingAt(); <span class="comment">// true  开头有匹配的可以</span></span><br><span class="line">        m2.find(); <span class="comment">// true 任意地方匹配</span></span><br><span class="line">        Matcher m3 = pattern.matcher(<span class="string">"dd2233"</span>);</span><br><span class="line">        m3.matches(); <span class="comment">// false</span></span><br><span class="line">        m3.lookingAt(); <span class="comment">// false 开头没有匹配</span></span><br><span class="line">        m3.find(); <span class="comment">// true 任意有匹配可以</span></span><br></pre></td></tr></table></figure></p><h3 id="start-end-group"><a href="#start-end-group" class="headerlink" title="start() / end() / group()"></a>start() / end() / group()</h3><p>使用matchers(),lookingAt(),find()方法后就可以使用这三个方法得到更加详细的信息<br>start() 返回匹配的子字符串在索引中的位置<br>end() 返回匹配的子字符串的最后一个字符在索引的位置<br>group() 返回匹配到的子字符串. 分组是在自己定义的匹配模式中定义的.用()包起来的.<br>这里分组有一个规定 :<br>捕获组是通过从左至右计算其开括号来编号,第一个括号编号从1开始.例如表达式中((A)(B(C))).编号从从1开始是如下的:</p><ol><li>((A)(B(C)))</li><li>(A)</li><li>(B(C))</li><li>(C)</li></ol><p>代码实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里只介绍group操作,可以把group操作想成是m.group()操作看成是s.substring(m.start(),m.end());</span></span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"(\\d+)((abc)+)"</span>);</span><br><span class="line">Matcher matcher1 = p.matcher(<span class="string">"900abcabc"</span>);</span><br><span class="line">System.out.println(matcher1.matches()); <span class="comment">// true 匹配到了整个字符串</span></span><br><span class="line">System.out.println(matcher1.group()); <span class="comment">// 返回整个字符串</span></span><br><span class="line">System.out.println(matcher1.group(<span class="number">1</span>)); <span class="comment">// 第一个匹配的 全部的数字 所以是 900</span></span><br><span class="line">System.out.println(matcher1.group(<span class="number">2</span>)); <span class="comment">// 第二个匹配的 abcabc</span></span><br><span class="line">System.out.println(matcher1.group(<span class="number">3</span>)); <span class="comment">// 第三个括号 一个abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面看lookingAt()方法</span></span><br><span class="line">Pattern p1 = Pattern.compile(<span class="string">"(\\d+)(abc)"</span>);</span><br><span class="line">Matcher matcher2 = p1.matcher(<span class="string">"900abcbbd"</span>);</span><br><span class="line">matcher2.lookingAt(); <span class="comment">// true  looking只需要匹配开头就可以了.所以这里是true,如果用matches则返回false</span></span><br><span class="line">System.out.println(matcher2.group(<span class="number">1</span>)); <span class="comment">// 900 匹配第一个括号中的内容</span></span><br><span class="line">System.out.println(matcher2.group(<span class="number">2</span>)); <span class="comment">// abc 后面的则不匹配</span></span><br></pre></td></tr></table></figure></p><p>find方法,find方法比较不一样,所以需要单独来讲<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        Pattern p2 = Pattern.compile(<span class="string">"(\\d+)(a+)"</span>);</span><br><span class="line">        Matcher matcher3 = p2.matcher(<span class="string">"900aa bcbb900aa bcbb900aa bcbbabc"</span>);</span><br><span class="line">        <span class="keyword">while</span> (matcher3.find())&#123;</span><br><span class="line">            System.out.println(matcher3.group());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">输出</span><br><span class="line"><span class="number">900</span>aa   </span><br><span class="line"><span class="number">900</span>aa</span><br><span class="line"><span class="number">900</span>aa</span><br></pre></td></tr></table></figure></p><p>find方法将会找到整个串中所有符合的子串.当然也可以使用group(1)匹配第一个分组,从而找到所有的字符串.在这里有一个点就是因为find()方法会匹配整个字符串符合模式的子串.所以每次调用find()方法,就会找到下一个匹配此模式的子串.所以在调用了一次find()方法就需要在调用一次group()方法来获得所匹配的子串.这是因为在matcher中记录了一个当前匹配的位置,下一次在匹配的时候会从当前位置开始进行匹配.</p><h3 id="appendReplacement-StringBuffer-sb-String-replacement-和-appendTail-StringBuffer-sb"><a href="#appendReplacement-StringBuffer-sb-String-replacement-和-appendTail-StringBuffer-sb" class="headerlink" title="appendReplacement(StringBuffer sb, String replacement) 和 appendTail(StringBuffer sb)"></a>appendReplacement(StringBuffer sb, String replacement) 和 appendTail(StringBuffer sb)</h3><p>appendReplacement这个方法主要是为了用来为字符串做替换的.通过将匹配到的字符串替换成指定的字符串到字符串缓冲区.appendTail从添加位置开始从字符序列读取字符然后加入到缓冲区.一般是用来给appendReplacement方法替换过之后调用它来复制剩余的序列.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Pattern p3 = Pattern.compile(<span class="string">"cat"</span>);</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        Matcher matcher4 = p3.matcher(<span class="string">"one cat and two cats in the word"</span>);</span><br><span class="line">        <span class="keyword">while</span> (matcher4.find())&#123;</span><br><span class="line">            matcher4.appendReplacement(sb,<span class="string">"dog"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在这里输出的结果是最后一次匹配替换过后的字符串  one dog and two dog</span></span><br><span class="line">        matcher4.appendTail(sb); <span class="comment">// 这里通过appendTail()进行收尾工作,将结尾的字符添加到缓冲区中.</span></span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">输出</span><br><span class="line">one dog and two dogs in the word</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 正则表达式 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java编译优化</title>
      <link href="/2019/04/21/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/"/>
      <url>/2019/04/21/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="java编译"><a href="#java编译" class="headerlink" title="java编译"></a>java编译</h2><p>java编译器为我们做了很多优化,比如在java中泛型并不是真正的泛型,在编译的时候会进行泛型擦除,使用的时候再进行类型转换.或者Integer自动装箱和拆箱.foreach循环遍历等等.</p><h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p>在java中泛型并不是真正的泛型,因为有一个java早期没有泛型的时候都是通过Object来代替泛型的,因为java中每个对象都是继承自Object的.在通过类型转换来实现泛型.现在有了泛型.通过泛型来指定类型.但是这个泛型也不是真正的泛型.在编译期间都会进行泛型擦除.使其变为普通的类型.下面来看个例子<br>源代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; ls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ls.add(<span class="number">1</span>);</span><br><span class="line">ls.add(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> a = ls.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure></p><p>编译之后的字节码反编译过来的文件.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList var1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        var1.add(<span class="number">1</span>);</span><br><span class="line">        var1.add(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> var2 = (Integer)var1.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(var2);</span><br></pre></td></tr></table></figure></p><p>这里可以看到这个时候哦ArrayList已经没有泛型了,只是他原来的类型.在获取字段的时候会有一个类型转换的操作.所以有一点就是在进行方法重载的时候ArrayList<integer> 和 ArrayList<double> 类型是一样的,编译会出现错误.<br>也正是有了泛型擦除,就有了一个问题,你可以向一个定义了类型的容器中添加其他类型的变量.看下面代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Class&lt;? extends ArrayList&gt; cls = (Class&lt;? extends ArrayList&gt;) ls.getClass();</span><br><span class="line">Method method = cls.getDeclaredMethod(<span class="string">"add"</span>,Object.class);</span><br><span class="line">method.invoke(ls,<span class="number">10</span>);</span><br></pre></td></tr></table></figure></double></integer></p><p>这里通过反射向list中添加Integer变量,并没有报错,但是,这个时候如果在运行时候调用get()方法,那么如上所说,会在get方法前加入强制类型转换,所以会在运行时期报错.</p><h2 id="Integer-Double-自动装箱与拆箱"><a href="#Integer-Double-自动装箱与拆箱" class="headerlink" title="Integer. Double 自动装箱与拆箱"></a>Integer. Double 自动装箱与拆箱</h2><p>在java中提供了自动装箱与拆箱的功能,就是把int变成Integer对象或者反过来.因为在泛型中只能存储对象而不能是普通值.而且在Integer或者Long中都有自己的数字缓存.都缓存了从-128~127之间的数字.意思就是在这些数字范围内的Integer对象都引用的是同一个对象.在看一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="number">128</span>;</span><br><span class="line">    Integer b = <span class="number">128</span>;</span><br><span class="line">    Integer c = <span class="number">1</span>;</span><br><span class="line">    Integer d = <span class="number">2</span>;</span><br><span class="line">    Integer e = <span class="number">3</span>;</span><br><span class="line">    Integer f = <span class="number">3</span>;</span><br><span class="line">    System.out.println(f == e);</span><br><span class="line">    System.out.println(c+d == e );</span><br><span class="line">    System.out.println(a==b);</span><br><span class="line">&#125;</span><br><span class="line">输出:</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure></p><p>这里可以看到从128开始就不缓存了.但是在128之前的数字都是缓存的.都引用的是同一个缓存的对象.但是在代码中最后还是使用equals来比较对象.这是最稳妥的.</p><h2 id="foreach循环遍历"><a href="#foreach循环遍历" class="headerlink" title="foreach循环遍历"></a>foreach循环遍历</h2><p>foreach循环遍历是代码中很常见的一个用法,但是他底层是怎么实现的呢,很多人不知道.其实也是很简单的,下面看实例;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 普通容器变为迭代器遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: ls)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// foreach循环在数组中变为普通的for遍历循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: arr)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码编译过后就能看到<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">        ArrayList var1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        Iterator var2 = var1.iterator();</span><br><span class="line">        <span class="comment">//这里能看到 循环遍历变成了通过迭代器遍历</span></span><br><span class="line">        <span class="keyword">int</span> var3;</span><br><span class="line">        <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">            var3 = (Integer)var2.next();</span><br><span class="line">            System.out.println(var3);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] var7 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span>[] var3 = var7;</span><br><span class="line">        <span class="keyword">int</span> var4 = var7.length;</span><br><span class="line">        <span class="comment">// 数组的变成了普通的遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">            <span class="keyword">int</span> var6 = var3[var5];</span><br><span class="line">            System.out.println(var6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>循环遍历在普通容器中变成了迭代器遍历,在数组中变成了普通的for遍历.这也是为什么循环遍历的容器必须实现iterator接口的原因.</p><h2 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h2><p>变长参数其实就是一个数组,取决于你传入了几个参数.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable... objs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Closeable obj: objs)&#123;</span><br><span class="line">            obj.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>字节码反编译过后的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable... var0)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Closeable[] var1 = var0;</span><br><span class="line">        <span class="keyword">int</span> var2 = var0.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">            Closeable var4 = var1[var3];</span><br><span class="line">            var4.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>能够看到实际上objs就是一个数组,应该就是通过得到一个数组,然后在循环遍历.所以说尽量少用变长参数,因为变长参数会有一个内部的数组建立的过程,所以速度肯定会降低.</p><h2 id="int-short-优化"><a href="#int-short-优化" class="headerlink" title="int short 优化"></a>int short 优化</h2><p>平时编写代码的时候可能不注意,但是看的话会发现编译器做了很多优化,比如就是int优化,这也是不小心发现的.例如下面的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">128</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">255</span>;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">1000000</span>;</span><br><span class="line">        b+=<span class="number">10000000</span>;</span><br><span class="line">        <span class="keyword">char</span> g = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">double</span> e = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">double</span> f = <span class="number">1000000</span>;</span><br><span class="line">        System.out.println(a+b+c+d);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>编译过后<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> var1 = <span class="number">10</span>;    <span class="comment">//int a = 10;</span></span><br><span class="line">    <span class="keyword">short</span> var2 = <span class="number">128</span>;   <span class="comment">// int b = 128;</span></span><br><span class="line">    <span class="keyword">short</span> var3 = <span class="number">255</span>;  <span class="comment">// int c = 255;</span></span><br><span class="line">    <span class="keyword">int</span> var4 = <span class="number">1000000</span>;  <span class="comment">// int d = 1000000;</span></span><br><span class="line">    <span class="keyword">int</span> var10 = var2 + <span class="number">10000000</span>;  <span class="comment">// b+=10000000;  这里就是当数值变大了之后就会发现新申请了一个数值，之后变量var2的使用都变成了var10.</span></span><br><span class="line">    <span class="keyword">boolean</span> var5 = <span class="keyword">true</span>;  <span class="comment">//char g = 100;</span></span><br><span class="line">    <span class="keyword">double</span> var6 = <span class="number">20.0</span>D;  <span class="comment">//double e = 20;</span></span><br><span class="line">    <span class="keyword">double</span> var8 = <span class="number">1000000.0</span>D;  <span class="comment">//double f = 1000000;</span></span><br><span class="line">    System.out.println(var1 + var10 + var3 + var4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>可以看到当int的值比较小的时候可能会用byte或者short来代替int.<br>当此值变成比这个值更大的值的时候就能发现这个变量变了.var2变成var10,在之后用到var2的地方也都变成了var10.<br>但是细看这里的编译过后的代码就会发现一个问题,就是在char变量g变成了boolean类型.这里也就是编译器的第二个优化了.这里它会看此变量是否用过,如果在只有的程序中没有用过,那么就会赋值一个boolean类型.因为boolean类型可能是占用内存最小的了.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal概览</title>
      <link href="/2019/04/15/ThreadLocal%E6%A6%82%E8%A7%88/"/>
      <url>/2019/04/15/ThreadLocal%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h2 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h2><p>ThreadLocal是java中将非线程安全变为线程安全的一个神器.通过为每一个线程保存一个线程本地变量来保证数据的安全性,通过set()和get()方法来使用. 因为每个线程都拥有变量的副本.不和其他线程变量交互,所以不会出现线程安全问题.所以这里有一个点就是ThreadLocal应用的场景应该是变量的访问是没有依赖关系的,每个线程只和自己的数据副本打交道.    </p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//每个线程有自己的HashCode,并不是根据线程计算的,而是Local分配的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来计算下一个线程的hash值,threadLocalHashCode就是根据这个Integer计算出来的,每次增加一个一个HASH_INCREMENT的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">        <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">//hash增量,hash值的增量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看代码可以知道首先获取当前线程,然后通过getMap获取到一个ThreadLocalMap.如果当前线程存在map的话,就从map中取出当前线程所需要的值.注意这里getEntry中传入的是<strong>this</strong>,不是当前线程t.因为map中存储的是键值对是ThreadLocal变量与ThreadLocal变量存储的值的对应.<br>接下来看getMap方法</p><h3 id="getMap"><a href="#getMap" class="headerlink" title="getMap()"></a>getMap()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里就是获得线程自己的ThreadLocalMap.每个线程都有一个ThreadLocal变量.在初始的时候是空的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是线程中的ThreadLocalMap变量</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p><p>然后上面获取到的.如果获取到的map不是空的,说明已经设置过本地变量.因此就直接获取到此map的键值对.然后返回所要的值.<br>如果map为空,就通过setInitialValue()方法设置初始值.</p><h3 id="setInitialValue"><a href="#setInitialValue" class="headerlink" title="setInitialValue()"></a>setInitialValue()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T value = initialValue();</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是用来给子类继承的.在ThreadLoacl中SuppliedThreadLocal内部类继承了此类,用来实现这个方法.设置初始值</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个代码也很清晰明了了,如果当前线程有本地map,就直接添加默认值,如果没有,就使用createMap()创建一个</p><h3 id="createMap"><a href="#createMap" class="headerlink" title="createMap()"></a>createMap()</h3><p>创建Map其实就是给当前线程的ThreadLocal赋值.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>接下来细看一下ThreadLocalMap类的内部实现</p><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>在这里map中的Entry存储的key是一个ThreadLocal变量,值就是设置的值.这里有一点要搞明白.每个线程都有一个ThreadLocalMap的变量.通过这个变量能够找到当前线程存储的每个的ThreadLocal所对应的值.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里在说一下,这里使用的是弱引用.是为了让在线程将此值释放掉后能够让虚拟机进行回收,当线程本地释放变量的时候,不需要在对map进行主动移除,虚拟机就会自动回收掉无用变量.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            Object value;</span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//省略一些基本的map的操作与字段,里面也是使用数组来存储数据.使用线性探测来解决hash冲突.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>重点看一下getEntry,通过得到当前线程保存的ThreadLocal变量.然后在通过这个值找到对应表中的位置,在这里有一点可能会出现为空或者这个key值不是当前线程保存的本地ThreadLocal的变量的情况.通过在线性探测法遍历整个数组. 这里就有个问题了,在线性探测法中,如果自己原本的位置有数据,然后自己向推了一格.但是之后前面的节点又被删除了,这个时候就会出现找到的位置节点是空的情况.</p><p>在说线性探测法的缺陷改进之前,先看一下ThreadLocal的删除操作.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// 调用map的remove操作</span></span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// for循环.向后遍历找到,如果碰见空,则直接返回.如果遇见自己,则执行删除操作.</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">            e != <span class="keyword">null</span>;</span><br><span class="line">            e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面看到删除节点时候会调yoga此方法.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 先将数组中的两个值键值对设置为空,</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 设置size--</span></span><br><span class="line">    size--;</span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">            (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">            i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 如果此ThreadLocal为空,则删掉此项值</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这个方法大概意思就是在删除某个节点的时候,会判断在他后面的节点有多少个可以向前移动,如果可以向前移动,就向前移动(<strong>那些经过二次探测或者三次探测的节点才有可能向前移动</strong>).  直到碰见一个空节点位置.</p><p>删除讲完了,对于线性探测法的缺点的改进也就很容易明白了,不会出现那种情况.因为每一次删除一个节点.都会将之后的连续的不为空的节点向前移(<strong>这里向前移动最多移动到自己节点的hash值与上len值的位置</strong>).也就是把删除掉的那些空位给补上.</p><h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里set方法首先就获取当前线程,在获取一个ThreadLocalMap(),然后设置值</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里可能会有一些人对这个ThreadLocal还有点懵逼,通过一个完整的例子来看一下.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal1 = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure></p><p>比如说这里面有两个ThreadLocal,上面讲过,线程中存储的是一个ThreadLocalMap,map中存储的是ThreadLocal变量与值的映射.比如这里,线程中的threadLocalMap中会有两对键值对,一个是threadLocal的,另一个是threadLocal1的.当然,拥有这两个键值对的前提是调用了threadLocal.set()方法或者是get方法.如果调用了threadLocal.set(str)方法,那么就会在此线程的map中添加一个映射,就是threadLocal-&gt;str的映射.如果在获取的时候,通过获取线程的threadLocalMap,找到此threadLocal对应的值,就是此线程保存的这个threadLocal的值了.</p><p>ThreadLocal的实现原理主要就是通过每个线程保存一个ThreadLocalMap的变量,在ThreadLocal中保存的ThreadLoca =&gt; value 的键值对映射的一个map,通过找到线程对应的threadlocalmap,然后在从threadlocalmap中找到对应的threadlocal对应的值,就能够获取到对应的变量副本.</p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰器模式</title>
      <link href="/2019/04/15/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/15/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式就是动态地给一个对象添加一些额外的职责,扩展对象的功能.对于增加功能来说,装饰器模式比生成子类更为灵活.  </p><h2 id="装饰器模式的结构"><a href="#装饰器模式的结构" class="headerlink" title="装饰器模式的结构"></a>装饰器模式的结构</h2><p>通常来说,给一个对象添加一些额外的功能,可以通过继承来实现,但是这并不能动态地给对象添加职责,如果要添加一些职责,只能改变原有对象. 这时候就需要有装饰器模式出现了. 装饰器模式并不是利用继承和多态来扩展和复用功能,是基于对象组合的方式 .  </p><p>装饰器模式的角色有:</p><ol><li>抽象的对象角色    给出一个抽象接口,以规范准备接受附加功能的对象</li><li>具体的被装饰者    一个将要接受附加功能的具体实现,就是被装饰者,需要实现抽象的对象接口</li><li>装饰抽象类　　持有一个被装饰者的实例,并实现抽象对象接口,为具体的装饰功能提供一个统一的接口</li><li>具体装饰角色 就是具体的装饰对象,继承子装饰抽象类,是用来给被装饰者添加附加功能的.</li></ol><p>看类图:</p><p><img src="/2019/04/15/装饰器模式/Decorator.png" alt></p><p>装饰对象和被装饰对象实现的都是同一个接口,装饰对象也可以是一个接口,下面还可以有更多的具体的装饰对象.通过调用一个方法来装饰被装饰对象,以此来添加新的功能附件.</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>比如我们现在要实现一个给人动态添加服装的功能.<br><strong>首先定义一个接口,就是被装饰者实现的接口</strong> 里面有一个方法就是为人动态添加衣服<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>接着实现具体要穿衣服的人</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">(String name, String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setName(name);</span><br><span class="line">        <span class="keyword">super</span>.setSex(sex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"装扮"</span>+getName()+getSex());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>在实现装饰抽象类</strong> 定义一个统一的装饰接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decorator</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(person != <span class="keyword">null</span>)&#123;</span><br><span class="line">            person.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>具体装饰实现类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TShirts</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"穿T恤"</span>);</span><br><span class="line">        <span class="keyword">super</span>.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shorts</span> <span class="keyword">extends</span> <span class="title">Decorator</span>  </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"穿短裤"</span>);</span><br><span class="line">        <span class="keyword">super</span>.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person man = <span class="keyword">new</span> Man(<span class="string">"spj"</span>,<span class="string">"男"</span>);</span><br><span class="line">        TShirts shirts = <span class="keyword">new</span> TShirts();</span><br><span class="line">        Shorts shorts = <span class="keyword">new</span> Shorts();</span><br><span class="line">        shirts.decorator(man);</span><br><span class="line">        shorts.decorator(shirts);</span><br><span class="line">        shirts.show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出:</span><br><span class="line">穿短裤</span><br><span class="line">穿T恤</span><br><span class="line">装扮spj男</span><br></pre></td></tr></table></figure><p>这个例子中每一个装饰对象都会调用自己装饰的那个对象,这个样子其实有点像责任链模式,不过责任链是将消息传递出去,而装饰模式是修饰已经已有的对象,一层一层的装饰.为对象动态的添加功能,最后形成一个完整的有用的对象.  </p><p>在java中 输出输入流就是使用到了装饰器模式,在java中我们经常能见到这种写法.比如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"文件1"</span>);</span><br><span class="line">BufferedInputStream bfi = <span class="keyword">new</span> BufferedInputStream(in);</span><br><span class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(bfi);</span><br></pre></td></tr></table></figure></p><p>在这中写法中应该能够看出来这就是应用了装饰器模式,所有的这些输入流都继承InputStream类,通过一层一层的包装,来为输入流添加不同的功能.而他们每个类都有着上一层的一个实例对象,通过对此实例对象进行包装,就能够添加想要的功能.</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码阅读</title>
      <link href="/2019/04/14/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2019/04/14/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>java.util包下面的工具类,键值对存储数据.通过对键值计算hash值,来存储到对应的位置.<br>jdk1.8中底层使用数组加链表实现.键值对通过一个内部类的Node节点来表示.采用链地址法解决hash冲突,如果一条链上的节点超过给定阈值会变为红黑树.默认为8.<br>在hashmap中是可以存储空key和value的.如果为空,则位置为0.</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>hashmap继承了AbstractMap类,实现Map接口和克隆接口.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></p><h2 id="主要内部类"><a href="#主要内部类" class="headerlink" title="主要内部类"></a>主要内部类</h2><h3 id="Node-继承Map-Entry"><a href="#Node-继承Map-Entry" class="headerlink" title="Node  继承Map.Entry"></a>Node  继承Map.Entry</h3><ul><li>final int hash; 此节点保存的键值的hash值</li><li>final K key; 此节点的键</li><li>V value; 值</li><li>Node&lt;K,V&gt; next; 下一个节点,主要在有hash冲突的地方指向下一个几点<blockquote><p>Node(int hash, K key, V value, Node&lt;K,V&gt; next)  初始化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>这里计算hashCode是用key和value的hash值异或得到.<br>剩下的是获取键,获取值,设置值,equals等方法,比较简单</p><h3 id="KeySet"><a href="#KeySet" class="headerlink" title="KeySet"></a>KeySet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">//容量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="comment">//调用父类的clear函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="comment">//返回key的iterator</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> KeySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mc = modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="HashIterator"><a href="#HashIterator" class="headerlink" title="HashIterator"></a>HashIterator</h3><p>遍历map的迭代器,定义了遍历的基本操作.KeyIterator,ValueIterator和EntryIterator都继承自此类,在实现了一个返回Node的不同值.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">    <span class="comment">//期望的modcount,在遍历期间不希望有别的线程更改过此map,如果改过,则抛出异常</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">    <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化,找到第一个不为空的节点</span></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="keyword">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回下一个节点,</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        <span class="comment">//首先返回值应该是下一个要返回的节点</span></span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="comment">//这里在继续寻找下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移除节点使用外部类的方法移除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        K key = p.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul><li>DEFAULT_INITIAL_CAPACITY,    默认为16,初始化默认容量大小</li><li>MAXIMUM_CAPACITY,   最大容量大小 ,为 1&lt;&lt;30</li><li>DEFAULT_LOAD_FACTOR,   加载因子. 默认0.75</li><li>TREEIFY_THRESHOLD,      链表树化的阈值,超过这个值,链表转为红黑树.默认为8</li><li>UNTREEIFY_THRESHOLD,      红黑树转为链表的阈值,当红黑树的节点个数小于此值会变为链表.默认为6</li><li>MIN_TREEIFY_CAPACITY,      这个值就是最小的树化table数组的长度,如果数组长度小于这个值,则先不进行树化,先扩容来减少冲突.<h3 id="具体属性"><a href="#具体属性" class="headerlink" title="具体属性"></a>具体属性</h3></li><li>Node&lt;K,V&gt;[] table. 用来存放键值对的数组.</li><li>int size; 返回table存放了多少键值对,并不是table的长度</li><li>int modCount. 这个是在迭代的时候才会用到,因为hashMap的迭代器是fast-fail的.用这个值表示在此过程中是否有过改变,有过改变就抛出异常.</li><li>int threshold;  下一个数组长度</li><li>final float loadFactor; 加载因子</li></ul><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><p>这里一些简单的get(),set()就不说了,因为很简单.</p><h3 id="HashMap-int-initialCapacity-float-loadFactor"><a href="#HashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="HashMap(int initialCapacity, float loadFactor)"></a>HashMap(int initialCapacity, float loadFactor)</h3><p>初始化方法,这里只看这一个.其他的都是通过调用这个方法的.所以能看出来在初始化的时候真正的存数据的表并没有初始化.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化容量小于0,直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">//如果大于默认的最大容量,则为最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//这里就是计算出下一次的table的长度.</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="tableSizeFor-int-cap-方法"><a href="#tableSizeFor-int-cap-方法" class="headerlink" title="tableSizeFor(int cap) 方法"></a>tableSizeFor(int cap) 方法</h3><p>这个方法设计的很巧妙,通过5次移位运算可以返回一个大于等于cap的最小的2的n次方的数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  减一是为了防止cap本身就为2的n次方</span></span><br><span class="line">    <span class="comment">// 这里一个数字首先无符号右移1位,然后在或运算,会将他最高位为1的右边一位也变为1.</span></span><br><span class="line">    <span class="comment">// 比如随便来一个数字  为010010111000000...</span></span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//经过第一次运算后,很明显为1的最高位和下一位都为1.数字为 01101....</span></span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//第二次运算之后,这两位1在向右移动两位,现在最高位最少有4个1.为011110....</span></span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="comment">//以此类推,在最后右移16位的时候,最后会导致cap的最高位为1的位置之后的全部为1.很容易就找见了大于等于cap的最小的2的n次方的数</span></span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="hash-Object-key"><a href="#hash-Object-key" class="headerlink" title="hash(Object key)"></a>hash(Object key)</h3><p>计算key的hash值,通过高16位与上低16为保证每一位都能够参与运算.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict-方法"><a href="#putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict-方法" class="headerlink" title="putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)方法"></a>putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">//首先判断table是否为空,如果为空,则先resize扩容.</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">            <span class="comment">//判断key要存储的位置是否有Node.如果没有则直接插入.有的话向下走</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//这里表示每个table对应的位置有节点,发生冲突,向链表或者红黑树插入节点.</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//如果链首节点的hash值和key值都与要插入的值相等,则把将e指向该节点..</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">                <span class="comment">//如果这条链已经转化成了红黑树,则通过红黑树的插入方式插入</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//这里找到链表的最后一个节点,如果在找的过程中,遇到了和自己key一样的节点将e指向此节点.在插入后如果长度大于等于8则把链表转化为树</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里e指的是key与要插入的key相等的节点.所以这个时候会判断上面是否要求存在并替换,如果为false,则不替换</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                <span class="comment">//这个方法是给linkedHashMap用的,这里用不到</span></span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//modCount加1,表示这个时候被改过了.</span></span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">//这个方法也是个linkedHashMap用的,这里用不到,没有实现.</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h3><p>接着看resize()方法,在这里,resize总是将容量大小扩容到2的n次方大小,因为这个样子有利于rehash.还有利于找key在数组中的位置.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        <span class="comment">//保存下来旧的table.</span></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果旧的容量大于0,并且大于默认最大值也就是1&lt;&lt;30,threshold也就是下一次的要扩容到threshold大小.直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//新的容量变为原来的2被,新的threshold也变为原来的2倍,因为有一个tablesizefor()方法,导致hashMap的容量只能是2的n次方</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里是table还没有初始化的时候,等于之前的要扩容大小</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;           </span><br><span class="line">            <span class="comment">//如果oldThr也没有制定,则就是默认大小.</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//对于表中的没一个位置,复制到新表中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                        <span class="comment">//如果这个表中的节点是树的话,就用树的方式来写.</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; </span><br><span class="line">                        <span class="comment">//如果是链表的话,这里有一个小知识点,因为table的大小只能是2的n次方,所以在rehash的时候在一条链上的节点在rehash后,只能有两个位置,一个是本身i,另一个是i+oldTab.length;</span></span><br><span class="line">                        <span class="comment">//这里使用两个链表直接遍历所有的在链表上的节点,然后分为两个链表,最后给i和i+oldTab.length位置赋值</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">//如果hash与上旧的长度为0的话,说明这个节点的位置还在原处</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>扩容这里,旧的链表上的节点的位置只可能是i或者i+oldTab.length.为什么呢.举个例子.假如之前的链表长度为16,二进制为10000,现在变为32,就是100000;这个时候如果一个hash值为10的节点分别与16-1(1111)和32-1(11111)进行与运算,那么他们两个就只有可能有一位不一样,就是第5位.所以如果第5为是0,说明和以前的坐标一样,还在原位置,如果为1,则说明坐标位置应该在i+oldTabl.length的位置.</p><h3 id="removeNode-int-hash-Object-key-Object-value-boolean-matchValue-boolean-movable"><a href="#removeNode-int-hash-Object-key-Object-value-boolean-matchValue-boolean-movable" class="headerlink" title="removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable)"></a>removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable)</h3><p>移除一个节点.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//先找到key所在数组中的位置为(n-1)&amp;hash</span></span><br><span class="line">                <span class="comment">//保存一个node节点,节点表示的是要删除的节点,p表示要删除的前一个节点.</span></span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="comment">//具体删除操作,都能看懂</span></span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="public-boolean-containsValue-Object-value"><a href="#public-boolean-containsValue-Object-value" class="headerlink" title="public boolean containsValue(Object value)"></a>public boolean containsValue(Object value)</h3><p>containsValue主要就是遍历表中的节点,如果找到就返回true.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear()方法"></a>clear()方法</h3><p>简单,就是将table中的元素附空值.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java注解</title>
      <link href="/2019/04/13/java%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/04/13/java%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这两天在自己学习着写一个小型的web框架,有点像spring,但是有是轻量级的.里面用到的注解功能.但是对于自定义注解这块又不熟悉,所以专门学习了一波,做点笔记记下来.  </p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>注解是自带的.jdk中本身就有很多内置注解,比如override等等.注解的功能其实就是为一些加了注解的类,方法等赋予一些特别的含义.java中有4中元注解<br>@Target中的参数表示注解应该用在什么地方,参数类型有</p><ul><li>TYPE 类,接口(包括注解类型)或enum类型</li><li>FIELD 声明在字段上(包括enum实例)</li><li>METHOD,声明在方法上</li><li>PARAMETER,声明参数</li><li>CONSTRUCTOR,构造器的声明</li><li>LOCAL_VARIABLE,局部变量声明</li><li>ANNOTATION_TYPE,注解累心声明</li><li>PACKAGE,声明在包上</li></ul><p>@Rentention注解 表示需要在什么级别保存该注解信息,就是注解的生命周期.参数RetentionPolicy</p><ul><li>SOURCE 只保留在源文件中,被编译器丢弃</li><li>CLASS 注解在class文件中可用,但会被VM丢弃</li><li>RUNTIME 运行时保存,可以通过反射获得信息</li></ul><p>@Document 将注解包含在Javadoc中<br>@Inherited 允许子类继承父类中的注解  </p><p>举个例子,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">    <span class="meta">@interface</span> UseCases&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> "no description"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这是个声明在方法级别上的注解,使用了这个注解的方法,可以通过反射来获得注解中的内容.如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">beanUtil</span></span>&#123;</span><br><span class="line">    <span class="comment">//在这里使用了注解</span></span><br><span class="line">    <span class="meta">@UseCases</span>(id = <span class="string">"123"</span>,description = <span class="string">"123的description"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valipassword</span><span class="params">(String password)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (password.matches(<span class="string">"\\w*\\d\\w*"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UseCases</span>(id =<span class="string">"48"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encryptPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(password).reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面看测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; useCases = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Collections.addAll(useCases, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>);</span><br><span class="line">        trackUseCases(useCases, beanUtil.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trackUseCases</span><span class="params">(List&lt;Integer&gt; useCases, Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里通过反射获取到此对象的所有方法,并且在其中找到所有的使用此注解的方法.</span></span><br><span class="line">        <span class="keyword">for</span> (Method m : cl.getDeclaredMethods()) &#123;</span><br><span class="line">            <span class="comment">//获得注解的对象</span></span><br><span class="line">            UseCases uc = m.getAnnotation(UseCases.class);</span><br><span class="line">            <span class="keyword">if</span> (uc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Found Use Case:"</span> + uc.id() + <span class="string">" "</span></span><br><span class="line">                        + uc.description());</span><br><span class="line">                useCases.remove(<span class="keyword">new</span> Integer(uc.id()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">Found Use Case:<span class="number">123</span> <span class="number">123</span>的description</span><br><span class="line">Found Use Case:<span class="number">48</span> no description</span><br></pre></td></tr></table></figure></p><p>这里就完成了一个自定义注解的实现了.<br>在这里主要用到的就是两个  一个是@Target注解,里面指明了此注解要修饰的内容,例如构造器,方法,类等.还有一个是Retention注解,表明了此注解保存在哪里,有只在源码中存在,在class文件中存在,在运行时可以出现.如果要使用反射需要使用RUNTIME类型,在运行中通过反射来获得注解.<br><strong>注意</strong>:注解定义上的内容值允许有String ,基本类型,枚举类型,Annotation类型和Class类型</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>责任链模式</title>
      <link href="/2019/04/10/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/10/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>有多个对象, 每个对象都持有下一个对象的引用,这样就会形成一条责任链,请求在这条链上进行传递,知道某一对象决定处理该请求.但是发出者并不知道那个对象处理的请求.责任链模式的好处就是在隐瞒客户端的情况下,对系统进行动态的调整.<br>类结构图<br>三个继承了Handle的类组成了一个责任链,每个对象获取请求后都会看自己是否能处理,不能处理则放在最顶端.<br><img src="/2019/04/10/责任链模式/Client.png" alt></p><p><strong>handle抽象类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Handle successor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetSuccessor</span><span class="params">(Handle successor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor=successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">HandleRequest</span><span class="params">(<span class="keyword">int</span> request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>三个责任链上的对象</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandle1</span> <span class="keyword">extends</span> <span class="title">Handle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HandleRequest</span><span class="params">(<span class="keyword">int</span> request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(request&lt;<span class="number">10</span> &amp;&amp; request&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"concreteHandler1 处理请求"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            successor.HandleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandle2</span> <span class="keyword">extends</span> <span class="title">Handle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HandleRequest</span><span class="params">(<span class="keyword">int</span> request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(request&lt;<span class="number">20</span> &amp;&amp; request&gt;<span class="number">10</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"concreteHandler2 处理请求"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            successor.HandleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandle3</span> <span class="keyword">extends</span> <span class="title">Handle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HandleRequest</span><span class="params">(<span class="keyword">int</span> request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(request&lt;<span class="number">30</span> &amp;&amp; request&gt;<span class="number">20</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"concreteHandler3 处理请求"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            successor.HandleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里链上的对象分别处理不同的请求.</p><p><strong>客户端代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Handle h1 = <span class="keyword">new</span> ConcreteHandle1();</span><br><span class="line">        Handle h2 = <span class="keyword">new</span> ConcreteHandle2();</span><br><span class="line">        Handle h3 = <span class="keyword">new</span> ConcreteHandle3();</span><br><span class="line">        h1.SetSuccessor(h2);</span><br><span class="line">        h2.SetSuccessor(h3);</span><br><span class="line"></span><br><span class="line">        h1.HandleRequest(<span class="number">15</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里如果要改变处理流程,客户端代码完全可以不用改变,改变责任链上的某些对象就可以更改执行逻辑,这就是责任链模式.</p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式是用来降低类类之间的耦合的.就是将一个系统分割成许多对象,对象间的通信不彼此直接通讯,而是通过一个中介者来进行通信,进行协调对象之间的关系.如果使用直接依赖对象来进行通讯的话,如果要更改一个对象,那么和他有关联的对象都会更改.但是使用中介者模式的话,更改对象只需要改变他和中介的关系就可以了.具体的调度类或者通信通过中介来实现.     </p><p><img src="/2019/04/10/责任链模式/Colleague.png" alt>  </p><p>从类图中能够看出来两个colleague两个类之间没有关系,都是通过一个mediator类在中间协调,当这样子的类多了之后,更改起来就只需要更改mediator类就可以了,方便维护.  </p><p><strong>同事接口</strong><br>确保每一个类关联着mediator<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator mediator)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>具体同事类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealColleague1</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealColleague1</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        mediator.send(message,<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Notify</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"同事1获得消息"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealColleague2</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealColleague2</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        mediator.send(message,<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Notify</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"同事2获得消息"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>mediator类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message,Colleague colleague)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RealColleague1 colleague1;</span><br><span class="line">    <span class="keyword">private</span> RealColleague2 colleague2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColleague1</span><span class="params">(RealColleague1 colleague1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.colleague1 = colleague1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColleague2</span><span class="params">(RealColleague2 colleague2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.colleague2 = colleague2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message, Colleague colleague)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(colleague == colleague1)&#123;</span><br><span class="line">            colleague2.Notify(message);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            colleague1.Notify(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实中介模式就是实现了迪米特法则,也就是最小知道原则,对于自己依赖的类知道的越少越好,在中介这模式中,每个同事只需要知道一个中介就可以,干什么都和中介说,然后中介帮他去做事.降低耦合性. 但是中介这也有一个坏处,就是中介者的需要干的事情比较多,也就比较复杂,维护也是个不小的成本.</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8元空间</title>
      <link href="/2019/04/09/java8%E7%9A%84%E5%86%85%E5%AD%98%E6%94%B9%E5%8F%98/"/>
      <url>/2019/04/09/java8%E7%9A%84%E5%86%85%E5%AD%98%E6%94%B9%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-8元空间"><a href="#Java-8元空间" class="headerlink" title="Java 8元空间"></a>Java 8元空间</h2><p>今天想要测试方法区空间溢出会怎么样,然后调试了半天.使用String,静态变量,发现最后都是heap space OOM,经过一番学习,发现一些Java 8 中的一些改变.记录一下.<br>在java 8中方法区也就是永久代已经是不存在了,出现了一个替代者:元空间.</p><h2 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h2><p>Java　8Hotpot JVM开始使用本地化的内存存放类的元数据,这个空间也叫作元空间(Metaspace).它存储在native heap中,不受jvm内存限制,仅仅只受本地内存的限制.<br>Java Hotpot明确了元数据空间从操作系统请求空间,然后将其分成块.每个类加载器有一个块.类加载器从其块中为元数据分配空间.当类加载器卸载掉类的时候,它的块会被循环使用,或者会被操作系统回收.元数据一般使用一种内存映射文件的方法分配的空间,而不是malloc申请的空间.</p><p>这个样子的话就是表示着一个让人烦恼的问题也就是java.lang.OutOfMemoryError: PermGen的问题将不会存在.并且不需要在调整和监控这个内存空间.但是这个改变并不会消除类和类加载器的内存泄露,而是需要以一些不同的方式和学习新名词来追查这些问题.  </p><ul><li>-XX:MetaspaceSize 初始元空间大小,达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整,如果释放了大量空间,就适当减少,如果释放了很少的空间,在不超过MaxMetaspaceSize时可以增加.</li><li>-XX:MaxMetaspaceSize 最大的元空间大小,元空间大小不得超过这个值,如果超过会抛出OOM异常</li><li>-XX:MinMetaspaceFreeRatio 在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</li><li>-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</li></ul><p><strong>永久区的情况</strong></p><ul><li>永久代被完全移除</li><li>JVM参数PermSize和MaxPermSize也会被忽略.</li></ul><p><strong>元空间内存分配模型</strong></p><ul><li>绝大多数的类元数据的空间都从本地内存分配.</li><li>每个类加载器分配一个内存块的列表.</li><li>这个内存块是连续分配的.</li><li>元空间主要存储类信息,常量池,方法数据以及方法代码<!--  -->从JDK7开始就进行移除永久代的准备 比如进行如下改变</li><li>符号引用转换到了native heap中</li><li>字面量常量(String)分配到java heap中</li><li>类的静态变量转移到了java heap中</li></ul><p>在JDK8中则是完全移除了永久代 连带着设置永久代大小的参数也被移除,取而代之的是一个Metaspace,这些空间直接在堆上进行分配.<br>为什么这么更改呢: 总结一下: </p><ul><li>首先是为了融合Hotpot JVM和JRockit VM而做出的努力,因为JRockit没有永久代</li><li>字符串存放在永久代,很容易出现性能问题和内存溢出.</li><li>类即方法信息难以确定大小,尤其是现在大多数的动态代理.而永久代的大小指定比较困难,大小容易出现永久代溢出,太大会导致老年代溢出</li><li>永久代对于GC不方便,而且效率比较低</li></ul><p><strong>元空间的优势</strong></p><ul><li>以前的jar包以及自己项目的class放在永久代中,但是永久代大小固定,所以经常可能出现永久代溢出.</li><li>永久代溢出将会不存在,元空间直接与放在本地堆中,大小可以动态增长</li><li>使用元空间后,每个项目都会共享可用的class内存空间,元空间中的class可以被多个项目使用,以前的永久代则是每个项目都有自己的永久代,并且用独立的class对象</li></ul><p><strong>元空间的容量</strong></p><ul><li>默认情况下，类元数据分配受到可用的本机内存容量的限制（容量依然取决于你使用32位JVM还是64位操作系统的虚拟内存的可用性</li><li>新参数 MaxMetaspaceSize被使用,允许限制类元数据的最大本地内存,如果没有指定,会根据程序运行情况动态设置<br><strong>元空间垃圾回收</strong></li><li>如果元空间的中的元数据达到参数”MaxMetaspaceSize”设置的值,才会触发对死亡对象和类加载器的垃圾回收</li><li>元空间中的对象的位置是固定的</li><li>元空间不会单独回收某个类</li><li>元空间提高了GC的性能,省掉了GC扫描的时间.</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/2019/04/09/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/09/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式主要是用来将某个类的接口转换成客户端期望的另一个接口的形式.目的用于消除接口的不兼容问题,主要分为三类,接口的适配器模式,类的适配器模式,对象的适配器模式.  </p><h3 id="类的适配器模式"><a href="#类的适配器模式" class="headerlink" title="类的适配器模式"></a>类的适配器模式</h3><p><img src="/2019/04/09/适配器模式/Adapter.png" alt></p><p>源类 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"source的方法1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>目标类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;<span class="comment">//与source一样</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>适配器: 继承自源类,并实现目标接口,就完成了适配功能.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Source</span> <span class="keyword">implements</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"targetable的method2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样实现了target的类就有了source的类的功能.</p><h3 id="对象的适配器模式"><a href="#对象的适配器模式" class="headerlink" title="对象的适配器模式;"></a>对象的适配器模式;</h3><p>与类的适配器模式差不多,只是在将继承原有类变成了持有原有类.也可以实现相同的功能. 前两个类就不在写了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Source source ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Source source)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"targetable的method2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        source.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="接口的适配器模式"><a href="#接口的适配器模式" class="headerlink" title="接口的适配器模式"></a>接口的适配器模式</h3><p>对于接口的适配器模式主要有一种情况就是在接口的方法有很多,但是我们可能只需要几个方法,这个时候就需要一个接口的适配器出现了.写一个接口的适配器抽象类,实现接口的所有方法,当然方法也是空方法,这时候具体类就可以继承此抽象类.实现自己想要实现的方法.</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/2019/04/09/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/09/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>就是讲一个复杂对象的构建与它的表示分离,是的同样的构建过程可以创建不同的表示.<br>如果我们使用了建造者模式,用户只需要指定需要构造的类型就可以得到它们,而具体建造的过程和细节就不需要知道.<br>在这里建造者类是为了表示要建造的对象的不同种类.通过多个建造类可以实现建造一个种类的不同对象.<br>指挥者主要是为了防止在建造的时候出错,因为建造的时候可能会有很多步骤或者顺序,防止步骤缺失或者顺序相反.起到一个管理的作用  </p><p>举例:</p><h3 id="要建造的对象"><a href="#要建造的对象" class="headerlink" title="要建造的对象:"></a>要建造的对象:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String head;</span><br><span class="line">    <span class="keyword">private</span> String body;</span><br><span class="line">    <span class="keyword">private</span> String arm;</span><br><span class="line">    <span class="keyword">private</span> String leg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略get和set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="建造对象抽象类"><a href="#建造对象抽象类" class="headerlink" title="建造对象抽象类"></a>建造对象抽象类</h3><p>定义了建造对象的主要方法,方便子类继承.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Person person;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonBuilder</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildHead</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBody</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildArm</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildLeg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="具体建造实现类"><a href="#具体建造实现类" class="headerlink" title="具体建造实现类"></a>具体建造实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//瘦子类,定义瘦人的属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThinPersonBuilder</span> <span class="keyword">extends</span> <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThinPersonBuilder</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.setHead(<span class="string">"头"</span>);</span><br><span class="line">        System.out.println(<span class="string">"建造瘦子的头"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.setBody(<span class="string">"身体"</span>);</span><br><span class="line">        System.out.println(<span class="string">"建造瘦子的身体"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildArm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.setArm(<span class="string">"胳膊"</span>);</span><br><span class="line">        System.out.println(<span class="string">"建造瘦子的胳膊"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildLeg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.setLeg(<span class="string">"腿"</span>);</span><br><span class="line">        System.out.println(<span class="string">"建造瘦子的腿"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//高个类,定义高个子的属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighPersonBuilder</span> <span class="keyword">extends</span> <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HighPersonBuilder</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"建造高个的头"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"建造高个的身体"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildArm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"建造高个的胳膊"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildLeg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"建造高个的腿"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们已经把建造类写完了,但是当我们想要建造一个类的时候会在逻辑代码中写大量的如此类的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">        personBuilder.buildArm();</span><br><span class="line">        personBuilder.buildHead();</span><br><span class="line">        personBuilder.buildBody();</span><br><span class="line">        personBuilder.buildLeg();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个样子更改起来特别繁琐,这个时候就有了我们的指挥者出场了.只会这封装了建造的过程与逻辑.接下里看指挥者:</p><h3 id="指挥者"><a href="#指挥者" class="headerlink" title="指挥者"></a>指挥者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDirector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PersonBuilder personBuilder ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonDirector</span><span class="params">(PersonBuilder  pb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personBuilder = pb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">        personBuilder.buildArm();</span><br><span class="line">        personBuilder.buildHead();</span><br><span class="line">        personBuilder.buildBody();</span><br><span class="line">        personBuilder.buildLeg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过指挥者封装的建造代码,我们完全不必要知道建造的具体细节,只需要把产品的属性就是建造类给它就可以创建出一个完好的对象.    </p><p><strong>如果没有指挥者类,直接在建造者类中添加逻辑可以吗</strong><br>这里简单说一下我自己的理解吧,如果没有指挥者类,那么如果在有一个新的需求的话,比如说我要建造一个穿有衣服的人,那么这个时候就必须去更改Build()的源代码,违反了开闭原则.如果有一个指挥者类,要在创建一种结构的话,只需要在加一个新的指挥者类,指挥不同的创建方式就可以了.</p><h3 id="好处与使用场景"><a href="#好处与使用场景" class="headerlink" title="好处与使用场景"></a>好处与使用场景</h3><p>建造这模式主要用在创建一些复杂的对象,并且这些对象内部构建间的建造顺序通常是稳定的,但对象内部的构建通常面临这复杂的变化.它是的建造代码与表示代码分离,由于建造者隐藏了该产品是如何组装的,所以若需要改变一个产品的内部表示,只需要再定义一个具体的建造者就可以了.</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/2019/04/08/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/08/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式就是定义一系列的算法,并且将算法封装起来,使他们可以相互替换,并且算法的替换不会使用客户端,需要设计一个接口,为一系列实现提供一个统一的方法,多个实现类实现该j接口,设计一个抽象类,提供辅助函数.<br>从概念来看,所有的算法完成的都是相同的工作,只是实现不同.在一个上下文中完成对算法的改变,每次要新增一个算法只需要在新增一个实现类就可以<br><img src="/2019/04/08/策略模式/类图.png" alt></p><p>具体例子:</p><h2 id="抽象接口"><a href="#抽象接口" class="headerlink" title="抽象接口:"></a>抽象接口:</h2><p>封装了算法对外的同意接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sort</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="具体实现类"><a href="#具体实现类" class="headerlink" title="具体实现类:"></a>具体实现类:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        quicksort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">        <span class="comment">//具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h2><p>使用算法全都这里使用,如果想要调用不同的算法,只需要传入相应的对象即可改变算法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    Sort sort;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Sort sort)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sort = sort;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ContextInterface</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        sort.sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结 :<br>策略模式主要是封装了变化,当不同的行为对其在一个类中时,就可能会有很多的条件语句,可读性不高.所以可以将这些行为封装在独立的类中,在使用行为的类来增强代码可读性.</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2019/04/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式在很多应用程序中有很多应用.比如说一个全局的工厂,一个threadlocal等等.要实现一个好的单利对象有很多种方法,可以挑选自己最喜欢的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉式 在不要求一些性能方面可以这个样子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Simple instance = <span class="keyword">new</span> Simple();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Simple</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Simple <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进阶 懒汉式 此方法可能导致并发的时候出现故障,比如很多线程在同事使用Two</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Two instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Two</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Two <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Two();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进阶 懒汉式 线程同步 这个线程同步没问题,但是会导致争用过大</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Three</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Three instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Three</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Three <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Three();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进阶 良好的线程同步 双重检查</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Four</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Four instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Four</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Four <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (instance)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance=<span class="keyword">new</span> Four();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内部类,懒汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Five</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Five</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleFactory</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Five instance = <span class="keyword">new</span> Five();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Five <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingleFactory.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举的单例模式 jdk1.5以后推荐</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂方法模式</title>
      <link href="/2019/04/08/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/08/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>在简单工厂模式中有个坏处就是,类的创建需要依赖工厂,也就是说如果要扩展类的功能需要对工厂类进行修改,这违背了开闭原则,所以从设计考虑,有一定问题.所以有了工厂方法模式,创建一个工厂接口和多个工厂实现类,这样一旦需要增加新的功能,直接增加工厂类就可以了,不需要修改以前的代码,只需要在添加一个工厂类.符合开闭原则.<br><img src="/2019/04/08/工厂方法模式/类图.jpg" alt><br>举例:</p><h2 id="类接口"><a href="#类接口" class="headerlink" title="类接口:"></a>类接口:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类:"></a>实现类:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"mailsender"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SmsSender"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂接口"><a href="#工厂接口" class="headerlink" title="工厂接口:"></a>工厂接口:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">getSender</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂实现类"><a href="#工厂实现类" class="headerlink" title="工厂实现类:"></a>工厂实现类:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSendFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">getSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSendFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">getSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~ </span><br><span class="line"></span><br><span class="line">## 测试</span><br><span class="line">~~~java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Provider provider = <span class="keyword">new</span> MailSendFactory();</span><br><span class="line">        Sender sender = provider.getSender();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这样做的好处就是完全解耦合,当需要不同的产品是只需要改变一下工厂类即可,其余的都可以不需要改.</span></span><br></pre></td></tr></table></figure><p>这个样子就可以在扩展的时候不需要修改之前的程序就可以添加扩展功能了.这样做的好处就是扩展性好,在添加新功能的时候只需要实现一个类,实现Sender接口,然后在做一个实现工厂,实现Provider接口,就可以了.<br>借鉴与<a href="https://www.cnblogs.com/geek6/p/3951677.html" target="_blank" rel="noopener">https://www.cnblogs.com/geek6/p/3951677.html</a></p><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式与工厂模式的区别不好区分.<br>抽象工厂模式是提供一个创建一系列相关或相互依赖对象的接口,而无需制定他们具体的类.<br>抽象工厂模式的好处就是易于交换产品系列,由于具体工厂类在一个应用中一般只需要出现一次(就像Provider = new MailSendFactory()). 这就使得改变一个应用的具体工厂编的非常容易,只需要改变具体工厂即可使用不用的产品配置.<br>抽象工厂模式与工厂方法模式的不同:　　　<br>工厂方法模式:  </p><ul><li>一个抽象产品类可以派生出多个具体产品类</li><li>一个抽象工厂类可以派生出多个具体工厂类</li><li>每个具体工厂类也只能派生出一个具体产品类<br>抽象工厂模式:　　　</li><li>多个抽象产品类，每个抽象产品类可以派生出多个具体产品类</li><li>一个抽象工厂类．可以派生出多个具体工厂类</li><li>每个具体工厂类可以创建多个具体的产品类的实例.  </li></ul><p><img src="/2019/04/08/工厂方法模式/抽象工厂模式.png" alt><br>举个例子: </p><h2 id="多个抽象产品类"><a href="#多个抽象产品类" class="headerlink" title="多个抽象产品类"></a>多个抽象产品类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Recived</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recived</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂抽象类"><a href="#工厂抽象类" class="headerlink" title="工厂抽象类"></a>工厂抽象类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">getSender</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Reviced 与这个一样,就不写了.</span></span><br></pre></td></tr></table></figure><h2 id="工厂实现类-1"><a href="#工厂实现类-1" class="headerlink" title="工厂实现类:"></a>工厂实现类:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSendFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">getSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSendFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">getSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 多个实现类</span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"mailsender"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailRecived</span> <span class="keyword">implements</span> <span class="title">Recived</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recived</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"mailRecived"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsRecived</span> <span class="keyword">implements</span> <span class="title">Recived</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recived</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"smsRecived"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SmsSender"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##　测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Provider provider = <span class="keyword">new</span> MailSendFactory();</span><br><span class="line">        Recived recived = provider.getRecived();</span><br><span class="line">        Sender sender = provider.getSender();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里如果想要使用mailSend邮件协议只需要改变上面那个工厂就可以在下面整体替换邮件系统.这样子给程序的扩展性与改变性提供了更好的方法.</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单工厂模式</title>
      <link href="/2019/04/07/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/07/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>在说简单工厂模式之前首先说一下设计模式的分类以及基本原则.</p><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p>总体来说设计模式总共分为三大类:<br>创建型模式:共5种,工厂方法模式,抽象工厂模式,单例模式,建造者模式,原型模式<br>结构性模式:共7种,适配器模式,装饰器模式,代理模式,外观模式,桥接模式,组合模式,享元模式<br>行为型模式:共11中,策略模式,模板方法模式,观察者模式,迭代子模式,责任链模式,命令模式,备忘录模式,状态模式,访问这模式,中介模式,解释器模式.</p><h2 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h2><h3 id="总原则-开闭原则"><a href="#总原则-开闭原则" class="headerlink" title="总原则:开闭原则"></a><strong>总原则:开闭原则</strong></h3><p>开闭原则就是说对扩展开放,对更改关闭.在程序需要扩展的时候不去更改原有的代码,而是增加新的代码,实现一个热插拔的效果.所以一句话就是为了是程序的扩展性好,易于维护和升级.  </p><ol><li>单一职责原则<br>不要存在多余一个导致类变更的原因,也就是说一个类应该只实现一个功能,如果不然,应该把类拆开.</li><li>里氏替换原则(LSP) 是面向对象的基本原则之一,此原则是说任何基类可以出现的地方其子类一定也可以出现.LSP是继承复用的基石,只有当衍生类能够替换掉基类,并且软件功能不受影响时,基类才能真正的被复用,而衍生类也能在基类的基础上增加一些新的功能.里氏替换原则是对开闭原则的补充.实现开闭原则的的关键步骤就是抽象画,而基类与子类的继承关系就是抽象的具体实现.<br>在里氏替换原则中,子类对父类的的方法尽量不要重写与重载.因为父类定义了一个良好的对外的接口,通过这个接口可以与外界更好的交互.子类不应该随便破坏它.</li><li>依赖倒转原则: 这是开闭原则的基础.主要是面向接口编程,依赖抽象而不依赖具体,写代码用到具体类时,不与具体类交互,而与上层接口交互.</li><li>接口隔离原则: 每个接口中不存在子类用不到的方法,如果有,则应该将接口分开为两个.</li><li>最少知道原则: 一个类对自己依赖的对象知道的越少越好,也就是说无论依赖的对象有多复杂,都应该将实现封装在方法的内部,通过public提供给外界,这样当被依赖的对象变化时候,才能最少的影响该类.</li><li>合成复用原则: 首先使用组合/聚合的方式,而不是使用继承.</li></ol><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式:"></a>简单工厂模式:</h2><p>简单工厂模式按理来说不属于23中设计模式,但是使用的却挺多的.<br>简单工厂模式主要有三种实现.</p><h3 id="第一种-最普通"><a href="#第一种-最普通" class="headerlink" title="第一种 最普通:"></a>第一种 最普通:</h3><p>创建共同的接口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后有两个类实现这个接口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send1</span> <span class="keyword">implements</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是send1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">send2</span> <span class="keyword">implements</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是send2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在创建工厂类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Send <span class="title">getProduce</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"send1"</span>.equals(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Send1();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"send2"</span>.equals(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> send2();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"输入正确类型"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个是测试</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SendFactory sendFactory = <span class="keyword">new</span> SendFactory();</span><br><span class="line">        Send send = sendFactory.getProduce(<span class="string">"send1"</span>);</span><br><span class="line">        send.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里只需要传入相对应的参数就可以返回相应的类. 但是这样子有点不好就是如果类的种类变多将会使得代码变得难以维护与扩展.</p><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>将创建每个类变成多个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactoryTwo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Send <span class="title">getSend1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Send1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Send <span class="title">getSend2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> send2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此种方法比第一种方法要更好一些,因为这里通过方法名来返回实例,比普通的要更好一点.</p><p>###　第三种<br>将方法变为静态的．这样不需要建立工厂类就可以调用返回响应的方法．<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactoryTwo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Send <span class="title">getSend1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Send1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Send <span class="title">getSend2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> send2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建.</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized详解</title>
      <link href="/2019/04/06/synchronized%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/04/06/synchronized%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h3><ul><li>修饰普通方法,锁的是当前的实例对象</li><li>静态同步方法,锁的是当前类的class对象</li><li>修饰代码块,锁的是括号中的实例对象</li></ul><h4 id="java对象头-monitor"><a href="#java对象头-monitor" class="headerlink" title="java对象头 monitor"></a>java对象头 monitor</h4><h5 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h5><p>synchronized 用的锁都是java对象头中的.hotpot虚拟机中对象头主要包括两部分数据:mark word(标记字段)和klass Point(类型指针).类型指针是指向它类元数据的指针,虚拟机通过这个指针来确定对象属于那个类的实例.标记字段用来存储对象自身的运行时数据,是实现偏向锁和轻量级锁的关键.<br>标记字段:<br>用于存储对象自身的运行时数据,如哈希码(HashCode) GC分代年龄 锁状态标志 线程持有的锁 偏向线程ID 偏向时间戳等.<br>考虑到虚拟机的空间效率问题,标记字段被设计成一个非固定的数据结构以便在极小的空间存储更多的数据.会根据对象的状态复用自己的存储空间.<br><img src="/2019/04/06/synchronized详解/对象头.jpeg" alt></p><h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><p>monitor可以理解为一个同步工具,或者说是一种同步机制,被描述为一个对象.<br>所有的java对象是天生的Monitor,每个对象都有成为Monitor的潜力,在java设计中,每个java对象天生有一把看不见的锁,叫内部锁或Monitor锁.<br>Monitor锁是线程私有的数据结构,每个线程有一个monitor record列表,还有一个可用的全局列表每个被锁住的对象都会和一个monitor关联.同时monitor中有一个Owner字段 存放拥有该锁的线程的唯一标识,标识该锁被这个线程占用. </p><ul><li>每个对象都有一个monitor(监视器锁).当monitor被占用时就会处于被锁定状态,在线程进入被同步的代码块时,会首先请求获取monitor的所有权,获取不到则会阻塞.<br><img src="/2019/04/06/synchronized详解/monitor数据结构.png" alt><br>owner 初始为NULL,标识没有任何线程拥有该monitor,线程成功拥有该锁保后存该线程唯一标识,释放之后会有设置为NULL<br>EntryQ: 关联一个系统互斥锁,阻塞所有试图获得monitor失败的线程<br>RcThis 表示阻塞或waiting在该monitor上的线程个数<br>Nest 用来实现可重入锁的计数<br>HashCode 保存从对象头上copy过来的哈希码(可能还有GC age)<br>Candidate 用来避免不必要的阻塞或等待线程唤醒,每次只能有一个线程能成功用有锁,如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程,会引起不必要的上下文切换,浪费系统开销,.Candidate只有两种值,0表示没有需要唤醒的线程,1 表示要唤醒一个继任线程来竞争锁.</li></ul><h3 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h3><ol><li>轻量级加锁<br>(1). 在代码进入同步块时候,如果对象锁状态为无所状态,,虚拟机在栈中建立一个名为锁记录(Lock record)的空间,用于存储对象当前mark word字段,<br>(2). 拷贝成功后,会通过CAS操作尝试将对象的mark word 更新为指向(lock record)的指针,并且将lock record的owner指针指向Object mark word,<br>(3).如果更新成功,说明这个线程拥有了该对象的锁,并且将mark word的标志位设置为00,表示此对象处于轻量级锁定状态<br>(4). 如果更新不成功,首先会检查mark word是否指向的是当前线程的栈帧,如果是说明线程拥有锁,如果不是,说明多个线程竞争锁,会膨胀为重量级锁,设置锁标志位为10,mark word存储指向重量级锁的指针,后面获取锁的都会进入阻塞状态   </li><li>轻量级解锁:<br> (1). 通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word。<br> (2). 如果替换成功,同步完成<br> (3). 如果不成功变为重量级锁,在释放锁的时候唤醒被挂起的线程</li><li>偏向锁加锁<ol><li>访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态</li><li>如果为可偏向状态，则测试线程ID是否指向当前线程.如果是,进入(5),不是进入(3)</li><li>如果线程ID并未指向当前线程，则通过CAS操作竞争锁。(这里CAS替换是换mark 替word中的线程ID,如果没有竞争,则会成功,如果有竞争,肯定有一个线程失败,这个失败的线程则会将锁升级为轻量级锁).如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）,如果竞争失败，执行（4）。  </li><li>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码  </li><li>执行同步代码</li></ol></li><li>偏向锁解锁<br>解锁主要就是到达一个全局安全点,首先暂停拥有偏向锁的线程,然后检查拥有偏向锁的线程是否或者,如果不活着,则设置为无锁状态,如果活着,拥有偏向锁的栈会被执行,遍历偏向对象的锁记录,占中的锁记录和对象头的mark word要么重新偏向于其他线程,要么恢复到无锁活着标记对象不合适作为偏向锁,最后唤醒暂停的线程.<br><img src="/2019/04/06/synchronized详解/java加锁解锁.png" alt></li></ol>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile详解</title>
      <link href="/2019/04/06/volatile%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/04/06/volatile%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="volatile的定义与实现原理"><a href="#volatile的定义与实现原理" class="headerlink" title="volatile的定义与实现原理"></a>volatile的定义与实现原理</h3><p>在java语言规范第三版中对volatile的定义如下:Java编程语言允许线程访问共享变量,为了保存共享变量能够被准确和一致的更新,线程应该确保通过排它锁单独获得这个变量.<br>java线程内存模型确保所有线程看到这个变量的值是一致的.<br>在了解volatile实现原理之前,要先看cpu术语与说明  : </p><ul><li>内存屏障(memory barriers) 一组处理器指令,用于实现对内存操作的顺序限制</li><li>缓冲行( cache line) cpu告诉缓存中可以分配的最小存储单位.处理器填写缓存行时会加载整个缓存行  </li><li>原子操作: 不可中断的一个或一系列操作</li><li>缓存行填充: 当处理器识别到从内存中读取操作数是可以缓存的,处理器就读取整个高速缓存行到适当的缓存  </li></ul><p>在java中,在对volatile变量进行写操作时候,会有lock指令,此lock指令会使得处理器发生两件事情</p><ul><li>将当前处理器缓存行的数据写会到系统内存</li><li>这个写回内存的操作会使其他cpu里缓存了该内存地址的数据无效<br>在这里为了提高处理速度,处理器不直接与内存直接通信,会首先将系统内存的数据读取到内部缓存后在进行操作.如果是普通变量,操作完不知道什么时候会写会内存,但是如果声明了volatile变量,则会立刻把缓存行的数据写会到系统内存.并且在多处理器下,为了保证各个处理器的缓存是一致的,会实现缓存一致性协议,每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是否过期,当处理器发现自己缓存行对应的内存地址被修改,就会将当前处理器的缓存行置为无效.  </li></ul><p><strong>volatile还有一个功能是禁止指令的重排序.</strong><br>在程序执行过程中存在三种重排序</p><ol><li>编译器优化的重排序,编译器在不改变单线程程序语义下,可以重新安排语句的执行顺序</li><li>指令级并行的重排序,现代处理器采用指令级并行技术将多条执行重叠执行,如果没有数据依赖性,可以改变语句对应执行的执行顺序</li><li>内存系统的重排序,由于处理器使用缓存和读/写缓冲区,是的加载和存储操作可能是在乱序执行<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>; <span class="number">1</span></span><br><span class="line"><span class="keyword">int</span> a = c; <span class="number">2</span></span><br><span class="line"> <span class="comment">//这里在其他线程看来可能2发生在1的前面,以为这里有缓存一说,所以就有了给b赋值,但是还没有被刷新回主存,但是a=c已经从内存中读取了,在这种情况下,可能会出现内存系统的重排序</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="volatile对于重排序的规定"><a href="#volatile对于重排序的规定" class="headerlink" title="volatile对于重排序的规定"></a>volatile对于重排序的规定</h3><p>当写一个volatile变量的时候,JMM会把该线程对应的本地内存中的共享变量值刷新会主存.当读一个volatile变量时,JMM会把该线程对应的本地内存置为无效,线程接下来将从主内存中读取共享变量</p><ul><li>对于volatile写之前的操作不允许放在volatile之后</li><li>对于valatile读之后的所有操作不允许放在volatile之前</li><li>一个普通变量的写可以被重排序到volatile变量的写之前</li></ul><p>在对一个普通变量的单个读/写操作,与一个普通变量的读/写操作都是使用同一个锁同步来说执行效果相同. 这是在jdk1.5之后增强了volatile关键字的语义,这个语义保证了对单个volatile变量的读/写具有原子性.<br>volatile变量自身拥有如下特性:</p><ul><li>可见性: 对一个volatile变量的读,总是能看到对这个变量的最后写入</li><li>原子性: 对任意单个变量的读/写具有原子性,但是类似于volatile这种复合操作不具有原子性;</li></ul><p>###　内存屏障</p><ul><li>StoreStore 确保之前的写操作先行与之后的写操作</li><li>LoadLoad 确保之前的读操作先于之后所有的读操作</li><li>LoadStore 确保之前的读操作先行与之后所有的写操作</li><li>StoreLoad 确保之前的写操作先行与之后所有的读操作</li></ul><p>JMM在会在使用了volatile的变量使用之前之后加入不同的内存屏障来禁止指令的重排序.保证了单个变量的原子性与可见性.</p><ul><li>在每个volatile写操作之前插入一个storeStore屏障</li><li>在每个volatile写操作之后插入一个StoreLoad屏障</li><li>在每个volatile读操作之前插入一个LoadLoad屏障</li><li>在每个volatile读操作之后插入一个LoadStore屏障</li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReentrantLock源码解读</title>
      <link href="/2019/04/06/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/04/06/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="RentrantLock总览"><a href="#RentrantLock总览" class="headerlink" title="RentrantLock总览"></a>RentrantLock总览</h2><p>ReentrantLock是一个独占式的锁,支持重入.里面实现了公平锁与非公平锁;<br><img src="/2019/04/06/ReentrantLock源码解读/ReentrantLock.png" alt><br>其中ReentrantLock支持可公平锁与非公平锁,最顶层的父类是AQS.获取锁阻塞释放全部都是通过AQS来实现.接下来详细说明这些是怎么实现的. </p><h2 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h2><p>继承自AQS  </p><h3 id="abstract-void-lock"><a href="#abstract-void-lock" class="headerlink" title="abstract void lock();"></a>abstract void lock();</h3><p>抽象方法,让子类也就是两个公平和非公平类来实现.</p><h3 id="boolean-nonfairTryAcquire-int-acquires"><a href="#boolean-nonfairTryAcquire-int-acquires" class="headerlink" title="boolean nonfairTryAcquire(int acquires) ;"></a>boolean nonfairTryAcquire(int acquires) ;</h3><p>此为尝试获取非公平锁,非公平锁的实现就是首先CAS替换看自己是否能够获得锁,如果能够获得,则设置为拥有锁,如果不行,返回false;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">               <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">               <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="boolean-tryRelease-int-releases"><a href="#boolean-tryRelease-int-releases" class="headerlink" title="boolean tryRelease(int releases)"></a>boolean tryRelease(int releases)</h3><p>释放掉指定的资源.如果当前线程没有拥有锁,则抛出异常.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">           <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">           <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               free = <span class="keyword">true</span>;</span><br><span class="line">               <span class="comment">//用来设置获得锁的线程的方法</span></span><br><span class="line">               setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           setState(c);<span class="comment">//设置状态,状态为0,表示没有线程获得锁</span></span><br><span class="line">           <span class="keyword">return</span> free;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="boolean-isHeldExclusively"><a href="#boolean-isHeldExclusively" class="headerlink" title="boolean isHeldExclusively()"></a>boolean isHeldExclusively()</h3><p>表明当前线程是否是独占锁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// While we must in general read state before owner,</span></span><br><span class="line">    <span class="comment">// we don't need to do so to check if current thread is owner</span></span><br><span class="line">    <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p>ReentrantLock实现了两种锁,一种是非公平的,一种是公平的.两个的区别在于公平锁总是按照先来就先获得锁,非公平锁是谁抢到就算谁的.接下来看公平锁的实现:  </p><h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><p>锁主要是通过acquire()实现锁住,acquire(1)方法是AQS中定义好的方法,acquire首先会调用自己所实现的tryacquire()方法,如果不成功则加入队列中,成功就直接获取到锁.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法如果有不了解,可以先去看我另一篇文章<a href="https://1fishman.github.io/2019/04/06/synchronized%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">AQS详解</a></p><h3 id="boolean-tryAcquire-int-acquires"><a href="#boolean-tryAcquire-int-acquires" class="headerlink" title="boolean tryAcquire(int acquires)"></a>boolean tryAcquire(int acquires)</h3><p>首先判断锁状态是否为0,如果为0,在判断阻塞队列中是否有前驱,如果没有前驱则设置此线程为拥有锁的线程.如果状态不为0,查看是否是自己拥有锁,如果不是返回false;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><p>非公平锁与公平所实现基本一样,但是是首先直接去获取锁,如果获取不到则加入队列,获取到就已经用有锁.<br>非公平锁有一点就是能够极大的提高系统吞吐量,公平所因为是先来先获得锁,所以在切换锁的时候会有很大的系统调度开销,而非公平锁是直接抢占,所以不会有很大的系统开销.但是可能会造成线程饥饿</p><h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><p>主要的一些方法都是通过调用内部类Sync的方法实现的.其实也就是用AQS定义好的框架来进行实现.这里就不一一说明了.有兴趣可以自己去看看源码</p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码阅读 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS源码解读</title>
      <link href="/2019/04/06/AQS%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/04/06/AQS%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="AbstractQueueSynchronizer"><a href="#AbstractQueueSynchronizer" class="headerlink" title="AbstractQueueSynchronizer"></a>AbstractQueueSynchronizer</h1><p>定义了一套多线程访问共享资源的同步框架<br>首先维护了一个volatile state状态量 和 一个阻塞队列,是FIFO队列,队列使用链表实现.state的访问方式有三种</p><ul><li>getstate()</li><li>setState()</li><li>compareAndSetState()<br>AQS 定义了两种资源共享状态,一种是独占(Exclusive 如ReentrantLock),一种是共享(Share可以同时多个线程执行).<br>不同的自定义同步实现器在实现时只需要实现共享资源state的获取和释放.至于具体的等待队列的维护与修改,顶层已了.自定义经实现好同步器主要实现一下几个方法.  </li><li>isHeldExclusive():表示该线程是否独占资源,只有用到condition才需要实现</li><li>tryAcquire():独占方式,尝试去获取资源,成功返回true,失败放回false</li><li>tryRelease():独占方式:尝试去释放资源</li><li>tryAcquireShared(int): 共享方式,尝试获取资源,负数表示失败,0表示成功,但没有剩余资源,正数表示成功并且有资源</li><li>tryReleaseShared(int): 共享方式:尝试释放资源,如果释放后允许释放后续等待资源返回true,否则放回false</li></ul><p>以ReentrantLock为例,首先初始化state为0,表示未锁定状态.一旦调用lock.lock(),会尝试调用tryAcquire()并且将state+1,此时其他线程会获取锁失败,知道unlock()讲state置为0,在获取到此锁的时候,可以继续获取,但是每次都会是state+1.<br>CountDownLatch 中,任务分为N个子线程执行,state初始化为N,这个N个子线程是并行执行的,每个子线程执行完之后会countDown()一次,state会通过CAS减一,等待所有的线程都执行完之后,在unpark()会调用主线程继续执行自己的工作.</p><h2 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h2><p>队列是通过Node来保持一个队列的,就相当于链表中的普通节点,保存了同步的线程以及线程的状态,上一个节点,下一个节点.: </p><ul><li>int waitStatus 共有四种状态:<ul><li>CANCELLED: 值为1,在等待过程中被中断,需要从队列中取消该节点.</li><li>SIGNAL :值为-1,后继节点的线程处于等待状态,当前节点的线程如果释放了同步状态或取消,将会通知后集节点,使后继节点的线程得意运行.</li><li>CONDITION :值为-2,表示该节点处于等待队列中，节点的线程等待在condition上,当其他线程调用Condition.signal()方法会唤醒此线程,进入到同步队列中</li><li>PROPAGATE：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。</li></ul></li><li>Node prev,前驱节点,当节点加入同步队列时被设置   </li><li>Node next,后继节点,  </li><li>Node nextWaiter 等待队列中的后继节点.如果当前节点是共享的,那么这个字段是一个SHARED常量,也就是说节点类型(独占和共享)和等待队列中的后继节点共用同一个字段  </li><li>Thread thread 获取同步状态的线程.<h3 id="方法一览"><a href="#方法一览" class="headerlink" title="方法一览"></a>方法一览</h3>isShared() 判断是否是共享模式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>predecessor() 返回前驱节点,如果前驱为空,抛出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h2 id="AQS内部属性"><a href="#AQS内部属性" class="headerlink" title="AQS内部属性"></a>AQS内部属性</h2><ul><li>Node head: 队列的头结点</li><li>Node tail: 队列的尾节点</li><li>int state: 锁的状态,独占模式下为0或1,0为空闲,1为已经有线程获取到锁.共享模式下为还剩余多少资源</li><li>long spinForTimeoutThreshold = 1000L: 最小的等待时间 在下面讲到</li></ul><h2 id="方法-独占模式方法"><a href="#方法-独占模式方法" class="headerlink" title="方法 独占模式方法"></a>方法 独占模式方法</h2><h3 id="acquire-获取锁"><a href="#acquire-获取锁" class="headerlink" title="acquire() 获取锁"></a>acquire() 获取锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line"><span class="number">3</span>         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line"><span class="number">4</span>         selfInterrupt();</span><br><span class="line"><span class="number">5</span> &#125;</span><br></pre></td></tr></table></figure><p>TryAcquire(arg)如果成功获取锁,则直接返回.而tryAcquire方法需要具体实现<br>addWaiter() 方法则将线程加入到队列的尾部,并标记为独占模式<br>acquireQueued() 使线程在等待队列中获取资源,知道获取资源后返回,如果被中断过,则返回true.</p><h3 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter()"></a>addWaiter()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="comment">//以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）</span></span><br><span class="line"> <span class="number">3</span>     Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line"> <span class="number">4</span>     </span><br><span class="line"> <span class="number">5</span>     <span class="comment">//尝试快速方式直接放到队尾。</span></span><br><span class="line"> <span class="number">6</span>     Node pred = tail;</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">8</span>         node.prev = pred;</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;<span class="comment">//利用CAS进行替换</span></span><br><span class="line"><span class="number">10</span>             pred.next = node;</span><br><span class="line"><span class="number">11</span>             <span class="keyword">return</span> node;</span><br><span class="line"><span class="number">12</span>         &#125;</span><br><span class="line"><span class="number">13</span>     &#125;</span><br><span class="line"><span class="number">14</span>     </span><br><span class="line"><span class="number">15</span>     <span class="comment">//上一步失败则通过enq入队。</span></span><br><span class="line"><span class="number">16</span>     enq(node);</span><br><span class="line"><span class="number">17</span>     <span class="keyword">return</span> node;</span><br><span class="line"><span class="number">18</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="enq-Node"><a href="#enq-Node" class="headerlink" title="enq(Node)"></a>enq(Node)</h3><p>如果直接添加到队尾失败则使用enq方法加入队尾<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="comment">//CAS"自旋"，直到成功加入队尾</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"> <span class="number">4</span>         Node t = tail;</span><br><span class="line"> <span class="number">5</span>         <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 队列为，空创建一个空的标志结点作为head结点，并将tail也指向它。</span></span><br><span class="line"> <span class="number">6</span>             <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line"> <span class="number">7</span>                 tail = head;</span><br><span class="line"> <span class="number">8</span>         &#125; <span class="keyword">else</span> &#123;<span class="comment">//正常流程，放入队尾</span></span><br><span class="line"> <span class="number">9</span>             node.prev = t;</span><br><span class="line"><span class="number">10</span>             <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line"><span class="number">11</span>                 t.next = node;</span><br><span class="line"><span class="number">12</span>                 <span class="keyword">return</span> t;</span><br><span class="line"><span class="number">13</span>             &#125;</span><br><span class="line"><span class="number">14</span>         &#125;</span><br><span class="line"><span class="number">15</span>     &#125;</span><br><span class="line"><span class="number">16</span> &#125;</span><br></pre></td></tr></table></figure></p><p>使用CAS自旋,直到成功加入队尾</p><h2 id="acquireQueued-Node-int"><a href="#acquireQueued-Node-int" class="headerlink" title="acquireQueued(Node int)"></a>acquireQueued(Node int)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//标记是否成功拿到资源</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="number">4</span>         <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//标记等待过程中是否被中断过</span></span><br><span class="line"> <span class="number">5</span>         </span><br><span class="line"> <span class="number">6</span>         <span class="comment">//又是一个“自旋”！</span></span><br><span class="line"> <span class="number">7</span>         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"> <span class="number">8</span>             <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//拿到前驱</span></span><br><span class="line"> <span class="number">9</span>             <span class="comment">//如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。</span></span><br><span class="line"><span class="number">10</span>             <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line"><span class="number">11</span>                 setHead(node);<span class="comment">//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。</span></span><br><span class="line"><span class="number">12</span>                 p.next = <span class="keyword">null</span>; <span class="comment">// setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！</span></span><br><span class="line"><span class="number">13</span>                 failed = <span class="keyword">false</span>;</span><br><span class="line"><span class="number">14</span>                 <span class="keyword">return</span> interrupted;<span class="comment">//返回等待过程中是否被中断过</span></span><br><span class="line"><span class="number">15</span>             &#125;</span><br><span class="line"><span class="number">16</span>             </span><br><span class="line"><span class="number">17</span>             <span class="comment">//如果自己可以休息了，就进入waiting状态，直到被unpark()</span></span><br><span class="line"><span class="number">18</span>             <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line"><span class="number">19</span>                 parkAndCheckInterrupt()) <span class="comment">//parkAndCheckiInterrupt方法会进行检查是否被中断过,并且阻塞线程,此处用自旋是为了保证唤醒的节点能够同步的获取到锁.</span></span><br><span class="line"><span class="number">20</span>                 interrupted = <span class="keyword">true</span>;<span class="comment">//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true</span></span><br><span class="line"><span class="number">21</span>         &#125;</span><br><span class="line"><span class="number">22</span>     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="number">23</span>         <span class="keyword">if</span> (failed)</span><br><span class="line"><span class="number">24</span>             cancelAcquire(node);</span><br><span class="line"><span class="number">25</span>     &#125;</span><br><span class="line"><span class="number">26</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h3><p>用于检查状态,看看自己是否可以去休息,也就是阻塞<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="keyword">int</span> ws = pred.waitStatus;<span class="comment">//拿到前驱的状态</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line"> <span class="number">4</span>         <span class="comment">//如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了</span></span><br><span class="line"> <span class="number">5</span>         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> <span class="number">6</span>     <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="number">7</span>         <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 8          * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。</span></span><br><span class="line"><span class="comment"> 9          * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！</span></span><br><span class="line"><span class="comment">10          */</span></span><br><span class="line"><span class="number">11</span>         <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="number">12</span>             node.prev = pred = pred.prev;</span><br><span class="line"><span class="number">13</span>         &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line"><span class="number">14</span>         pred.next = node;</span><br><span class="line"><span class="number">15</span>     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">16</span>          <span class="comment">//如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！</span></span><br><span class="line"><span class="number">17</span>         compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line"><span class="number">18</span>     &#125;</span><br><span class="line"><span class="number">19</span>     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">20</span> &#125;</span><br></pre></td></tr></table></figure></p><p>###　parkAndCheckInterrupt()　<br>将进程阻塞，并且返回中断状态.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="doAcquireInterruptibly-int-arg"><a href="#doAcquireInterruptibly-int-arg" class="headerlink" title="doAcquireInterruptibly(int arg)"></a>doAcquireInterruptibly(int arg)</h3><p>此方法为支持中断的获取资源,如果在过程中发生了中断,则方法会抛出中断并且返回<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">//首先看是否能够获取资源,获取不到则不会取消</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)<span class="comment">//如果failed=true,说明没有获取到资源,并且有过中断,因为中断后会返回并且抛出异常.则取消该节点.</span></span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="doAcquireNanos-int-arg-long-nanosTimeout"><a href="#doAcquireNanos-int-arg-long-nanosTimeout" class="headerlink" title="doAcquireNanos(int arg, long nanosTimeout)"></a>doAcquireNanos(int arg, long nanosTimeout)</h3><p>是支持超时的获取同步状态,在时间限制到的情况下会直接返回false,否则获取到同步状态则返回true<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;<span class="comment">//计算出deadline时间</span></span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);<span class="comment">//将此节点加入队列</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//自旋</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//获取前驱,与普通获取一样</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime(); <span class="comment">//再次判断是否超时</span></span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<span class="comment">//判断是否可以阻塞</span></span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)<span class="comment">//必须得经过一次spinForTimeoutThreshold</span></span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                    <span class="comment">//如果nanosTimeout小于spinForTimeoutThreshold,将不会是线程进入超时等待,则会进入一个自旋的过程.原因在于非常短的超时无法做到十分精确,如果这个时候在进行超时等待,会让nanoTimeout的超时从整体上变现的不精确.</span></span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();<span class="comment">//如果线程被中断过,则会抛出一个异常并且放回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)<span class="comment">//如果没有获得资源或则被中断或者超时都会取消此节点.</span></span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>realease</strong><br>会释放指定量的资源,首先执行tryrelease()方法,此方法为继承者实现.如果彻底释放,会唤醒队列中的其他线程来获取资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line"><span class="number">3</span>         Node h = head;    <span class="comment">//找到头结点</span></span><br><span class="line"><span class="number">4</span>         <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)<span class="comment">//在头结点不为空的情况下并且waitStatus不为0也就是不是刚初始化的情况</span></span><br><span class="line"><span class="number">5</span>             unparkSuccessor(h);    <span class="comment">//唤醒等待队列里的下一个线程</span></span><br><span class="line"><span class="number">6</span>         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="number">7</span>     &#125;</span><br><span class="line"><span class="number">8</span>     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">9</span> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor()"></a><strong>unparkSuccessor()</strong></h3><p>用来唤醒等待对垒中的下一个线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="comment">//这里，node一般为当前线程所在的结点。</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line"> <span class="number">4</span>     <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)<span class="comment">//置零当前线程所在的结点状态，允许失败。</span></span><br><span class="line"> <span class="number">5</span>         compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"> <span class="number">6</span> </span><br><span class="line"> <span class="number">7</span>     Node s = node.next;<span class="comment">//找到下一个需要唤醒的结点s</span></span><br><span class="line"> <span class="number">8</span>     <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;<span class="comment">//如果为空或已取消,则从尾节点开始找,知道找到第一个有效的节点</span></span><br><span class="line"> <span class="number">9</span>         s = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">10</span>         <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line"><span class="number">11</span>             <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)<span class="comment">//从这里可以看出，&lt;=0的结点，都是还有效的结点。</span></span><br><span class="line"><span class="number">12</span>                 s = t;</span><br><span class="line"><span class="number">13</span>     &#125;</span><br><span class="line"><span class="number">14</span>     <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line"><span class="number">15</span>         LockSupport.unpark(s.thread);<span class="comment">//唤醒</span></span><br><span class="line"><span class="number">16</span> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h2><p>和独占模式差不多,但是在共享模式只有当前线程是头结点的下一个节点的时候,才可以去获取资源,有剩余的话会唤醒后续的节点,不会隔着来.</p><h3 id="acquireShared-int-arg"><a href="#acquireShared-int-arg" class="headerlink" title="acquireShared(int arg)"></a>acquireShared(int arg)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)<span class="comment">//尝试直接获取,小于0说明没有资源</span></span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="doAcquireShared-int-arg"><a href="#doAcquireShared-int-arg" class="headerlink" title="doAcquireShared(int arg)"></a>doAcquireShared(int arg)</h3><p>与独占模式相同,只不过在加入队列的节点模式改变成了共享模式,还有一点就是在共享模式下如果还有剩余资源则会继续唤醒之后的节点.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先以共享方式加入队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//标志位检查是否呗中断过</span></span><br><span class="line">        <span class="comment">// 与独占模式相同,自旋保证获取资源,</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//加入阻塞队列之后进行中断检查,如果中断过则取消节点.</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="doAcquireSharedInterruptibly-int-arg"><a href="#doAcquireSharedInterruptibly-int-arg" class="headerlink" title="doAcquireSharedInterruptibly(int arg)"></a>doAcquireSharedInterruptibly(int arg)</h3><p>这里与独占模式不同,独占模式首先获取资源,将头结点设置为当前节点,获取不到则阻塞,并且被中断过就抛出异常,在这里首先会获取资源,设置头结点之后多了一条propagate操作.在这个会在判断后继节点是否为shared的,如果是,则会唤醒.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;<span class="comment">//如果还有资源,进入下一个方法</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="setHeadAndPropagate-node-r"><a href="#setHeadAndPropagate-node-r" class="headerlink" title="setHeadAndPropagate(node, r)"></a>setHeadAndPropagate(node, r)</h3><p>在这里会先看后继节点,如果后继节点是shared状态则会继续唤醒后集节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">        setHead(node);</span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">~~~ </span><br><span class="line"></span><br><span class="line">### doReleaseShared()</span><br><span class="line">首先先看头结点,如果头结点为signal状态,则会唤醒头结点的下一个节点.如果状态为<span class="number">0</span>,则讲状态转换为propagate状态,继续向下传播.</span><br><span class="line">~~~java</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);<span class="comment">//在这里会唤醒h节点之后的一个等待节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="unparkSuccessor-Node-node"><a href="#unparkSuccessor-Node-node" class="headerlink" title="unparkSuccessor(Node node)"></a>unparkSuccessor(Node node)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)<span class="comment">//这里从后向前遍历主要是保证了在共享模式下可能要唤醒多个,保证了每次唤醒的节点都是最开始的那个节点,如果从前向后遍历的话,可能会被已经唤醒的节点所打断,导致再次唤醒已经唤醒的节点. </span></span><br><span class="line">        <span class="comment">// 还有一点就是从后向前便利保证了能够将失效的节点能更快的被回收.</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cancelAcquire-Node-node"><a href="#cancelAcquire-Node-node" class="headerlink" title="cancelAcquire(Node node)"></a>cancelAcquire(Node node)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">//节点为空则直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    node.thread = <span class="keyword">null</span>; <span class="comment">//将节点的线程置位空,方便GC</span></span><br><span class="line">    Node pred = node.prev;<span class="comment">// 找到前驱节点</span></span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)<span class="comment">//这里找到第一个有效的前驱节点</span></span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    node.waitStatus = Node.CANCELLED; <span class="comment">// 将此节点状态设置为取消状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果节点为尾节点,并且设置尾节点为最后一个有效节点,则把尾节点的next设置为null//有助于GC</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则将前驱节点替换为node的后继节点</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;<span class="comment">//如果前驱节点不为为头结点并且前驱节点的状态为signal而且线程不为空.</span></span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);<span class="comment">//将前驱有效节点的下一个节点设置为node的下一个节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);<span class="comment">//如果前驱节点是头结点,就唤醒node之前的前驱节点.</span></span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类ConditionObject"><a href="#内部类ConditionObject" class="headerlink" title="内部类ConditionObject"></a>内部类ConditionObject</h1><p>实现 Condition接口和serializable接口<br>condition的实现主要包括等待队列,等待和通知.等待队列是一个FIFO的队列,如果线程调用了Condition.await()方法,则会释放锁,构造成节点加入等待队列并进入等待状态.这里节点复用了同步器的节点定义.</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性:"></a>属性:</h2><ul><li>Node firstWaiter: 第一个等待节点</li><li>Node lastWaiter: 最后一个等待节点</li></ul><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法:"></a>主要方法:</h2><h3 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h3><p>调用await()方法回事当前线程进入等待队列并且释放锁,同事状态变为等待状态.在返回时,当前线程一定获取了Condition相关联的锁.<br>从队列的角度看await()方法,调用await()方法,相当于同步队列的首节点移动到了Condition的等待队列中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为此时节点还获取有锁,所以不会产生竞争,直接赋值就可以</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//当前线程加入等待队列中</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">//释放同步状态</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123; <span class="comment">//这里判断是否应该等待,看节点状态是否为Condition状态</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);<span class="comment">//阻塞</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<span class="comment">//加入竞争中</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###　addConditionWaiter()<br>将节点加入到condition等带队列中.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();<span class="comment">//断开已经取消的节点链</span></span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);<span class="comment">//创建一个新的节点.</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="unlinkCancelledWaiters"><a href="#unlinkCancelledWaiters" class="headerlink" title="unlinkCancelledWaiters()"></a>unlinkCancelledWaiters()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    Node trail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h3><p>唤醒第一个节点,如果当前线程没有获取锁,则抛出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="doSignal"><a href="#doSignal" class="headerlink" title="doSignal()"></a>doSignal()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;<span class="comment">//循环唤醒下一个线程</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transferForSignal-Node-first"><a href="#transferForSignal-Node-first" class="headerlink" title="transferForSignal(Node first)"></a>transferForSignal(Node first)</h3><p>将节点设置状态为0,然后在加入队尾,在唤醒线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);<span class="comment">//这里唤醒线程后,线程会从await()方法的while循环中退出(isOnSyncQueue(Node node)方法返回ture,节点已经在同步队列中)借着在调用同步器的acquireQueued()方法加入竞争</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法:"></a>其他方法:</h2><ul><li>hasQueuedThreads() 返回是否有阻塞线程</li><li>hasContended 返回是否有线程在执行</li><li>isQueued(Thread thread) 返回当前线程是否在阻塞中</li><li>getQueueLength() 返回队列的长度</li><li>Collection<thread> getQueuedThreads 返回正在阻塞的线程</thread></li><li>getExclusiveQueuedThreads() 返回独占状态的阻塞线程,返回一个线程集合Collection<thread></thread></li><li>getSharedQueuedThreads() 返回共享状态下的线程集合</li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码阅读 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>timSort源码剖析</title>
      <link href="/2019/04/05/timSort%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2019/04/05/timSort%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="TimSort"><a href="#TimSort" class="headerlink" title="TimSort"></a>TimSort</h1><p>timsort是jdk自带的一种特别高效的排序算法,大致思想使用的是归并排序,但是内部细节做了许多的优化.<br>在timsort中,主要是为待排序数组分为很多个run块,通过讲这些run块进行归并排序.最后实现总体排序.每个run块的大小为16-32大小.<br>优化地方: </p><ul><li>当待排序数组长度小于32就使用二分排序算法</li><li>分为多个run块,在通过把run块的起始位置和长度压入栈中,在进行合并.</li><li>在找到一个run块的时候会首先判断数组中有序元素的个数.通过二分排序从第一个无序的元素开始排序,加快排序速度</li><li>在进行合并的时候会进行”去头”,”去尾”操作,是的归并操作加快速度.</li></ul><h2 id="sort-T-a-int-lo-int-hi-Comparator-lt-super-T-gt-c-T-work-int-workBase-int-workLen"><a href="#sort-T-a-int-lo-int-hi-Comparator-lt-super-T-gt-c-T-work-int-workBase-int-workLen" class="headerlink" title="sort(T[] a, int lo, int hi, Comparator&lt;? super T&gt; c, T[] work, int workBase, int workLen)"></a>sort(T[] a, int lo, int hi, Comparator&lt;? super T&gt; c, T[] work, int workBase, int workLen)</h2><p>timsort对外的唯一接口.并且只能本包内访问<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Comparator&lt;? <span class="keyword">super</span> T&gt; c,</span></span></span><br><span class="line"><span class="function"><span class="params">                         T[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> c != <span class="keyword">null</span> &amp;&amp; a != <span class="keyword">null</span> &amp;&amp; lo &gt;= <span class="number">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nRemaining  = hi - lo;</span><br><span class="line">        <span class="comment">//小于2不用排序,直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (nRemaining &lt; <span class="number">2</span>) </span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        <span class="comment">// 看是否小于min_merge,如果小于就直接二分排序,没必要进行复杂的timsort.</span></span><br><span class="line">        <span class="keyword">if</span> (nRemaining &lt; MIN_MERGE) &#123;</span><br><span class="line">            <span class="comment">//下面有详细说明.返回的是从lo开始已经有序的个数,对二分排序用</span></span><br><span class="line">            <span class="keyword">int</span> initRunLen = countRunAndMakeAscending(a, lo, hi, c);</span><br><span class="line">            <span class="comment">// 从第一没有排好序位置开始进行二分排序</span></span><br><span class="line">            binarySort(a, lo, hi, lo + initRunLen, c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个时候开始真正的timsort</span></span><br><span class="line">        TimSort&lt;T&gt; ts = <span class="keyword">new</span> TimSort&lt;&gt;(a, c, work, workBase, workLen);</span><br><span class="line">        <span class="comment">//主要将数组分为一个个的minRun,最后在进行合并,如果长度为2的n次幂,minRun为32,否则为16-32之间的数.</span></span><br><span class="line">        <span class="keyword">int</span> minRun = minRunLength(nRemaining);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//再次找到a中已经有序的元素个数</span></span><br><span class="line">            <span class="keyword">int</span> runLen = countRunAndMakeAscending(a, lo, hi, c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果有序个数小于上面的最小minRun的话,就找到</span></span><br><span class="line">            <span class="keyword">if</span> (runLen &lt; minRun) &#123;</span><br><span class="line">                <span class="keyword">int</span> force = nRemaining &lt;= minRun ? nRemaining : minRun;</span><br><span class="line">                binarySort(a, lo, lo + force, lo + runLen, c);</span><br><span class="line">                runLen = force;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将此run块放入run数组中.</span></span><br><span class="line">            ts.pushRun(lo, runLen);</span><br><span class="line">            <span class="comment">//这里之心合并操作.</span></span><br><span class="line">            ts.mergeCollapse();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Advance to find next run</span></span><br><span class="line">            lo += runLen;</span><br><span class="line">            nRemaining -= runLen;</span><br><span class="line">        &#125; <span class="keyword">while</span> (nRemaining != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Merge all remaining runs to complete sort</span></span><br><span class="line">        <span class="keyword">assert</span> lo == hi;</span><br><span class="line">        ts.mergeForceCollapse();</span><br><span class="line">        <span class="keyword">assert</span> ts.stackSize == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="minRunLength"><a href="#minRunLength" class="headerlink" title="minRunLength"></a>minRunLength</h2><p>就是获得一个最小的Run块的大小,大小在16-32之间.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minRunLength</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> n &gt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;      <span class="comment">// Becomes 1 if any 1 bits are shifted off</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt;= MIN_MERGE) &#123;</span><br><span class="line">        r |= (n &amp; <span class="number">1</span>);</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n + r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="countRunAndMakeAscending-a-lo-hi-c"><a href="#countRunAndMakeAscending-a-lo-hi-c" class="headerlink" title="countRunAndMakeAscending(a, lo, hi, c)"></a>countRunAndMakeAscending(a, lo, hi, c)</h2><p>找到a数组中从lo开始并且已经有序的元素个数,返回已经有序的元素个数.在这里如果逆序在翻转一下,变为有序.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">countRunAndMakeAscending</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> lo &lt; hi;</span><br><span class="line">        <span class="keyword">int</span> runHi = lo + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (runHi == hi)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找见a从lo开始已经有序的元素个数</span></span><br><span class="line">        <span class="keyword">if</span> (c.compare(a[runHi++], a[lo]) &lt; <span class="number">0</span>) &#123; <span class="comment">// Descending</span></span><br><span class="line">            <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="number">1</span>]) &lt; <span class="number">0</span>)</span><br><span class="line">                runHi++;</span><br><span class="line">            reverseRange(a, lo, runHi);<span class="comment">//如果是逆序则翻转</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                              <span class="comment">// Ascending</span></span><br><span class="line">            <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="number">1</span>]) &gt;= <span class="number">0</span>)</span><br><span class="line">                runHi++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> runHi - lo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="binarySort-T-a-int-lo-int-hi-int-start-Comparator-lt-super-T-gt-c"><a href="#binarySort-T-a-int-lo-int-hi-int-start-Comparator-lt-super-T-gt-c" class="headerlink" title="binarySort(T[] a, int lo, int hi, int start,Comparator&lt;? super T&gt; c)"></a>binarySort(T[] a, int lo, int hi, int start,Comparator&lt;? super T&gt; c)</h2><p>此方法就是二分排序,二分排序就是插入排序,但是在寻找向前面插入的位置是通过二分法来查找,然后在插入的.<br>此方法是在a数组中排序从lo到hi的元素,从start开始.</p><h2 id="private-void-mergeCollapse"><a href="#private-void-mergeCollapse" class="headerlink" title="private void mergeCollapse()"></a>private void mergeCollapse()</h2><p>这个方法主要是用来合并已经分好的几个Run块的.但是是有条件的;</p><ol><li>runLen[i - 3] &gt; runLen[i - 2] + runLen[i - 1]</li><li>runLen[i - 2] &gt; runLen[i - 1]<br>满足这两个条件才合并,否则什么都不做.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeCollapse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最少都得有两个块,如果没有,则退出.</span></span><br><span class="line">        <span class="keyword">while</span> (stackSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = stackSize - <span class="number">2</span>;<span class="comment">// stackSize为块的数量,-2相当与倒数第二个块</span></span><br><span class="line">            <span class="comment">//如果块的数量大于三个并且倒数第三个Run块大小小于后面两个块的大小和进入</span></span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; runLen[n-<span class="number">1</span>] &lt;= runLen[n] + runLen[n+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//如果倒数第三个块比倒一块的大小小,就从倒数第三个块进行合并</span></span><br><span class="line">                <span class="keyword">if</span> (runLen[n - <span class="number">1</span>] &lt; runLen[n + <span class="number">1</span>])</span><br><span class="line">                    n--;</span><br><span class="line">                mergeAt(n);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (runLen[n] &lt;= runLen[n + <span class="number">1</span>]) &#123;<span class="comment">//第一个块大小小于第二个块大小,就合并这两个</span></span><br><span class="line">                mergeAt(n);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则什么都不做    </span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// Invariant is established</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="private-void-mergeAt-int-i"><a href="#private-void-mergeAt-int-i" class="headerlink" title="private void mergeAt(int i)"></a>private void mergeAt(int i)</h2><p>再来看mergeAt(i)方法,这个方法主要就是合并在run块数组中从i开始的两个块.run[i]和run[i+1]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> base1 = runBase[i];</span><br><span class="line"><span class="keyword">int</span> len1 = runLen[i];</span><br><span class="line"><span class="keyword">int</span> base2 = runBase[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> len2 = runLen[i + <span class="number">1</span>];</span><br><span class="line">runLen[i] = len1 + len2;</span><br><span class="line"><span class="comment">//观察如果是倒数第三个块,就倒数第一个块赋值给倒数第二个块</span></span><br><span class="line"><span class="keyword">if</span> (i == stackSize - <span class="number">3</span>) &#123;</span><br><span class="line">    runBase[i + <span class="number">1</span>] = runBase[i + <span class="number">2</span>];</span><br><span class="line">    runLen[i + <span class="number">1</span>] = runLen[i + <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">stackSize--;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算run2的第一个元素能插入到run1的位置</span></span><br><span class="line"><span class="comment">//如果属于run1的最后一个位置,就不需要排序,因为run1中的所有元素都比run2中的小,直接返回,</span></span><br><span class="line"><span class="comment">//这样可以忽略掉run1中之前的位置</span></span><br><span class="line"><span class="keyword">int</span> k = gallopRight(a[base2], a, base1, len1, <span class="number">0</span>, c);</span><br><span class="line"><span class="keyword">assert</span> k &gt;= <span class="number">0</span>;</span><br><span class="line">base1 += k;</span><br><span class="line">len1 -= k;</span><br><span class="line"><span class="keyword">if</span> (len1 == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算run1的最后一个元素在run2中插入的位置,进行去尾.</span></span><br><span class="line">len2 = gallopLeft(a[base1 + len1 - <span class="number">1</span>], a, base2, len2, len2 - <span class="number">1</span>, c);</span><br><span class="line"><span class="keyword">assert</span> len2 &gt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (len2 == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经过上面的“去头”和“去尾”之后，保证run1的开始元素一定大</span></span><br><span class="line"><span class="comment">// 于run2的开始元素，并且run1的最后一个数据一定大于run2的最后一个数据  </span></span><br><span class="line"><span class="comment">// 然后进行合并,通过两个len的大小找到最好的合并方式</span></span><br><span class="line"><span class="keyword">if</span> (len1 &lt;= len2)</span><br><span class="line">    mergeLo(base1, len1, base2, len2);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    mergeHi(base1, len1, base2, len2);</span><br></pre></td></tr></table></figure></p><h2 id="private-void-mergeLo-int-base1-int-len1-int-base2-int-len2"><a href="#private-void-mergeLo-int-base1-int-len1-int-base2-int-len2" class="headerlink" title="private void mergeLo(int base1, int len1, int base2, int len2)"></a>private void mergeLo(int base1, int len1, int base2, int len2)</h2><p>mergeLo方法 合并两个run块<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">    T[] a = <span class="keyword">this</span>.a; <span class="comment">//首先赋值到一个临时数组中</span></span><br><span class="line">    T[] tmp = ensureCapacity(len1);</span><br><span class="line">    <span class="keyword">int</span> cursor1 = tmpBase;</span><br><span class="line">    <span class="keyword">int</span> cursor2 = base2;   <span class="comment">// Indexes int a</span></span><br><span class="line">    <span class="keyword">int</span> dest = base1;      <span class="comment">// Indexes int a</span></span><br><span class="line">    <span class="comment">//先吧a从base1开始的元素赋值到tmp从tmpbase开始的元素,赋值len1个元素,因为len1肯定是最小的元素</span></span><br><span class="line">    System.arraycopy(a, base1, tmp, cursor1, len1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先肯定run2的第一个元素小于run1的第一个元素,因为上面都已经去头了</span></span><br><span class="line">    a[dest++] = a[cursor2++];</span><br><span class="line">    <span class="keyword">if</span> (--len2 == <span class="number">0</span>) &#123;<span class="comment">//如果run2长度为0,则赋值tmp过去,</span></span><br><span class="line">        System.arraycopy(tmp, cursor1, a, dest, len1);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len1 == <span class="number">1</span>) &#123;<span class="comment">//如果run1只剩下一个元素,所以只需要先把run2复制过去,再讲Run1的唯一元素赋值过去</span></span><br><span class="line">        System.arraycopy(a, cursor2, a, dest, len2);</span><br><span class="line">        a[dest + len2] = tmp[cursor1]; <span class="comment">// Last elt of run 1 to end of merge</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> T&gt; c = <span class="keyword">this</span>.c;  <span class="comment">// Use local variable for performance</span></span><br><span class="line">    <span class="keyword">int</span> minGallop = <span class="keyword">this</span>.minGallop;    <span class="comment">// 定义一个最小Gallop</span></span><br><span class="line">outer: <span class="comment">//定义跳出什么循环</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在这里有一个思路就是合并两个run,但是会记录两个块中连续个数的数量,如果连续个数的数量大于minGallop也就是7,那就会进入Gallop模式.此模式就是通过"去头","去尾"来减少比较次数</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> count1 = <span class="number">0</span>; <span class="comment">// Number of times in a row that first run won</span></span><br><span class="line">        <span class="keyword">int</span> count2 = <span class="number">0</span>; <span class="comment">// Number of times in a row that second run won</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Do the straightforward thing until (if ever) one run starts</span></span><br><span class="line"><span class="comment">         * winning consistently.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> len1 &gt; <span class="number">1</span> &amp;&amp; len2 &gt; <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//开始比较</span></span><br><span class="line">            <span class="keyword">if</span> (c.compare(a[cursor2], tmp[cursor1]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                a[dest++] = a[cursor2++];</span><br><span class="line">                count2++;</span><br><span class="line">                count1 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (--len2 == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a[dest++] = tmp[cursor1++];</span><br><span class="line">                count1++;</span><br><span class="line">                count2 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (--len1 == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当有一个块有连续大于另一个块的次数超过minGallop的时候,进入gallop模式</span></span><br><span class="line">        &#125; <span class="keyword">while</span> ((count1 | count2) &lt; minGallop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * One run is winning so consistently that galloping may be a</span></span><br><span class="line"><span class="comment">         * huge win. So try that, and continue galloping until (if ever)</span></span><br><span class="line"><span class="comment">         * neither run appears to be winning consistently anymore.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> len1 &gt; <span class="number">1</span> &amp;&amp; len2 &gt; <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//如上,去掉run1的头部</span></span><br><span class="line">            count1 = gallopRight(a[cursor2], tmp, cursor1, len1, <span class="number">0</span>, c);</span><br><span class="line">            <span class="keyword">if</span> (count1 != <span class="number">0</span>) &#123;</span><br><span class="line">                System.arraycopy(tmp, cursor1, a, dest, count1);</span><br><span class="line">                dest += count1;</span><br><span class="line">                cursor1 += count1;</span><br><span class="line">                len1 -= count1;</span><br><span class="line">                <span class="keyword">if</span> (len1 &lt;= <span class="number">1</span>) <span class="comment">// len1 == 1 || len1 == 0</span></span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">            &#125;</span><br><span class="line">            a[dest++] = a[cursor2++];</span><br><span class="line">            <span class="keyword">if</span> (--len2 == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="comment">// 去掉run2的尾部</span></span><br><span class="line">            count2 = gallopLeft(tmp[cursor1], a, cursor2, len2, <span class="number">0</span>, c);</span><br><span class="line">            <span class="keyword">if</span> (count2 != <span class="number">0</span>) &#123;</span><br><span class="line">                System.arraycopy(a, cursor2, a, dest, count2);</span><br><span class="line">                dest += count2;</span><br><span class="line">                cursor2 += count2;</span><br><span class="line">                len2 -= count2;</span><br><span class="line">                <span class="keyword">if</span> (len2 == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">            &#125;</span><br><span class="line">            a[dest++] = tmp[cursor1++];</span><br><span class="line">            <span class="keyword">if</span> (--len1 == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            minGallop--;</span><br><span class="line">            <span class="comment">//在此模式每多循环一次minGallop减少1</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (count1 &gt;= MIN_GALLOP | count2 &gt;= MIN_GALLOP);</span><br><span class="line">        <span class="keyword">if</span> (minGallop &lt; <span class="number">0</span>)</span><br><span class="line">            minGallop = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//在离开这个gallop模式后值增加2</span></span><br><span class="line">        minGallop += <span class="number">2</span>;  <span class="comment">// Penalize for leaving gallop mode</span></span><br><span class="line">    &#125;  <span class="comment">// End of "outer" loop</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.minGallop = minGallop &lt; <span class="number">1</span> ? <span class="number">1</span> : minGallop;  <span class="comment">// Write back to field</span></span><br><span class="line">    <span class="keyword">if</span> (len1 == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">assert</span> len2 &gt; <span class="number">0</span>;</span><br><span class="line">        System.arraycopy(a, cursor2, a, dest, len2);</span><br><span class="line">        a[dest + len2] = tmp[cursor1]; <span class="comment">//  Last elt of run 1 to end of merge</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len1 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">            <span class="string">"Comparison method violates its general contract!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> len2 == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">assert</span> len1 &gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//最后将tmp的值赋值到a中</span></span><br><span class="line">        System.arraycopy(tmp, cursor1, a, dest, len1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql查询优化</title>
      <link href="/2019/04/03/mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
      <url>/2019/04/03/mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h2><h3 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h3><ul><li>查询不需要的记录</li><li>多表关联是返回全部列</li><li>总是取出全部列 ,尽量不要使用select *,去除全部列,可能会使优化器无法完成索引覆盖扫描这种优化.还会为服务器带来额外的IO,内存和cpu开销.</li><li>重复查询相同的数据.可以将经常用到的数据放在缓存里,避免重复查询数据库<h3 id="是否在扫描额外的数据"><a href="#是否在扫描额外的数据" class="headerlink" title="是否在扫描额外的数据"></a>是否在扫描额外的数据</h3>确定了查询的数据列后,还应该看看查询是否为了返回结果是否扫描了过多的数据.对于mysql,最简单的衡量开销指标有三个:<ul><li>响应时间 包括服务时间(就是查询时间)和排队时间(也就是等待锁或者等待其他I/O完成的时间)</li><li>扫描行数 </li><li>返回行数<br>对于查询最好的就是扫描行数/返回行数在1:1到10:1之间<br>可以尝试使用索引覆盖扫描,把所有需要的列放入索引中,这样存储引擎就可以不需要回表就可以返回列,或者重写查询.以更优的方式查询结果</li></ul></li></ul><h2 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h2><ul><li>考虑是用一个大的查询还是用很多个小的查询.因为在实际应用中,如果一个查询很大的话可能会导致锁住整个表,耗尽系统资源,阻塞后面的查询.因此有时候可以使用多个小的查询来返回结果,最后在把小的查询组合起来.</li><li>分解关联查询,因为每个数据库都有自己的缓存,如果分解大的查询可以更好的应用自己的缓存</li></ul><h2 id="mysql查询执行过程"><a href="#mysql查询执行过程" class="headerlink" title="mysql查询执行过程"></a>mysql查询执行过程</h2><ol><li>客户端向服务器发送一条消息(这是半双工的,意思是同一时间只有一方能够发送数据)</li><li>服务器先查询缓存,如果缓存命中,直接返回给客服,否则进入下一阶段</li><li>服务端进行sql解析,预处理,在根据优化器生成对应的查询计划</li><li>调用存储引擎API查询数据,</li><li>将结果返回给客户端.</li></ol><h2 id="mysql能处理的优化类型"><a href="#mysql能处理的优化类型" class="headerlink" title="mysql能处理的优化类型"></a>mysql能处理的优化类型</h2><ul><li>重新定义关联表的顺序</li><li>将外部连接转化程内部连接  </li><li>使用等价变换规则, 比如 5=5 and a&gt;5 换成 a&gt;5</li><li>优化count(),min(),max(),如果在索引列找最小值,直接搜索最左边的值</li><li>覆盖索引查询,如果索引的列包含所有要查询的列的时候就无须在回表查询</li><li>子查询优化   </li><li>提前终止查询: 比如使用limit语句的时候,发现语句够了,就会直接终止  </li><li>列表in的比较,在mysql中,会把在in中的数据进行排序,然后在根据二分查找来查询,明显提高了查找速度.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中断与中断处理</title>
      <link href="/2019/04/01/%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/"/>
      <url>/2019/04/01/%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断就是使硬件发出通知给处理器,比如在敲击键盘的时候,键盘控制器会发送一个中断,通知操作系统有键按下,让操作系统尽快处理<br>不同的设备对应的中断不同,每个中断都通过一个唯一的数字标志,使得操作系统能够对中断进行区分,继而提供不同的处理程序.这些中断值通常被成为中断请求(IRQ)线.每个IRQ先都会被关联一个数值量;例如在经典的PC机上,IRQ 0 是时钟中断.1是键盘中断.但是对于连接在PCi总线上的设备而言,中断是动态分配的.</p><h2 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h2><p>在操作系统中,在响应一个特定中断的时候,内核会执行一个函数,该函数叫做中断处理程序,产生中断的每个设备都有一个特定的中断处理程序.<br>对于操作系统而言,中断处理程序在尽可能短的时间内完成很重要;但是对于硬件而言,操作系统能迅速对其中断进行服务也非常重要.<br>所以中断程序首先要通知硬件设备中断已接受.还要运行中断函数处理.例如要把硬件网络接收到的数据拷贝到内存,但是现在网速特别块,所以之后的工作量会很大.因此将响应中断分为两部分.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在操作系统中一般中断分为两部分.中断处理程序是上半部---接收到一个中断,它就立即开始执行,但是只做有严格实现的工作.例如对接收的中断进行应答或复位硬件.能够允许稍后完后才能的工作会推迟到下半部.</span><br></pre></td></tr></table></figure></p><p>linux的中断处理程序是无须重入的,但一个给定的中断处理程序正在执行,相应的中断线上的所有处理器上的都会被屏蔽掉.</p><h2 id="注册中断处理程序"><a href="#注册中断处理程序" class="headerlink" title="注册中断处理程序"></a>注册中断处理程序</h2><p>每个设备都有相关的驱动程序,如果硬件使用中断,应该注册一个中断处理程序.通过reques_irq()函数注册,并且激活给定的中断线,以处理中断.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">request_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq,  表示要分配的中断号</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="comment">//handler是一个指针,指向处理这个中断的实际中断处理程序</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">irq_handler_t</span> handler, </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="comment">//标志位: IRQF_FISABLED 表示不响应其他中断;IRQF_TIMER为系统定时器的中断处理而准备的;IRQF_SHARED:表明在多个中断处理程序之间共享中断线.</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">unsigned</span> <span class="keyword">long</span> flags, </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="comment">// 是与中断相关的设备的ASCII文本表示</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">char</span> *name, </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="comment">// 拥有共享中断线,dev讲提供唯一的标识信息.当删除中断处理程序需要释放时,能够知道删除哪一个.</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">void</span> *dev)</span></span></span><br></pre></td></tr></table></figure></p><p>request_irq()成功会返回0,否则返回非0值.<br>这里request_irq函数可能会睡眠,因此不能在中断上下文或者其他不允许阻塞的代码中调用该函数.<br>中断线共享仅仅指的是中断号共享,并不是处理程序共享.</p><h2 id="共享的中断处理程序"><a href="#共享的中断处理程序" class="headerlink" title="共享的中断处理程序"></a>共享的中断处理程序</h2><p>对于共享中断线的设备,首先request_irq()的flag参数为IRQF_SHARED标志<br>对于dev参数必须唯一.指向任意设备结构的指针就可以满足这一要求;通常选择设备结构,因为它是唯一的.这里设备结构是你要想响应的设备结构.<br>中断处理程序必须能够区分它的设备是否真的产生了中断.这需要硬件的支持,也需要程序中有相关的处理逻辑.</p><h2 id="释放中断处理程序"><a href="#释放中断处理程序" class="headerlink" title="释放中断处理程序"></a>释放中断处理程序</h2><p>使用free_irq(unsigned int irq, void *dev);<br>如果中断线是共享的,则传入dev参数,删除此dev对应的处理程序,知道最后一个处理程序时才会被禁用此中断线;如果不是共享的,则在删除处理程序的同时禁用此中断线.  </p><h2 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h2><p>上面提到了中断上下文.其实在执行一个中断处理程序时,内核处于中断上下文中.<br>中断上下文和进程没有瓜葛,因为没有后备进程,所以中断上下文不可以睡眠.因此在中断上下文中不能调用睡眠的函数.<br>在中断上下文具有较为严格的时间限制,所有的中断处理程序必须尽可能的迅速,简洁.尽量把工作从中断处理程序中分离出来.放在下半部执行．<br>在每个处理中有一个中断处理栈，大小为１页. 在栈中处理中断程序.</p><h2 id="中断控制"><a href="#中断控制" class="headerlink" title="中断控制"></a>中断控制</h2><p>禁止指定中断线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void disable_irq(unsigned int irq);//会等待当前处理程序完成后才返回</span><br><span class="line">void diable_irq_nosync(unsigned int irq);//强制返回</span><br><span class="line">void enable_irq(unsigned int irq);</span><br><span class="line">void synchronized_irq(unsigned int irq);</span><br></pre></td></tr></table></figure></p><p>前两个函数禁止中断控制器上制定的中断线.synchronized_irq等待一个特定的中断处理程序的退出.<br>对于调用禁用函数可以嵌套,但是有一点就是调用多少次禁用中断线函数,就要调用多少次启动函数才能够重新激活.</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux进程调度</title>
      <link href="/2019/04/01/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
      <url>/2019/04/01/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><p>linux采用两种不同的优先级范围.<br>第一种用nice值,范围为-20到19,越低优先级越高.<br>第二种是实时优先级,从0-99,越大优先级越高.  </p><p>在系统调度中总会解决I/O密集型的和CPU密集型的进程的协调,I/O密集型要求有更好的响应性,而执行时间应该更少.CPU要求有更好的执行时间,而不是花费更多时间用来调度.</p><h2 id="调度器类"><a href="#调度器类" class="headerlink" title="调度器类"></a>调度器类</h2><p>linux调度器是以模块方式提供的,每个模块化结构成为调度器类,允许多种不同的可动态添加的调度算法并存.每个调度器都有一个优先级,会按照优先级顺序便利调度类,拥有一个可执行进程的最高优先级的调度器类胜出,选出下面要执行的一个程序.</p><h2 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h2><p>在linux中采用公平调度算法CFS,允许每个进程运行一段时间,循环轮转,选择运行最少的进程作为下一个运行进程,而不在采用分配给每个进程时间片.CFS在所有可运行进程总数基础上计算出一个进程应该运行多久.通过用nice值作为进程获得处理器运行比的权重,越低的优先级进程获得更低的处理器使用权重.在这里nice值并不是通过绝对值值来进行划分的,而是通过相对差值来分配权重的.避免了优先级差值不大的两个进程得到的处理器使用权重相差过大的情况.<br>在这里是由操作系统来确定进程应该使用多久,假设nice=0的进程分配时间片为100ms,则另一个nice=20的进程时间片为5ms.<br>如果按照绝对差值来分配时间片可能出现下列情况:<br>两个进程优先级分别为0和1,一个为100ms,则另一个为95ms,这时候基本没有问题.但是当两个优先级分别为18和19,那么一个为10ms,一个为5ms,这样前者比后者多出了一倍的处理器时间,是相对不合理的.</p><h2 id="linux调度的实现"><a href="#linux调度的实现" class="headerlink" title="linux调度的实现"></a>linux调度的实现</h2><h3 id="时间记账"><a href="#时间记账" class="headerlink" title="时间记账"></a><strong>时间记账</strong></h3><p>CFS不再有时间片概念,维护每个进程运行的时间的记账,保存在进程描述符中.<br>每个进程都有一个虚拟运行时间,该运行时间的计算是所有可运行进程总数的标准化(是被加权的).虚拟时间以ns为单位.CFS使用vruntime变量来记录一个程序到底运行了多长时间以及还应该在运行多久.<br>vruntime运行时间计算如下:</p><ul><li>首先的到当前进程的执行时间,然后在根据当前可运行进程总数对运行时间进行加权计算,在将权重值与当前进程的vruntime相加.</li><li>vruntime准确的测量给定进程的运行时间,而且可知道谁应该是下一个被运行的进程,因为他是根据运行时间最小的进程优先调度的.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static const int prio_to_weight[40] = &#123;</span><br><span class="line">/* -20 */     88761,     71755,     56483,     46273,     36291,</span><br><span class="line">/* -15 */     29154,     23254,     18705,     14949,     11916,</span><br><span class="line">/* -10 */      9548,      7620,      6100,      4904,      3906,</span><br><span class="line">/*  -5 */      3121,      2501,      1991,      1586,      1277,</span><br><span class="line">/*   0 */      1024,       820,       655,       526,       423,</span><br><span class="line">/*   5 */       335,       272,       215,       172,       137,</span><br><span class="line">/*  10 */       110,        87,        70,        56,        45,</span><br><span class="line">/*  15 */        36,        29,        23,        18,        15,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在linux中CPU nice值每下降1,则获得多10%的cpu时间,而这10%有一个相对的概念.就像上文所说的,如果用绝对的方式来说那么就会出现两倍的差距;<br>这里一张表表明了40个优先级的权重表示.比如有A,B两个进程nice都为0,那么每个的cpu占用时间都为1024/(1024+1024)=50%(这里1024代表上面0对应的权值),但是B要少出10的cpu时间的话,则将B的nice值加1,则应该有1024/(1024+B的权值) = 45%;算出来B的权值为837,与820相差不多,所以这里是按照相对值来计算获得的cpu时间的.<br><strong>以上参考博文 <a href="https://blog.csdn.net/u010173306/article/details/46743491" target="_blank" rel="noopener">https://blog.csdn.net/u010173306/article/details/46743491</a></strong></p><h3 id="进程选择"><a href="#进程选择" class="headerlink" title="进程选择"></a><strong>进程选择</strong></h3><p>主要选择具有最小vruntime的任务;通过使用红黑树来保存这些进程</p><h3 id="调度器入口"><a href="#调度器入口" class="headerlink" title="调度器入口"></a><strong>调度器入口</strong></h3><p>进程调度的时候首先是以调度器的优先级为顺序从高到低一次检查每个调度类,并且从最高优先级的调度类中选择最高优先级的进程.这样就找到最高优先级的进程,也就是vruntime最小的进程.</p><h3 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a><strong>睡眠和唤醒</strong></h3><p>内核操作: 首先标记自己为休眠状态,从可执行红黑树中移除,放入等待队列.在选择一个可执行进程.唤醒相反.<br>等待队列: 维护一个等待队列,当要休眠的时候放入到等待队列.编码是一个while(true)循环中等待,在被唤醒后在此检查条件是否为真,为真就会退出循环,将自己移除出等待队列,加入可执行红黑树中.<br>唤醒:唤醒操作通过函数wake_up()进行,唤醒指定的等待队列上的所有进程.</p><h2 id="抢占和上下文切换"><a href="#抢占和上下文切换" class="headerlink" title="抢占和上下文切换"></a>抢占和上下文切换</h2><p>内核中有一个参数为need_resched参数,表明是否需要重新执行一次调度,此过程称为抢占.</p><ul><li>用户抢占:　在系统调用返回用户控件或从中断处理程序返回用户空间是会发生用户抢占，当然need_resched参数要设置</li><li>内核抢占: 除了need_resched参数还有一个preempt_count参数,表明是否持有锁,在preempt_count为0的时候说明在执行任务持有锁,此次抢占是不安全的.直到当前新进程持有的所有锁都释放了,才会重新执行调度.</li></ul><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用在用户空间进程和硬件设备之间添加了一个中间层,作用有三个:</p><ol><li>首先为用户空间提供了一种硬件的抽象接口.这样应用程序不管磁盘类型和介质,不管文件系统是那种类型</li><li>第二 系统调用保证了系统的稳定和安全.作为硬件设备和应用程序之间的中间人可以基于权限,用户类型和其他规则对需要进行的访问进行裁决,避免引用程序不正当的使用硬件设备.</li><li>每个进程都运行在虚拟系统中,而在用户控件和系统的其余部分提供这样一层公共接口.在linux中系统调用是用户空间进入内核的唯一手段,除了异常和陷入外,他们是内核唯一的合法入口.</li></ol><p>在linux中,每个系统调用被赋予一个系统调用号. 这样就可以根据一个独一无二的号关联系统调用.进程不会提及系统调用的名称.如果一个系统调用删除,他所占用的系统调用号不允许被回收,否则以前编译过的代码调用此系统调用,但是事实上却调用另一个系统调用容易引发错误.如果一个系统调用被删除会用sys_ni_syscall()替换,此函数返回-ENOSYS.内核记录了系统调用表中的所有已注册过的系统调用的列表.存储在sys_call_table中. </p><h3 id="指定系统调用"><a href="#指定系统调用" class="headerlink" title="指定系统调用"></a><strong>指定系统调用</strong></h3><p>所有的系统调用陷入内核方式都一样,所以必须把系统调用号一并创给内核.在x86上,系统调用号通过eax寄存器传递给内核.在陷入内核前,用户空间就把响应系统调用锁对应的号放入eax中.</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a><strong>参数传递</strong></h3><p>调用系统调用有时需要一些参数,最简单的办法是把参数也存放在寄存器里.在ebx ecx edx esi edi按照顺序存放前5个参数.应用用一个单独的寄存器存放指向所有这些参数在用户空间地址的指针.给用户空间的返回值也通过寄存器传递.</p><h3 id="调用参数限制"><a href="#调用参数限制" class="headerlink" title="调用参数限制"></a><strong>调用参数限制</strong></h3><p>在进行系统调用之前会先检查他们所有的参数是否合法有效.在接受用户空间的指针前,内核必须保证:</p><ul><li>指针指向的内存区域属于用户空间.进程决不能哄骗内核去读内核空间的数据.</li><li>指针指向的内核区域在进程的地址空间里.进程绝不能哄骗内核去读取其他进程的数据.</li><li>如果是读,该内存可以被读;如果是写操作,该内存应该可写;如果是可执行,必须被标记为可执行.进程局不能绕过内存访问限制.<br>如果调用成功返回0,否则返回标准-EFAULT<h3 id="绑定系统调用"><a href="#绑定系统调用" class="headerlink" title="绑定系统调用"></a><strong>绑定系统调用</strong></h3>在编写完一个系统调用后，要把它注册程一个正式的系统调用</li></ul><ol><li>首先在系统调用表的最后加入一个表项,从0开始算起</li><li>系统调用必须被编译进内核映像(不能被编译成模块)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux进程管理</title>
      <link href="/2019/03/31/linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2019/03/31/linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="linux进程管理"><a href="#linux进程管理" class="headerlink" title="linux进程管理"></a>linux进程管理</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><blockquote><p>进程就是处于执行期的程序.但不仅仅局限于一段可执行程序代码.通常还要包括其他资源,打开的文件,挂起的信号,内核内部数据,处理器状态,一个或多个具有内存映射的内存地址空间或多个执行线程.<br>在linux中线程是一种特殊的进程.是内核调度的对象.每个线程都拥有一个独立的程序计数器,进程栈,一组进程寄存器.<br>在操作系统中进程提供两种虚拟机机制:虚拟处理器和虚拟内存   </p></blockquote><h2 id="进程描述符及任务结构"><a href="#进程描述符及任务结构" class="headerlink" title="进程描述符及任务结构"></a>进程描述符及任务结构</h2><blockquote><p>内核把进程的列表存在叫任务队列的双向循环链表中.链表的每一项类型为task_struct称为进程描述符的机构.主要保存有:打开的文件,进程的地址空间,挂起的信号,进程的状态等.<br>每个进程都有自己的父进程,父进程可以管理其子进程.通过fork创建子进程.<br>在系统中有一个进程内核栈,动态生成task_struct只需要在栈上创建一个新结构thread_info,thread_info中包含了指向task_struct的指针.</p></blockquote><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在linux中线程创建和普通进程的创建类似,但是在调用clone()(也就是复制父进程的资源)的时候要传入参数指明要共享的资源.因为在linux中线程和普通的进程差不多,只是有共享资源.  </p><h2 id="进程终结"><a href="#进程终结" class="headerlink" title="进程终结"></a>进程终结</h2><p>原因: </p><ul><li>可能是自身引起,调用exit()系统调用.可能被其他进程终结.<br>过程:</li></ul><ol><li>讲tast_struct中标志成员设置为PF_EXITING.</li><li>调用deltimersync()删除任意内核定时器.根据返回结果,确保没有定时器在排队,也没有定时器处理程序在运行.</li><li>如果BSD(伯克利软件套件)进程记账功能开启,do_exit()调用函数输出记账信息.</li><li>调用exit_files和exit_fs(),分别递减文件描述符,文件系统数据的引用技术.如果每个引用技术为0,则可以释放</li><li>把退出代码保存下来,供父进程随时检索.</li><li>调用exit_notify()向父进程发送信号,给子进程重新找养父,养父为线程组的其他线程或者init进程,并吧线程状态设置为EXIT_ZOMBIE</li><li>切换新的进程</li></ol><blockquote><p>在每个进程结束之后都会保留一个退出信息,等待父进程调用结束后在被释放.(通过wait()函数).<br>如果父进程在子进程之前退出,就会在当前线程组内找一个线程作为父亲,如果不行就让init进程做他们的父进程.保证了每个进程死亡之后不会僵死,会有父进程回收此进程的退出代码信息</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/30/hello-world/"/>
      <url>/2019/03/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
